#pragma once

#include <glm/glm.hpp>
#include <vector>
#include <string>
#include <cstdint>
#include <functional>

// A river represented as a spline with varying width
struct RiverSpline {
    std::vector<glm::vec3> controlPoints;  // World-space positions (x, height, z)
    std::vector<float> widths;             // Width at each control point (based on flow)
    float totalFlow = 0.0f;                // Total accumulated flow for this river
};

// A detected lake/pond
struct Lake {
    glm::vec2 position;                    // Center position in world XZ
    float waterLevel;                      // Surface height in world Y
    float radius;                          // Approximate radius
    float area;                            // Surface area in world units squared
    float depth;                           // Maximum depth
    std::vector<glm::vec2> shoreline;      // Detailed shoreline points (optional)
};

// Complete water placement data generated by erosion simulation
struct WaterPlacementData {
    std::vector<RiverSpline> rivers;
    std::vector<Lake> lakes;
    float seaLevel = 0.0f;                 // Sea level threshold

    // Flow accumulation data (normalized 0-1, can be used as texture)
    std::vector<float> flowAccumulation;
    uint32_t flowMapWidth = 0;
    uint32_t flowMapHeight = 0;

    // Statistics
    uint32_t numDropletsSimulated = 0;
    float maxFlowValue = 0.0f;
};

// Configuration for erosion simulation
struct ErosionConfig {
    std::string sourceHeightmapPath;       // Path to source heightmap PNG
    std::string cacheDirectory;            // Directory for cached results

    // Simulation parameters
    uint32_t numDroplets = 500000;         // Number of water droplets to simulate
    uint32_t maxDropletLifetime = 512;     // Max steps per droplet
    float inertia = 0.3f;                  // How much droplet maintains direction (0-1)
    float gravity = 10.0f;                 // Gravity strength for acceleration
    float evaporationRate = 0.02f;         // Water loss per step
    float minWater = 0.001f;               // Minimum water before droplet dies

    // Output resolution (can be lower than source for performance)
    uint32_t outputResolution = 4096;      // Flow map resolution

    // River extraction parameters
    float riverFlowThreshold = 0.1f;       // Min normalized flow to be considered river (0-1)
    float riverMinWidth = 2.0f;            // Minimum river width in world units
    float riverMaxWidth = 50.0f;           // Maximum river width in world units
    float splineSimplifyTolerance = 5.0f;  // Douglas-Peucker simplification tolerance

    // Lake detection parameters
    float lakeMinArea = 100.0f;            // Minimum lake area in world units squared
    float lakeMinDepth = 1.0f;             // Minimum depression depth to be a lake

    // Sea level
    float seaLevel = 0.0f;                 // Height below which is considered sea

    // Terrain parameters (should match terrain config)
    float terrainSize = 16384.0f;          // World size of terrain
    float minAltitude = 0.0f;              // Min altitude in source heightmap
    float maxAltitude = 200.0f;            // Max altitude in source heightmap
};

// Progress callback for erosion simulation
using ErosionProgressCallback = std::function<void(float progress, const std::string& status)>;

// Erosion simulator - generates water placement data from heightmap
class ErosionSimulator {
public:
    ErosionSimulator() = default;
    ~ErosionSimulator() = default;

    // Check if cached results exist and are valid
    bool isCacheValid(const ErosionConfig& config) const;

    // Run erosion simulation and generate water placement data
    // Returns true on success
    bool simulate(const ErosionConfig& config, ErosionProgressCallback progressCallback = nullptr);

    // Load cached results (call after isCacheValid returns true)
    bool loadFromCache(const ErosionConfig& config);

    // Get the generated water placement data
    const WaterPlacementData& getWaterData() const { return waterData; }
    WaterPlacementData& getWaterData() { return waterData; }

    // Get cache file paths
    static std::string getFlowMapPath(const std::string& cacheDir);
    static std::string getRiversPath(const std::string& cacheDir);
    static std::string getLakesPath(const std::string& cacheDir);
    static std::string getMetadataPath(const std::string& cacheDir);
    static std::string getPreviewPath(const std::string& cacheDir);

private:
    // Load source heightmap at full resolution
    bool loadSourceHeightmap(const std::string& path, float minAlt, float maxAlt);

    // Core erosion simulation
    void simulateDroplets(const ErosionConfig& config, ErosionProgressCallback progressCallback);

    // Single droplet simulation step
    void simulateDroplet(const ErosionConfig& config, uint32_t startX, uint32_t startY);

    // Extract rivers from flow accumulation
    void extractRivers(const ErosionConfig& config, ErosionProgressCallback progressCallback);

    // Detect lakes from terrain depressions
    void detectLakes(const ErosionConfig& config, ErosionProgressCallback progressCallback);

    // Trace a river path from a high-flow starting point
    RiverSpline traceRiver(uint32_t startX, uint32_t startY, const ErosionConfig& config);

    // Simplify spline using Douglas-Peucker algorithm
    void simplifySpline(RiverSpline& spline, float tolerance);

    // Flood fill to find lake extent
    Lake floodFillLake(uint32_t startX, uint32_t startY, const ErosionConfig& config,
                       std::vector<bool>& visited);

    // Helper: get height at position with bilinear interpolation
    float getHeightAt(float x, float y) const;

    // Helper: get gradient at position
    glm::vec2 getGradientAt(float x, float y) const;

    // Helper: convert between pixel and world coordinates
    glm::vec2 pixelToWorld(float px, float py, float terrainSize) const;
    glm::vec2 worldToPixel(float wx, float wy, float terrainSize) const;

    // Save/load cache
    bool saveToCache(const ErosionConfig& config) const;
    bool saveMetadata(const ErosionConfig& config) const;
    bool savePreviewImage(const ErosionConfig& config) const;
    bool loadAndValidateMetadata(const ErosionConfig& config) const;

    // Source heightmap data (full resolution)
    std::vector<float> sourceHeight;       // Normalized [0,1]
    uint32_t sourceWidth = 0;
    uint32_t sourceHeight_ = 0;

    // Flow accumulation during simulation (at output resolution)
    std::vector<float> flowAccum;
    uint32_t flowWidth = 0;
    uint32_t flowHeight = 0;

    // Visited flags for river tracing
    std::vector<bool> riverVisited;

    // Output data
    WaterPlacementData waterData;
};

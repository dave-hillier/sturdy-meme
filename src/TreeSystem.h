#pragma once

#include "EnvironmentSettings.h"
#include <vulkan/vulkan.h>
#include <vk_mem_alloc.h>
#include <glm/glm.hpp>
#include <vector>
#include <string>

#include "BufferUtils.h"
#include "ParticleSystem.h"
#include "UBOs.h"

// Parametric tree definition - describes a tree type via parameters
struct TreeDefinition {
    // Trunk parameters
    float trunkHeight;          // Height of trunk
    float trunkRadius;          // Base radius of trunk
    float trunkTaper;           // How much trunk narrows toward top (0-1)
    float trunkBend;            // Natural lean/curve amount

    // Branching parameters
    uint32_t branchLevels;      // 0 = trunk only, 1 = primary branches, etc.
    float branchAngle;          // Angle from parent (radians)
    float branchSpread;         // Angular spread around parent
    float branchLengthRatio;    // Length relative to parent
    float branchRadiusRatio;    // Radius relative to parent
    uint32_t branchesPerLevel;  // How many branches at each level

    // Canopy parameters
    glm::vec3 canopyCenter;     // Offset from trunk top
    glm::vec3 canopyExtent;     // Ellipsoid radii
    float leafDensity;          // Leaves per cubic meter
    float leafSize;             // Base leaf size
    float leafSizeVariance;     // Variation in leaf size

    // Animation parameters
    float windInfluence;        // How much wind affects this tree
    float branchStiffness;      // Resistance to wind

    // Visual parameters
    uint32_t leafPaletteIndex;  // Index into color palette
    uint32_t barkTextureIndex;  // Bark texture index

    float padding[2];           // Padding for alignment
};

// Per-tree instance data
struct TreeInstance {
    glm::vec3 position;         // World position of trunk base
    float rotation;             // Y-axis rotation (radians)
    float scale;                // Uniform scale
    float age;                  // 0-1, affects size and fullness
    uint32_t definitionIndex;   // Which TreeDefinition to use
    float hash;                 // Unique random seed for variation
};

// Branch instance - generated by compute shader
struct BranchInstance {
    glm::vec4 basePosition;     // xyz = base position, w = base radius
    glm::vec4 tipPosition;      // xyz = tip position, w = tip radius
    glm::vec4 controlPoint1;    // xyz = bezier control point 1, w = hash
    glm::vec4 controlPoint2;    // xyz = bezier control point 2, w = unused
    glm::uvec4 metadata;        // x = parent index, y = depth, z = tree index, w = flags
};

// Push constants for tree rendering
struct TreePushConstants {
    float time;
    int cascadeIndex;           // For shadow pass
    float padding[2];
};

// Uniforms for tree compute shader
struct TreeUniforms {
    glm::vec4 cameraPosition;
    glm::vec4 frustumPlanes[6];
    float maxDrawDistance;
    float lodTransitionStart;
    float lodTransitionEnd;
    float terrainSize;
    float terrainHeightScale;
    float time;
    uint32_t treeCount;
    float padding;
};

class TreeSystem {
public:
    struct InitInfo : public ParticleSystem::InitInfo {
        VkRenderPass shadowRenderPass;
        uint32_t shadowMapSize;
    };

    TreeSystem() = default;
    ~TreeSystem() = default;

    bool init(const InitInfo& info);
    void destroy(VkDevice device, VmaAllocator allocator);

    void updateDescriptorSets(VkDevice device, const std::vector<VkBuffer>& uniformBuffers,
                              VkImageView shadowMapView, VkSampler shadowSampler,
                              const std::vector<VkBuffer>& windBuffers,
                              const std::vector<VkBuffer>& lightBuffers,
                              VkImageView terrainHeightMapView, VkSampler terrainHeightMapSampler);

    void updateUniforms(uint32_t frameIndex, const glm::vec3& cameraPos, const glm::mat4& viewProj,
                        float terrainSize, float terrainHeightScale, float time);

    void recordResetAndCompute(VkCommandBuffer cmd, uint32_t frameIndex, float time);
    void recordDraw(VkCommandBuffer cmd, uint32_t frameIndex, float time);
    void recordShadowDraw(VkCommandBuffer cmd, uint32_t frameIndex, float time, uint32_t cascadeIndex);

    // Double-buffer management
    void advanceBufferSet();

    // Tree management
    void addTree(const glm::vec3& position, float rotation = 0.0f, float scale = 1.0f, uint32_t definitionIndex = 0);
    void clearTrees();
    uint32_t getTreeCount() const { return static_cast<uint32_t>(trees.size()); }

    // Tree definition management
    void addTreeDefinition(const TreeDefinition& def);
    void setDefaultTreeDefinition();

    void setEnvironmentSettings(const EnvironmentSettings* settings) { environmentSettings = settings; }

private:
    bool createBuffers();
    bool createComputeDescriptorSetLayout();
    bool createComputePipeline();
    bool createGraphicsDescriptorSetLayout();
    bool createGraphicsPipeline();
    bool createShadowPipeline();
    bool createDescriptorSets();
    bool createExtraPipelines();
    void destroyBuffers(VmaAllocator allocator);
    void uploadTreeData();

    VkDevice getDevice() const { return particleSystem.getDevice(); }
    VmaAllocator getAllocator() const { return particleSystem.getAllocator(); }
    VkRenderPass getRenderPass() const { return particleSystem.getRenderPass(); }
    VkDescriptorPool getDescriptorPool() const { return particleSystem.getDescriptorPool(); }
    const VkExtent2D& getExtent() const { return particleSystem.getExtent(); }
    const std::string& getShaderPath() const { return particleSystem.getShaderPath(); }
    uint32_t getFramesInFlight() const { return particleSystem.getFramesInFlight(); }

    SystemLifecycleHelper::PipelineHandles& getComputePipelineHandles() { return particleSystem.getComputePipelineHandles(); }
    SystemLifecycleHelper::PipelineHandles& getGraphicsPipelineHandles() { return particleSystem.getGraphicsPipelineHandles(); }

    ParticleSystem particleSystem;

    VkRenderPass shadowRenderPass = VK_NULL_HANDLE;
    uint32_t shadowMapSize = 0;

    // Shadow pipeline
    VkDescriptorSetLayout shadowDescriptorSetLayout = VK_NULL_HANDLE;
    VkPipelineLayout shadowPipelineLayout = VK_NULL_HANDLE;
    VkPipeline shadowPipeline = VK_NULL_HANDLE;

    // Tree definition buffer (uploaded once, read by compute)
    VkBuffer definitionBuffer = VK_NULL_HANDLE;
    VmaAllocation definitionAllocation = VK_NULL_HANDLE;
    void* definitionMappedPtr = nullptr;

    // Tree instance buffer (uploaded when trees change)
    VkBuffer treeInstanceBuffer = VK_NULL_HANDLE;
    VmaAllocation treeInstanceAllocation = VK_NULL_HANDLE;
    void* treeInstanceMappedPtr = nullptr;

    // Double-buffered storage buffers for generated branches
    static constexpr uint32_t BUFFER_SET_COUNT = 2;
    BufferUtils::DoubleBufferedBufferSet branchBuffers;
    BufferUtils::DoubleBufferedBufferSet indirectBuffers;

    // Uniform buffers (per frame)
    BufferUtils::PerFrameBufferSet uniformBuffers;

    // Descriptor sets for shadow pass
    VkDescriptorSet shadowDescriptorSetsDB[BUFFER_SET_COUNT];

    // Terrain heightmap (for tree placement on terrain)
    VkImageView terrainHeightMapView = VK_NULL_HANDLE;
    VkSampler terrainHeightMapSampler = VK_NULL_HANDLE;

    // Tree data
    std::vector<TreeDefinition> definitions;
    std::vector<TreeInstance> trees;
    bool treesNeedUpload = false;

    // Maximum counts
    static constexpr uint32_t MAX_TREES = 1000;
    static constexpr uint32_t MAX_DEFINITIONS = 16;
    static constexpr uint32_t MAX_BRANCHES = 50000;  // Generated branches per frame
    static constexpr uint32_t VERTICES_PER_BRANCH = 32;  // 8 segments * 4 vertices per ring

    const EnvironmentSettings* environmentSettings = nullptr;
};

#define VMA_IMPLEMENTATION
#include "Renderer.h"
#include "RendererInit.h"
#include "ShaderLoader.h"
#include "BindingBuilder.h"
#include "GraphicsPipelineFactory.h"
#include "MaterialDescriptorFactory.h"
#include "Bindings.h"
#include "VulkanRAII.h"
#include <SDL3/SDL_vulkan.h>
#include <glm/gtc/matrix_transform.hpp>
#include <stdexcept>
#include <cstring>
#include <cmath>
#include <cstddef>
#include <array>
#include <limits>

bool Renderer::init(SDL_Window* win, const std::string& resPath) {
    window = win;
    resourcePath = resPath;

    // Initialize Vulkan context (instance, device, queues, allocator, swapchain)
    if (!vulkanContext.init(window)) {
        SDL_Log("Failed to initialize Vulkan context");
        return false;
    }

    // Get convenience references for the rest of initialization
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();
    VkPhysicalDevice physicalDevice = vulkanContext.getPhysicalDevice();
    VkQueue graphicsQueue = vulkanContext.getGraphicsQueue();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();
    VkFormat swapchainImageFormat = vulkanContext.getSwapchainImageFormat();
    if (!createRenderPass()) return false;
    if (!createDepthResources()) return false;
    if (!createFramebuffers()) return false;
    if (!createCommandPool()) return false;
    if (!createDescriptorSetLayout()) return false;
    if (!createDescriptorPool()) return false;

    // Build shared InitContext for subsystem initialization
    // This centralizes common parameters and reduces duplication
    InitContext initCtx = RendererInit::buildContext(
        vulkanContext, commandPool, &*descriptorManagerPool,
        resourcePath, MAX_FRAMES_IN_FLIGHT);

    // Initialize post-processing systems (PostProcessSystem, BloomSystem)
    if (!RendererInit::initPostProcessing(postProcessSystem, bloomSystem, initCtx, renderPass, swapchainImageFormat)) {
        return false;
    }

    if (!createGraphicsPipeline()) return false;

    // Initialize skinned mesh rendering (GPU skinning for animated characters)
    if (!initSkinnedMeshRenderer()) return false;

    // Initialize sky system (needs HDR render pass from postProcessSystem)
    if (!skySystem.init(initCtx, postProcessSystem.getHDRRenderPass())) return false;

    if (!createCommandBuffers()) return false;

    // Initialize global buffer manager for all per-frame shared buffers
    if (!globalBufferManager.init(allocator, MAX_FRAMES_IN_FLIGHT)) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to initialize GlobalBufferManager");
        return false;
    }

    // Initialize light buffers with empty data
    for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        LightBuffer emptyBuffer{};
        emptyBuffer.lightCount = glm::uvec4(0, 0, 0, 0);
        globalBufferManager.updateLightBuffer(i, emptyBuffer);
    }

    // Initialize shadow system (needs descriptor set layouts for pipeline compatibility)
    if (!shadowSystem.init(initCtx, descriptorSetLayout, skinnedMeshRenderer.getDescriptorSetLayout())) return false;

    // Initialize terrain system BEFORE scene so scene objects can query terrain height
    std::string heightmapPath = resourcePath + "/assets/terrain/isleofwight-0m-200m.png";
    std::string terrainDataPath = resourcePath + "/terrain_data";

    // Load erosion/water placement data (generated by erosion_preprocess tool during build)
    // DISABLED: Slow startup - uncomment when needed
    // ErosionLoadConfig erosionConfig{};
    // erosionConfig.sourceHeightmapPath = heightmapPath;
    // erosionConfig.cacheDirectory = terrainDataPath;
    // // Sea level: real-world 0m altitude maps to worldY = 0 - minAltitude = 15m
    // erosionConfig.seaLevel = 15.0f;
    //
    // if (erosionDataLoader.isCacheValid(erosionConfig)) {
    //     if (erosionDataLoader.loadFromCache(erosionConfig)) {
    //         const auto& waterData = erosionDataLoader.getWaterData();
    //         SDL_Log("Water placement loaded: %zu rivers, %zu lakes",
    //                 waterData.rivers.size(), waterData.lakes.size());
    //     } else {
    //         SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Failed to load erosion data");
    //     }
    // } else {
    //     SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,
    //         "Erosion data not found. Ensure build completed successfully.");
    // }

    // Initialize terrain system with CBT (loads heightmap directly)
    TerrainSystem::TerrainInitParams terrainParams{};
    terrainParams.renderPass = postProcessSystem.getHDRRenderPass();
    terrainParams.shadowRenderPass = shadowSystem.getShadowRenderPass();
    terrainParams.shadowMapSize = shadowSystem.getShadowMapSize();
    terrainParams.texturePath = resourcePath + "/textures";

    TerrainConfig terrainConfig{};
    terrainConfig.size = 16384.0f;
    terrainConfig.maxDepth = 20;
    terrainConfig.minDepth = 5;
    terrainConfig.targetEdgePixels = 16.0f;
    terrainConfig.splitThreshold = 100.0f;
    terrainConfig.mergeThreshold = 50.0f;
    // Load Isle of Wight heightmap (-15m to 200m altitude range, includes beaches below sea level)
    terrainConfig.heightmapPath = resourcePath + "/assets/terrain/isleofwight-0m-200m.png";
    terrainConfig.minAltitude = -15.0f;
    terrainConfig.maxAltitude = 220.0f;
    // heightScale is computed from minAltitude/maxAltitude during init

    // Enable LOD-based tile streaming from preprocessed tile cache
    terrainConfig.tileCacheDir = resourcePath + "/terrain_data";
    terrainConfig.tileLoadRadius = 2000.0f;   // Load high-res tiles within 2km
    terrainConfig.tileUnloadRadius = 3000.0f; // Unload tiles beyond 3km

    if (!terrainSystem.init(initCtx, terrainParams, terrainConfig)) return false;

    // Initialize scene (meshes, textures, objects, lights)
    // Pass terrain height function so objects can be placed on terrain
    SceneBuilder::InitInfo sceneInfo{};
    sceneInfo.allocator = allocator;
    sceneInfo.device = device;
    sceneInfo.commandPool = commandPool;
    sceneInfo.graphicsQueue = graphicsQueue;
    sceneInfo.physicalDevice = physicalDevice;
    sceneInfo.resourcePath = resourcePath;
    sceneInfo.getTerrainHeight = [this](float x, float z) {
        return terrainSystem.getHeightAt(x, z);
    };

    if (!sceneManager.init(sceneInfo)) return false;

    // Initialize snow subsystems (SnowMaskSystem, VolumetricSnowSystem)
    if (!RendererInit::initSnowSubsystems(snowMaskSystem, volumetricSnowSystem, initCtx,
                                          postProcessSystem.getHDRRenderPass())) return false;

    if (!createDescriptorSets()) return false;
    if (!createSkinnedMeshRendererDescriptorSets()) return false;

    // Initialize grass and wind subsystems
    if (!RendererInit::initGrassSubsystem(grassSystem, windSystem, leafSystem, initCtx,
                                          postProcessSystem.getHDRRenderPass(),
                                          shadowSystem.getShadowRenderPass(),
                                          shadowSystem.getShadowMapSize())) return false;

    const EnvironmentSettings* envSettings = &windSystem.getEnvironmentSettings();

    // Get wind buffers for grass descriptor sets
    std::vector<VkBuffer> windBuffers(MAX_FRAMES_IN_FLIGHT);
    for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        windBuffers[i] = windSystem.getBufferInfo(i).buffer;
    }
    grassSystem.updateDescriptorSets(device, globalBufferManager.uniformBuffers.buffers, shadowSystem.getShadowImageView(), shadowSystem.getShadowSampler(), windBuffers, globalBufferManager.lightBuffers.buffers,
                                      terrainSystem.getHeightMapView(), terrainSystem.getHeightMapSampler(),
                                      globalBufferManager.snowBuffers.buffers, globalBufferManager.cloudShadowBuffers.buffers,
                                      cloudShadowSystem.getShadowMapView(), cloudShadowSystem.getShadowMapSampler());

    // Update terrain descriptor sets with shared resources
    terrainSystem.updateDescriptorSets(device, globalBufferManager.uniformBuffers.buffers, shadowSystem.getShadowImageView(), shadowSystem.getShadowSampler(),
                                        globalBufferManager.snowBuffers.buffers, globalBufferManager.cloudShadowBuffers.buffers);

    // Initialize rock system
    if (!RendererInit::initRockSystem(rockSystem, initCtx, terrainConfig.size,
                                       [this](float x, float z) { return terrainSystem.getHeightAt(x, z); })) return false;

    // Update rock descriptor sets now that rock textures are loaded
    {
        MaterialDescriptorFactory factory(device);
        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            MaterialDescriptorFactory::CommonBindings common{};
            common.uniformBuffer = globalBufferManager.uniformBuffers.buffers[i];
            common.uniformBufferSize = sizeof(UniformBufferObject);
            common.shadowMapView = shadowSystem.getShadowImageView();
            common.shadowMapSampler = shadowSystem.getShadowSampler();
            common.lightBuffer = globalBufferManager.lightBuffers.buffers[i];
            common.lightBufferSize = sizeof(LightBuffer);
            common.emissiveMapView = sceneManager.getSceneBuilder().getDefaultEmissiveMap().getImageView();
            common.emissiveMapSampler = sceneManager.getSceneBuilder().getDefaultEmissiveMap().getSampler();
            common.pointShadowView = shadowSystem.getPointShadowArrayView(i);
            common.pointShadowSampler = shadowSystem.getPointShadowSampler();
            common.spotShadowView = shadowSystem.getSpotShadowArrayView(i);
            common.spotShadowSampler = shadowSystem.getSpotShadowSampler();
            common.snowMaskView = snowMaskSystem.getSnowMaskView();
            common.snowMaskSampler = snowMaskSystem.getSnowMaskSampler();
            // Placeholder texture for unused PBR bindings (13-16)
            common.placeholderTextureView = sceneManager.getSceneBuilder().getWhiteTexture().getImageView();
            common.placeholderTextureSampler = sceneManager.getSceneBuilder().getWhiteTexture().getSampler();

            MaterialDescriptorFactory::MaterialTextures mat{};
            mat.diffuseView = rockSystem.getRockTexture().getImageView();
            mat.diffuseSampler = rockSystem.getRockTexture().getSampler();
            mat.normalView = rockSystem.getRockNormalMap().getImageView();
            mat.normalSampler = rockSystem.getRockNormalMap().getSampler();
            factory.writeDescriptorSet(rockDescriptorSets[i], common, mat);
        }
    }

    // Initialize weather and leaf subsystems
    if (!RendererInit::initWeatherSubsystems(weatherSystem, leafSystem, initCtx,
                                              postProcessSystem.getHDRRenderPass())) return false;

    // Update weather system descriptor sets
    weatherSystem.updateDescriptorSets(device, globalBufferManager.uniformBuffers.buffers, windBuffers,
                                        postProcessSystem.getHDRDepthView(), shadowSystem.getShadowSampler());

    // Connect snow to environment settings and systems
    snowMaskSystem.setEnvironmentSettings(envSettings);
    volumetricSnowSystem.setEnvironmentSettings(envSettings);
    terrainSystem.setSnowMask(device, snowMaskSystem.getSnowMaskView(), snowMaskSystem.getSnowMaskSampler());
    terrainSystem.setVolumetricSnowCascades(device,
        volumetricSnowSystem.getCascadeView(0), volumetricSnowSystem.getCascadeView(1),
        volumetricSnowSystem.getCascadeView(2), volumetricSnowSystem.getCascadeSampler());
    grassSystem.setSnowMask(device, snowMaskSystem.getSnowMaskView(), snowMaskSystem.getSnowMaskSampler());

    // Update leaf system descriptor sets
    leafSystem.updateDescriptorSets(device, globalBufferManager.uniformBuffers.buffers, windBuffers,
                                     terrainSystem.getHeightMapView(), terrainSystem.getHeightMapSampler(),
                                     grassSystem.getDisplacementImageView(), grassSystem.getDisplacementSampler());

    // Initialize atmosphere subsystems (Froxel, AtmosphereLUT, CloudShadow)
    if (!RendererInit::initAtmosphereSubsystems(froxelSystem, atmosphereLUTSystem, cloudShadowSystem,
                                                 postProcessSystem, initCtx, shadowSystem.getShadowImageView(),
                                                 shadowSystem.getShadowSampler(), globalBufferManager.lightBuffers.buffers)) return false;

    // Connect froxel volume to weather system
    weatherSystem.setFroxelVolume(froxelSystem.getScatteringVolumeView(), froxelSystem.getVolumeSampler(),
                                   froxelSystem.getVolumetricFarPlane(), FroxelSystem::DEPTH_DISTRIBUTION);

    // Connect cloud shadow map to terrain system
    terrainSystem.setCloudShadowMap(device, cloudShadowSystem.getShadowMapView(), cloudShadowSystem.getShadowMapSampler());

    // Update cloud shadow bindings across all descriptor sets
    RendererInit::updateCloudShadowBindings(device, sceneManager.getSceneBuilder().getMaterialRegistry(),
                                            rockDescriptorSets, skinnedMeshRenderer,
                                            cloudShadowSystem.getShadowMapView(), cloudShadowSystem.getShadowMapSampler());

    // Initialize Catmull-Clark subdivision system
    float suzanneX = 5.0f, suzanneZ = -5.0f;
    glm::vec3 suzannePos(suzanneX, terrainSystem.getHeightAt(suzanneX, suzanneZ) + 2.0f, suzanneZ);
    if (!RendererInit::initCatmullClarkSystem(catmullClarkSystem, initCtx,
                                              postProcessSystem.getHDRRenderPass(), suzannePos)) return false;
    catmullClarkSystem.updateDescriptorSets(device, globalBufferManager.uniformBuffers.buffers);

    // Create sky descriptor sets now that uniform buffers and LUTs are ready
    if (!skySystem.createDescriptorSets(globalBufferManager.uniformBuffers.buffers, sizeof(UniformBufferObject), atmosphereLUTSystem)) return false;

    // Initialize Hi-Z occlusion culling system
    if (!hiZSystem.init(initCtx, depthFormat)) {
        SDL_Log("Warning: Hi-Z system initialization failed, occlusion culling disabled");
        // Continue without Hi-Z - it's an optional optimization
    } else {
        // Connect depth buffer to Hi-Z system - use HDR depth where scene is rendered
        hiZSystem.setDepthBuffer(postProcessSystem.getHDRDepthView(), depthSampler);

        // Initialize object data for culling
        updateHiZObjectData();
    }

    // Initialize profiler for GPU and CPU timing
    if (!profiler.init(device, physicalDevice, MAX_FRAMES_IN_FLIGHT)) {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Profiler initialization failed - profiling disabled");
        // Continue without profiling - it's optional
    }

    // Initialize water subsystems (WaterSystem, WaterDisplacement, FlowMap, Foam, SSR, TileCull, GBuffer)
    WaterSubsystems waterSubs{waterSystem, waterDisplacement, flowMapGenerator, foamBuffer, ssrSystem, waterTileCull, waterGBuffer};
    if (!RendererInit::initWaterSubsystems(waterSubs, initCtx, postProcessSystem.getHDRRenderPass(),
                                            shadowSystem, terrainSystem, terrainConfig, postProcessSystem, depthSampler)) return false;

    // Create water descriptor sets
    if (!RendererInit::createWaterDescriptorSets(waterSubs, globalBufferManager.uniformBuffers.buffers,
                                                  sizeof(UniformBufferObject), shadowSystem, terrainSystem,
                                                  postProcessSystem, depthSampler)) return false;

    // Initialize tree edit system
    if (!RendererInit::initTreeEditSystem(treeEditSystem, initCtx, postProcessSystem.getHDRRenderPass())) return false;
    treeEditSystem.updateDescriptorSets(device, globalBufferManager.uniformBuffers.buffers);

    if (!createSyncObjects()) return false;

    // Initialize debug line system
    if (!RendererInit::initDebugLineSystem(debugLineSystem, initCtx, postProcessSystem.getHDRRenderPass())) return false;
    SDL_Log("Debug line system initialized");

    // Initialize UBO builder with system references
    UBOBuilder::Systems uboSystems{};
    uboSystems.timeSystem = &timeSystem;
    uboSystems.celestialCalculator = &celestialCalculator;
    uboSystems.shadowSystem = &shadowSystem;
    uboSystems.windSystem = &windSystem;
    uboSystems.atmosphereLUTSystem = &atmosphereLUTSystem;
    uboSystems.froxelSystem = &froxelSystem;
    uboSystems.sceneManager = &sceneManager;
    uboSystems.snowMaskSystem = &snowMaskSystem;
    uboSystems.volumetricSnowSystem = &volumetricSnowSystem;
    uboSystems.cloudShadowSystem = &cloudShadowSystem;
    uboSystems.environmentSettings = &environmentSettings;
    uboBuilder.setSystems(uboSystems);

    // Setup render pipeline stages with lambdas
    setupRenderPipeline();
    SDL_Log("Render pipeline configured");

    return true;
}

void Renderer::setupRenderPipeline() {
    // Clear any existing passes
    renderPipeline.clear();

    // ===== COMPUTE STAGE =====
    // Terrain compute pass (adaptive subdivision)
    renderPipeline.computeStage.addPass("terrain", [this](RenderContext& ctx) {
        if (!terrainEnabled) return;
        profiler.beginGpuZone(ctx.cmd, "TerrainCompute");
        terrainSystem.recordCompute(ctx.cmd, ctx.frameIndex, &profiler.getGpuProfiler());
        profiler.endGpuZone(ctx.cmd, "TerrainCompute");
    });

    // Catmull-Clark subdivision compute pass
    renderPipeline.computeStage.addPass("subdivision", [this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "SubdivisionCompute");
        catmullClarkSystem.recordCompute(ctx.cmd, ctx.frameIndex);
        profiler.endGpuZone(ctx.cmd, "SubdivisionCompute");
    });

    // Grass compute pass (displacement + simulation)
    renderPipeline.computeStage.addPass("grass", [this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "GrassCompute");
        grassSystem.recordDisplacementUpdate(ctx.cmd, ctx.frameIndex);
        grassSystem.recordResetAndCompute(ctx.cmd, ctx.frameIndex, ctx.frame.time);
        profiler.endGpuZone(ctx.cmd, "GrassCompute");
    });

    // Weather particle compute pass
    renderPipeline.computeStage.addPass("weather", [this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "WeatherCompute");
        weatherSystem.recordResetAndCompute(ctx.cmd, ctx.frameIndex, ctx.frame.time, ctx.frame.deltaTime);
        profiler.endGpuZone(ctx.cmd, "WeatherCompute");
    });

    // Snow compute passes (mask + volumetric)
    renderPipeline.computeStage.addPass("snow", [this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "SnowCompute");
        snowMaskSystem.recordCompute(ctx.cmd, ctx.frameIndex);
        volumetricSnowSystem.recordCompute(ctx.cmd, ctx.frameIndex);
        profiler.endGpuZone(ctx.cmd, "SnowCompute");
    });

    // Leaf particle compute pass
    renderPipeline.computeStage.addPass("leaf", [this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "LeafCompute");
        leafSystem.recordResetAndCompute(ctx.cmd, ctx.frameIndex, ctx.frame.time, ctx.frame.deltaTime);
        profiler.endGpuZone(ctx.cmd, "LeafCompute");
    });

    // Water foam persistence compute pass
    renderPipeline.computeStage.addPass("foam", [this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "FoamCompute");
        foamBuffer.recordCompute(ctx.cmd, ctx.frameIndex, ctx.frame.deltaTime,
                                 flowMapGenerator.getFlowMapView(), flowMapGenerator.getFlowMapSampler());
        profiler.endGpuZone(ctx.cmd, "FoamCompute");
    });

    // Cloud shadow map compute pass
    renderPipeline.computeStage.addPass("cloudShadow", [this](RenderContext& ctx) {
        if (!cloudShadowSystem.isEnabled()) return;
        profiler.beginGpuZone(ctx.cmd, "CloudShadow");

        // Wind offset for cloud animation
        glm::vec2 windDir = windSystem.getWindDirection();
        float windSpeed = windSystem.getWindSpeed();
        float windTime = windSystem.getTime();
        float cloudTimeScale = 0.02f;
        glm::vec3 windOffset = glm::vec3(windDir.x * windSpeed * windTime * cloudTimeScale,
                                          windTime * 0.002f,
                                          windDir.y * windSpeed * windTime * cloudTimeScale);

        cloudShadowSystem.recordUpdate(ctx.cmd, ctx.frameIndex, ctx.frame.sunDirection, ctx.frame.sunIntensity,
                                        windOffset, windTime * cloudTimeScale, ctx.frame.cameraPosition);
        profiler.endGpuZone(ctx.cmd, "CloudShadow");
    });

    // ===== SHADOW STAGE =====
    renderPipeline.shadowStage.setTerrainCallback([this](VkCommandBuffer cb, uint32_t cascade, const glm::mat4& lightMatrix) {
        if (terrainEnabled) {
            // Need to get frameIndex from somewhere - we'll use currentFrame
            terrainSystem.recordShadowDraw(cb, currentFrame, lightMatrix, static_cast<int>(cascade));
        }
    });

    renderPipeline.shadowStage.setGrassCallback([this](VkCommandBuffer cb, uint32_t cascade, const glm::mat4& lightMatrix) {
        (void)lightMatrix;
        // Need grassTime from ctx - this callback doesn't have access to it
        // For now, use windSystem.getTime() as a proxy
        grassSystem.recordShadowDraw(cb, currentFrame, windSystem.getTime(), cascade);
    });

    renderPipeline.shadowStage.getDescriptorSet = [this](uint32_t frameIndex) -> VkDescriptorSet {
        const auto& materialRegistry = sceneManager.getSceneBuilder().getMaterialRegistry();
        return materialRegistry.getDescriptorSet(0, frameIndex);
    };

    renderPipeline.shadowStage.getSceneObjects = [this]() -> const std::vector<Renderable>& {
        return sceneManager.getRenderables();
    };

    // ===== ATMOSPHERE/FROXEL STAGES =====
    renderPipeline.setFroxelStageFn([this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "Atmosphere");

        UniformBufferObject* ubo = static_cast<UniformBufferObject*>(globalBufferManager.uniformBuffers.mappedPointers[ctx.frameIndex]);
        glm::vec3 sunColor = glm::vec3(ubo->sunColor);

        // Froxel volumetric fog
        froxelSystem.recordFroxelUpdate(ctx.cmd, ctx.frameIndex,
                                        ctx.frame.view, ctx.frame.projection,
                                        ctx.frame.cameraPosition,
                                        ctx.frame.sunDirection, ctx.frame.sunIntensity, sunColor,
                                        shadowSystem.getCascadeMatrices().data(),
                                        ubo->cascadeSplits);

        // Recompute static LUTs if atmosphere parameters changed
        if (atmosphereLUTSystem.needsRecompute()) {
            atmosphereLUTSystem.recomputeStaticLUTs(ctx.cmd);
        }

        // Update sky-view LUT with current sun direction
        atmosphereLUTSystem.updateSkyViewLUT(ctx.cmd, ctx.frameIndex, ctx.frame.sunDirection, ctx.frame.cameraPosition, 0.0f);

        // Update cloud map LUT with wind animation
        glm::vec2 windDir = windSystem.getWindDirection();
        float windSpeed = windSystem.getWindSpeed();
        float windTime = windSystem.getTime();
        float cloudTimeScale = 0.02f;
        glm::vec3 windOffset = glm::vec3(windDir.x * windSpeed * windTime * cloudTimeScale,
                                          windTime * 0.002f,
                                          windDir.y * windSpeed * windTime * cloudTimeScale);
        atmosphereLUTSystem.updateCloudMapLUT(ctx.cmd, ctx.frameIndex, windOffset, windTime * cloudTimeScale);

        profiler.endGpuZone(ctx.cmd, "Atmosphere");
    });

    // ===== HDR STAGE =====
    // Sky rendering
    renderPipeline.hdrStage.addDrawCall("sky", [this](RenderContext& ctx) {
        skySystem.recordDraw(ctx.cmd, ctx.frameIndex);
    });

    // Terrain rendering
    renderPipeline.hdrStage.addDrawCall("terrain", [this](RenderContext& ctx) {
        if (terrainEnabled) {
            terrainSystem.recordDraw(ctx.cmd, ctx.frameIndex);
        }
    });

    // Catmull-Clark subdivision surfaces
    renderPipeline.hdrStage.addDrawCall("catmullClark", [this](RenderContext& ctx) {
        catmullClarkSystem.recordDraw(ctx.cmd, ctx.frameIndex);
    });

    // Scene objects (static meshes)
    renderPipeline.hdrStage.addDrawCall("sceneObjects", [this](RenderContext& ctx) {
        vkCmdBindPipeline(ctx.cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
        recordSceneObjects(ctx.cmd, ctx.frameIndex);
    });

    // Skinned character (GPU skinning)
    renderPipeline.hdrStage.addDrawCall("skinnedCharacter", [this](RenderContext& ctx) {
        SceneBuilder& sceneBuilder = sceneManager.getSceneBuilder();
        if (sceneBuilder.hasCharacter()) {
            const auto& sceneObjects = sceneBuilder.getRenderables();
            size_t playerIndex = sceneBuilder.getPlayerObjectIndex();
            if (playerIndex < sceneObjects.size()) {
                const Renderable& playerObj = sceneObjects[playerIndex];
                skinnedMeshRenderer.record(ctx.cmd, ctx.frameIndex, playerObj, sceneBuilder.getAnimatedCharacter());
            }
        }
    });

    // Tree editor
    renderPipeline.hdrStage.addDrawCall("treeEdit", [this](RenderContext& ctx) {
        treeEditSystem.recordDraw(ctx.cmd, ctx.frameIndex);
    });

    // Grass
    renderPipeline.hdrStage.addDrawCall("grass", [this](RenderContext& ctx) {
        grassSystem.recordDraw(ctx.cmd, ctx.frameIndex, ctx.frame.time);
    });

    // Water surface (after opaque geometry)
    renderPipeline.hdrStage.addDrawCall("water", [this](RenderContext& ctx) {
        if (waterTileCull.wasWaterVisibleLastFrame(ctx.frameIndex)) {
            waterSystem.recordDraw(ctx.cmd, ctx.frameIndex);
        }
    });

    // Leaves (after grass, before weather)
    renderPipeline.hdrStage.addDrawCall("leaves", [this](RenderContext& ctx) {
        leafSystem.recordDraw(ctx.cmd, ctx.frameIndex, ctx.frame.time);
    });

    // Weather particles (rain/snow)
    renderPipeline.hdrStage.addDrawCall("weather", [this](RenderContext& ctx) {
        weatherSystem.recordDraw(ctx.cmd, ctx.frameIndex, ctx.frame.time);
    });

    // Physics debug lines
    renderPipeline.hdrStage.addDrawCall("debugLines", [this](RenderContext& ctx) {
#ifdef JPH_DEBUG_RENDERER
        if (physicsDebugEnabled && debugLineSystem.hasLines()) {
            VkViewport viewport{};
            viewport.x = 0.0f;
            viewport.y = 0.0f;
            viewport.width = static_cast<float>(postProcessSystem.getExtent().width);
            viewport.height = static_cast<float>(postProcessSystem.getExtent().height);
            viewport.minDepth = 0.0f;
            viewport.maxDepth = 1.0f;
            vkCmdSetViewport(ctx.cmd, 0, 1, &viewport);

            VkRect2D scissor{};
            scissor.offset = {0, 0};
            scissor.extent = postProcessSystem.getExtent();
            vkCmdSetScissor(ctx.cmd, 0, 1, &scissor);

            debugLineSystem.recordCommands(ctx.cmd, lastViewProj);
        }
#endif
    });

    // ===== POST STAGE =====
    renderPipeline.postStage.setHiZRecordFn([this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "HiZPyramid");
        hiZSystem.recordPyramidGeneration(ctx.cmd, ctx.frameIndex);
        profiler.endGpuZone(ctx.cmd, "HiZPyramid");
    });

    renderPipeline.postStage.setBloomRecordFn([this](RenderContext& ctx) {
        profiler.beginGpuZone(ctx.cmd, "Bloom");
        bloomSystem.setThreshold(postProcessSystem.getBloomThreshold());
        bloomSystem.recordBloomPass(ctx.cmd, postProcessSystem.getHDRColorView());
        profiler.endGpuZone(ctx.cmd, "Bloom");
    });

    // Post-process is handled separately since it needs guiRenderCallback and framebuffer
}

void Renderer::setWeatherIntensity(float intensity) {
    weatherSystem.setIntensity(intensity);
}

void Renderer::setWeatherType(uint32_t type) {
    weatherSystem.setWeatherType(type);
}

void Renderer::setPlayerPosition(const glm::vec3& position, float radius) {
    setPlayerState(position, glm::vec3(0.0f), radius);
}

void Renderer::setPlayerState(const glm::vec3& position, const glm::vec3& velocity, float radius) {
    playerPosition = position;
    playerVelocity = velocity;
    playerCapsuleRadius = radius;
}

#ifdef JPH_DEBUG_RENDERER
void Renderer::updatePhysicsDebug(PhysicsWorld& physics, const glm::vec3& cameraPos) {
    if (!physicsDebugEnabled) return;

    // Begin debug line frame (clear previous and set frame index)
    debugLineSystem.beginFrame(currentFrame);

    // Create debug renderer on first use (after Jolt is initialized)
    if (!physicsDebugRenderer) {
        physicsDebugRenderer = std::make_unique<PhysicsDebugRenderer>();
        physicsDebugRenderer->init();
    }

    // Begin physics debug frame
    physicsDebugRenderer->beginFrame(cameraPos);

    // Draw all physics bodies
    if (physics.getPhysicsSystem()) {
        physicsDebugRenderer->drawBodies(*physics.getPhysicsSystem());
    }

    // End frame (cleanup cached geometry)
    physicsDebugRenderer->endFrame();

    // Import collected lines into our debug line system
    debugLineSystem.importFromPhysicsDebugRenderer(*physicsDebugRenderer);
}
#endif

void Renderer::shutdown() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();

    if (device != VK_NULL_HANDLE) {
        vkDeviceWaitIdle(device);

        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr);
            vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr);
            vkDestroyFence(device, inFlightFences[i], nullptr);
        }

        sceneManager.destroy(allocator, device);

        // Clean up the auto-growing descriptor pool
        if (descriptorManagerPool.has_value()) {
            descriptorManagerPool->destroy();
            descriptorManagerPool.reset();
        }

        // Clean up all per-frame shared buffers via GlobalBufferManager
        globalBufferManager.destroy(allocator);

        grassSystem.destroy(device, allocator);
        terrainSystem.destroy(device, allocator);
        catmullClarkSystem.destroy(device, allocator);
        rockSystem.destroy(allocator, device);
        windSystem.destroy(device, allocator);
        weatherSystem.destroy(device, allocator);
        snowMaskSystem.destroy(device, allocator);
        volumetricSnowSystem.destroy(device, allocator);
        leafSystem.destroy(device, allocator);
        froxelSystem.destroy(device, allocator);
        cloudShadowSystem.destroy();
        hiZSystem.destroy();
        profiler.shutdown();
        waterSystem.destroy(device, allocator);
        waterDisplacement.destroy();
        foamBuffer.destroy();
        ssrSystem.destroy();
        waterTileCull.destroy();
        waterGBuffer.destroy();
        flowMapGenerator.destroy(device, allocator);
        treeEditSystem.destroy(device, allocator);
        debugLineSystem.shutdown();
        atmosphereLUTSystem.destroy(device, allocator);
        skySystem.destroy(device, allocator);
        postProcessSystem.destroy(device, allocator);
        bloomSystem.destroy(device, allocator);

        vkDestroyPipeline(device, graphicsPipeline, nullptr);
        vkDestroyPipelineLayout(device, pipelineLayout, nullptr);
        vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr);

        // Clean up skinned mesh renderer
        skinnedMeshRenderer.destroy();

        // Shadow system cleanup
        shadowSystem.destroy();

        vkDestroyCommandPool(device, commandPool, nullptr);

        // Clean up Renderer-specific resources (depth, framebuffers, renderPass)
        destroyRenderResources();
    }

    vulkanContext.shutdown();
}

void Renderer::destroyRenderResources() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();

    if (depthSampler != VK_NULL_HANDLE) {
        vkDestroySampler(device, depthSampler, nullptr);
        depthSampler = VK_NULL_HANDLE;
    }
    if (depthImageView != VK_NULL_HANDLE) {
        vkDestroyImageView(device, depthImageView, nullptr);
        depthImageView = VK_NULL_HANDLE;
    }
    if (depthImage != VK_NULL_HANDLE) {
        vmaDestroyImage(allocator, depthImage, depthImageAllocation);
        depthImage = VK_NULL_HANDLE;
    }

    for (auto framebuffer : framebuffers) {
        vkDestroyFramebuffer(device, framebuffer, nullptr);
    }
    framebuffers.clear();

    if (renderPass != VK_NULL_HANDLE) {
        vkDestroyRenderPass(device, renderPass, nullptr);
        renderPass = VK_NULL_HANDLE;
    }
}

bool Renderer::createRenderPass() {
    VkDevice device = vulkanContext.getDevice();
    VkFormat swapchainImageFormat = vulkanContext.getSwapchainImageFormat();

    VkAttachmentDescription colorAttachment{};
    colorAttachment.format = swapchainImageFormat;
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    VkAttachmentDescription depthAttachment{};
    depthAttachment.format = VK_FORMAT_D32_SFLOAT;
    depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    // Store depth for Hi-Z pyramid generation
    depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    // Transition to shader read for Hi-Z
    depthAttachment.finalLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

    depthFormat = VK_FORMAT_D32_SFLOAT;

    VkAttachmentReference colorAttachmentRef{};
    colorAttachmentRef.attachment = 0;
    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    VkAttachmentReference depthAttachmentRef{};
    depthAttachmentRef.attachment = 1;
    depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkSubpassDescription subpass{};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &colorAttachmentRef;
    subpass.pDepthStencilAttachment = &depthAttachmentRef;

    VkSubpassDependency dependency{};
    dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
    dependency.dstSubpass = 0;
    dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    dependency.srcAccessMask = 0;
    dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

    std::array<VkAttachmentDescription, 2> attachments = {colorAttachment, depthAttachment};

    VkRenderPassCreateInfo renderPassInfo{};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
    renderPassInfo.pAttachments = attachments.data();
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &subpass;
    renderPassInfo.dependencyCount = 1;
    renderPassInfo.pDependencies = &dependency;

    if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) {
        SDL_Log("Failed to create render pass");
        return false;
    }

    return true;
}

bool Renderer::createDepthResources() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();

    VkImageCreateInfo imageInfo{};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.width = swapchainExtent.width;
    imageInfo.extent.height = swapchainExtent.height;
    imageInfo.extent.depth = 1;
    imageInfo.mipLevels = 1;
    imageInfo.arrayLayers = 1;
    imageInfo.format = depthFormat;
    imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    // Add SAMPLED_BIT for Hi-Z pyramid generation
    imageInfo.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    VmaAllocationCreateInfo allocInfo{};
    allocInfo.usage = VMA_MEMORY_USAGE_AUTO;

    if (vmaCreateImage(allocator, &imageInfo, &allocInfo, &depthImage, &depthImageAllocation, nullptr) != VK_SUCCESS) {
        SDL_Log("Failed to create depth image");
        return false;
    }

    VkImageViewCreateInfo viewInfo{};
    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    viewInfo.image = depthImage;
    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    viewInfo.format = depthFormat;
    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
    viewInfo.subresourceRange.baseMipLevel = 0;
    viewInfo.subresourceRange.levelCount = 1;
    viewInfo.subresourceRange.baseArrayLayer = 0;
    viewInfo.subresourceRange.layerCount = 1;

    if (vkCreateImageView(device, &viewInfo, nullptr, &depthImageView) != VK_SUCCESS) {
        SDL_Log("Failed to create depth image view");
        return false;
    }

    // Create depth sampler for Hi-Z pyramid generation
    VkSamplerCreateInfo samplerInfo{};
    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    samplerInfo.magFilter = VK_FILTER_NEAREST;
    samplerInfo.minFilter = VK_FILTER_NEAREST;
    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;
    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    samplerInfo.minLod = 0.0f;
    samplerInfo.maxLod = 0.0f;
    samplerInfo.borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;

    if (vkCreateSampler(device, &samplerInfo, nullptr, &depthSampler) != VK_SUCCESS) {
        SDL_Log("Failed to create depth sampler");
        return false;
    }

    return true;
}

bool Renderer::createFramebuffers() {
    VkDevice device = vulkanContext.getDevice();
    const auto& swapchainImageViews = vulkanContext.getSwapchainImageViews();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();

    framebuffers.resize(swapchainImageViews.size());

    for (size_t i = 0; i < swapchainImageViews.size(); i++) {
        std::array<VkImageView, 2> attachments = {
            swapchainImageViews[i],
            depthImageView
        };

        VkFramebufferCreateInfo framebufferInfo{};
        framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass = renderPass;
        framebufferInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
        framebufferInfo.pAttachments = attachments.data();
        framebufferInfo.width = swapchainExtent.width;
        framebufferInfo.height = swapchainExtent.height;
        framebufferInfo.layers = 1;

        if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &framebuffers[i]) != VK_SUCCESS) {
            SDL_Log("Failed to create framebuffer");
            return false;
        }
    }

    return true;
}

bool Renderer::createCommandPool() {
    VkDevice device = vulkanContext.getDevice();
    uint32_t queueFamilyIndex = vulkanContext.getGraphicsQueueFamily();

    VkCommandPoolCreateInfo poolInfo{};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    poolInfo.queueFamilyIndex = queueFamilyIndex;

    if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
        SDL_Log("Failed to create command pool");
        return false;
    }

    return true;
}

bool Renderer::createCommandBuffers() {
    VkDevice device = vulkanContext.getDevice();

    commandBuffers.resize(MAX_FRAMES_IN_FLIGHT);

    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = static_cast<uint32_t>(commandBuffers.size());

    if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) {
        SDL_Log("Failed to allocate command buffers");
        return false;
    }

    return true;
}

bool Renderer::createSyncObjects() {
    VkDevice device = vulkanContext.getDevice();

    imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

    VkSemaphoreCreateInfo semaphoreInfo{};
    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

    VkFenceCreateInfo fenceInfo{};
    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphores[i]) != VK_SUCCESS ||
            vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphores[i]) != VK_SUCCESS ||
            vkCreateFence(device, &fenceInfo, nullptr, &inFlightFences[i]) != VK_SUCCESS) {
            SDL_Log("Failed to create sync objects");
            return false;
        }
    }

    return true;
}

// Adds the common descriptor bindings shared between main and skinned layouts.
// This ensures both layouts stay in sync for bindings used by shader.frag.
void Renderer::addCommonDescriptorBindings(DescriptorManager::LayoutBuilder& builder) {
    builder
        .addUniformBuffer(VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT)  // 0: UBO
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 1: diffuse
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 2: shadow
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 3: normal
        .addStorageBuffer(VK_SHADER_STAGE_FRAGMENT_BIT)         // 4: lights
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 5: emissive
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 6: point shadow
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 7: spot shadow
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 8: snow mask
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 9: cloud shadow map
        .addUniformBuffer(VK_SHADER_STAGE_FRAGMENT_BIT)         // 10: Snow UBO
        .addUniformBuffer(VK_SHADER_STAGE_FRAGMENT_BIT)         // 11: Cloud shadow UBO
        // Note: binding 12 (bone matrices) is added separately for skinned layout
        .addBinding(Bindings::ROUGHNESS_MAP, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT)  // 13: roughness
        .addBinding(Bindings::METALLIC_MAP, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT)   // 14: metallic
        .addBinding(Bindings::AO_MAP, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT)         // 15: AO
        .addBinding(Bindings::HEIGHT_MAP, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT);    // 16: height
}

bool Renderer::createDescriptorSetLayout() {
    VkDevice device = vulkanContext.getDevice();

    // Main scene descriptor set layout - uses common bindings (0-11, 13-16)
    DescriptorManager::LayoutBuilder builder(device);
    addCommonDescriptorBindings(builder);
    descriptorSetLayout = builder.build();

    if (descriptorSetLayout == VK_NULL_HANDLE) {
        SDL_Log("Failed to create descriptor set layout");
        return false;
    }

    return true;
}

bool Renderer::createGraphicsPipeline() {
    VkDevice device = vulkanContext.getDevice();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();

    // Create pipeline layout (still needed - factory expects it to be provided)
    VkPushConstantRange pushConstantRange{};
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange.offset = 0;
    pushConstantRange.size = sizeof(PushConstants);

    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout;
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;

    if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create pipeline layout");
        return false;
    }

    // Use factory for pipeline creation
    auto bindingDescription = Vertex::getBindingDescription();
    auto attributeDescriptions = Vertex::getAttributeDescriptions();

    GraphicsPipelineFactory factory(device);
    bool success = factory
        .applyPreset(GraphicsPipelineFactory::Preset::Default)
        .setShaders(resourcePath + "/shaders/shader.vert.spv",
                    resourcePath + "/shaders/shader.frag.spv")
        .setVertexInput({bindingDescription},
                        {attributeDescriptions.begin(), attributeDescriptions.end()})
        .setRenderPass(postProcessSystem.getHDRRenderPass())
        .setPipelineLayout(pipelineLayout)
        .setExtent(swapchainExtent)
        .setBlendMode(GraphicsPipelineFactory::BlendMode::Alpha)
        .build(graphicsPipeline);

    if (!success) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create graphics pipeline");
        return false;
    }

    return true;
}

void Renderer::updateLightBuffer(uint32_t currentImage, const Camera& camera) {
    LightBuffer buffer{};
    glm::mat4 viewProj = camera.getProjectionMatrix() * camera.getViewMatrix();
    sceneManager.getLightManager().buildLightBuffer(buffer, camera.getPosition(), camera.getFront(), viewProj, lightCullRadius);
    globalBufferManager.updateLightBuffer(currentImage, buffer);
}

bool Renderer::createDescriptorPool() {
    VkDevice device = vulkanContext.getDevice();

    // Create the auto-growing descriptor pool
    // Initial capacity of 64 sets per pool, will automatically grow if exhausted
    // All subsystems now use this managed pool for consistent descriptor allocation
    descriptorManagerPool.emplace(device, 64);

    return true;
}

bool Renderer::createDescriptorSets() {
    VkDevice device = vulkanContext.getDevice();

    // Create descriptor sets for all materials via MaterialRegistry
    // This replaces the hardcoded per-material descriptor set allocation
    auto& materialRegistry = sceneManager.getSceneBuilder().getMaterialRegistry();

    // Lambda to build common bindings for a given frame (using GlobalBufferManager)
    auto getCommonBindings = [this](uint32_t frameIndex) -> MaterialDescriptorFactory::CommonBindings {
        MaterialDescriptorFactory::CommonBindings common{};
        common.uniformBuffer = globalBufferManager.uniformBuffers.buffers[frameIndex];
        common.uniformBufferSize = sizeof(UniformBufferObject);
        common.shadowMapView = shadowSystem.getShadowImageView();
        common.shadowMapSampler = shadowSystem.getShadowSampler();
        common.lightBuffer = globalBufferManager.lightBuffers.buffers[frameIndex];
        common.lightBufferSize = sizeof(LightBuffer);
        common.emissiveMapView = sceneManager.getSceneBuilder().getDefaultEmissiveMap().getImageView();
        common.emissiveMapSampler = sceneManager.getSceneBuilder().getDefaultEmissiveMap().getSampler();
        common.pointShadowView = shadowSystem.getPointShadowArrayView(frameIndex);
        common.pointShadowSampler = shadowSystem.getPointShadowSampler();
        common.spotShadowView = shadowSystem.getSpotShadowArrayView(frameIndex);
        common.spotShadowSampler = shadowSystem.getSpotShadowSampler();
        common.snowMaskView = snowMaskSystem.getSnowMaskView();
        common.snowMaskSampler = snowMaskSystem.getSnowMaskSampler();
        // Snow and cloud shadow UBOs (bindings 10 and 11)
        common.snowUboBuffer = globalBufferManager.snowBuffers.buffers[frameIndex];
        common.snowUboBufferSize = sizeof(SnowUBO);
        common.cloudShadowUboBuffer = globalBufferManager.cloudShadowBuffers.buffers[frameIndex];
        common.cloudShadowUboBufferSize = sizeof(CloudShadowUBO);
        // Cloud shadow texture is added later in init() after cloudShadowSystem is initialized
        // Placeholder texture for unused PBR bindings (13-16)
        common.placeholderTextureView = sceneManager.getSceneBuilder().getWhiteTexture().getImageView();
        common.placeholderTextureSampler = sceneManager.getSceneBuilder().getWhiteTexture().getSampler();
        return common;
    };

    materialRegistry.createDescriptorSets(
        device,
        *descriptorManagerPool,
        descriptorSetLayout,
        MAX_FRAMES_IN_FLIGHT,
        getCommonBindings);

    if (!materialRegistry.hasDescriptorSets()) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create MaterialRegistry descriptor sets");
        return false;
    }

    // Rock descriptor sets (RockSystem has its own textures, not in MaterialRegistry)
    rockDescriptorSets = descriptorManagerPool->allocate(descriptorSetLayout, MAX_FRAMES_IN_FLIGHT);
    if (rockDescriptorSets.empty()) {
        SDL_Log("Failed to allocate rock descriptor sets");
        return false;
    }

    // Write rock descriptor sets
    MaterialDescriptorFactory factory(device);
    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        MaterialDescriptorFactory::CommonBindings common = getCommonBindings(static_cast<uint32_t>(i));

        MaterialDescriptorFactory::MaterialTextures mat{};
        mat.diffuseView = rockSystem.getRockTexture().getImageView();
        mat.diffuseSampler = rockSystem.getRockTexture().getSampler();
        mat.normalView = rockSystem.getRockNormalMap().getImageView();
        mat.normalSampler = rockSystem.getRockNormalMap().getSampler();
        factory.writeDescriptorSet(rockDescriptorSets[i], common, mat);
    }

    return true;
}


void Renderer::updateUniformBuffer(uint32_t currentImage, const Camera& camera) {
    // Get current time of day from time system (already updated in render())
    float currentTimeOfDay = timeSystem.getTimeOfDay();

    // Pure calculations via UBOBuilder
    UBOBuilder::LightingParams lighting = uboBuilder.calculateLightingParams(currentTimeOfDay);
    timeSystem.setCurrentMoonPhase(lighting.moonPhase);  // Track current effective phase

    // Calculate and apply tide based on celestial positions
    DateTime dateTime = DateTime::fromTimeOfDay(currentTimeOfDay, timeSystem.getCurrentYear(),
                                                 timeSystem.getCurrentMonth(), timeSystem.getCurrentDay());
    TideInfo tide = celestialCalculator.calculateTide(dateTime);
    waterSystem.updateTide(tide.height);

    // Update cascade matrices via shadow system
    shadowSystem.updateCascadeMatrices(lighting.sunDir, camera);

    // Build UBO data via UBOBuilder (pure calculation)
    UBOBuilder::MainUBOConfig mainConfig{};
    mainConfig.showCascadeDebug = showCascadeDebug;
    mainConfig.useParaboloidClouds = useParaboloidClouds;
    mainConfig.cloudCoverage = cloudCoverage;
    mainConfig.cloudDensity = cloudDensity;
    UniformBufferObject ubo = uboBuilder.buildUniformBufferData(camera, lighting, currentTimeOfDay, mainConfig);

    UBOBuilder::SnowConfig snowConfig{};
    snowConfig.useVolumetricSnow = useVolumetricSnow;
    snowConfig.showSnowDepthDebug = showSnowDepthDebug;
    snowConfig.maxSnowHeight = MAX_SNOW_HEIGHT;
    SnowUBO snowUbo = uboBuilder.buildSnowUBOData(snowConfig);

    CloudShadowUBO cloudShadowUbo = uboBuilder.buildCloudShadowUBOData();

    // State mutations - use GlobalBufferManager for buffer updates
    lastSunIntensity = lighting.sunIntensity;
    globalBufferManager.updateUniformBuffer(currentImage, ubo);
    globalBufferManager.updateSnowBuffer(currentImage, snowUbo);
    globalBufferManager.updateCloudShadowBuffer(currentImage, cloudShadowUbo);

    // Update light buffer with camera-based culling
    updateLightBuffer(currentImage, camera);

    // Calculate sun screen position (pure) and update post-process (state mutation)
    glm::vec2 sunScreenPos = calculateSunScreenPos(camera, lighting.sunDir);
    postProcessSystem.setSunScreenPos(sunScreenPos);

    // Update HDR enabled state
    postProcessSystem.setHDREnabled(hdrEnabled);
}

bool Renderer::render(const Camera& camera) {
    // Skip rendering if window is suspended (e.g., macOS screen lock)
    if (windowSuspended) {
        return false;
    }

    VkDevice device = vulkanContext.getDevice();
    VkSwapchainKHR swapchain = vulkanContext.getSwapchain();
    VkQueue graphicsQueue = vulkanContext.getGraphicsQueue();
    VkQueue presentQueue = vulkanContext.getPresentQueue();

    // Handle pending resize before acquiring next image
    if (framebufferResized) {
        handleResize();
        swapchain = vulkanContext.getSwapchain();  // Update after resize
        framebufferResized = false;
    }

    // Skip rendering if window is minimized
    VkExtent2D extent = vulkanContext.getSwapchainExtent();
    if (extent.width == 0 || extent.height == 0) {
        return false;
    }

    // Frame synchronization
    vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

    uint32_t imageIndex;
    VkResult result = vkAcquireNextImageKHR(device, swapchain, UINT64_MAX,
                                            imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);

    if (result == VK_ERROR_OUT_OF_DATE_KHR) {
        handleResize();
        return false;
    } else if (result == VK_ERROR_SURFACE_LOST_KHR) {
        // Surface lost - can happen on macOS when screen locks/unlocks
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Surface lost, will recreate on next frame");
        framebufferResized = true;
        return false;
    } else if (result == VK_ERROR_DEVICE_LOST) {
        // Device lost - critical error on macOS lock/unlock
        // Log error but return gracefully - app can attempt recovery on next frame
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Vulkan device lost - attempting recovery");
        framebufferResized = true;
        return false;
    } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to acquire swapchain image: %d", result);
        return false;
    }

    vkResetFences(device, 1, &inFlightFences[currentFrame]);

    // Update time system (frame timing and day/night cycle)
    TimingData timing = timeSystem.update();

    // Begin CPU profiling for this frame
    profiler.beginCpuZone("UniformUpdates");

    // Update uniform buffer data
    updateUniformBuffer(currentFrame, camera);

    // Update bone matrices for GPU skinning
    SceneBuilder& sceneBuilder = sceneManager.getSceneBuilder();
    AnimatedCharacter* character = sceneBuilder.hasCharacter() ? &sceneBuilder.getAnimatedCharacter() : nullptr;
    skinnedMeshRenderer.updateBoneMatrices(currentFrame, character);

    profiler.endCpuZone("UniformUpdates");

    // Build per-frame shared state
    FrameData frame = buildFrameData(camera, timing.deltaTime, timing.elapsedTime);

    // Cache view-projection for debug rendering
    lastViewProj = frame.viewProj;

    // Upload debug lines if enabled (lines were collected in updatePhysicsDebug before render)
#ifdef JPH_DEBUG_RENDERER
    if (physicsDebugEnabled && debugLineSystem.hasLines()) {
        debugLineSystem.uploadLines();
    }
#endif

    // Update subsystems (state mutations)
    profiler.beginCpuZone("SystemUpdates");

    windSystem.update(frame.deltaTime);
    windSystem.updateUniforms(frame.frameIndex);

    grassSystem.updateUniforms(frame.frameIndex, frame.cameraPosition, frame.viewProj,
                               frame.terrainSize, frame.heightScale);
    grassSystem.updateDisplacementSources(frame.playerPosition, frame.playerCapsuleRadius, frame.deltaTime);
    weatherSystem.updateUniforms(frame.frameIndex, frame.cameraPosition, frame.viewProj, frame.deltaTime, frame.time, windSystem);
    terrainSystem.updateUniforms(frame.frameIndex, frame.cameraPosition, frame.view, frame.projection,
                                  volumetricSnowSystem.getCascadeParams(), useVolumetricSnow, MAX_SNOW_HEIGHT);

    // Update snow mask system - accumulation/melting based on weather type
    bool isSnowing = (weatherSystem.getWeatherType() == 1);  // 1 = snow
    float weatherIntensity = weatherSystem.getIntensity();
    // Auto-adjust snow amount based on weather state
    if (isSnowing && weatherIntensity > 0.0f) {
        environmentSettings.snowAmount = glm::min(environmentSettings.snowAmount + environmentSettings.snowAccumulationRate * frame.deltaTime, 1.0f);
    } else if (environmentSettings.snowAmount > 0.0f) {
        environmentSettings.snowAmount = glm::max(environmentSettings.snowAmount - environmentSettings.snowMeltRate * frame.deltaTime, 0.0f);
    }
    snowMaskSystem.setMaskCenter(frame.cameraPosition);
    snowMaskSystem.updateUniforms(frame.frameIndex, frame.deltaTime, isSnowing, weatherIntensity, environmentSettings);

    // Update volumetric snow system
    volumetricSnowSystem.setCameraPosition(frame.cameraPosition);
    volumetricSnowSystem.setWindDirection(glm::vec2(windSystem.getEnvironmentSettings().windDirection.x,
                                                     windSystem.getEnvironmentSettings().windDirection.y));
    volumetricSnowSystem.setWindStrength(windSystem.getEnvironmentSettings().windStrength);
    volumetricSnowSystem.updateUniforms(frame.frameIndex, frame.deltaTime, isSnowing, weatherIntensity, environmentSettings);

    // Add player footprint interaction with snow
    if (environmentSettings.snowAmount > 0.1f) {
        snowMaskSystem.addInteraction(frame.playerPosition, frame.playerCapsuleRadius * 1.5f, 0.3f);
        volumetricSnowSystem.addInteraction(frame.playerPosition, frame.playerCapsuleRadius * 1.5f, 0.3f);
    }

    // Update leaf system with player position and velocity for disruption
    leafSystem.updateUniforms(frame.frameIndex, frame.cameraPosition, frame.viewProj, frame.cameraPosition, frame.playerVelocity, frame.deltaTime, frame.time,
                               frame.terrainSize, frame.heightScale);

    // Update water system uniforms
    waterSystem.updateUniforms(frame.frameIndex);

    profiler.endCpuZone("SystemUpdates");

    // Begin command buffer recording
    vkResetCommandBuffer(commandBuffers[frame.frameIndex], 0);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkBeginCommandBuffer(commandBuffers[frame.frameIndex], &beginInfo);

    VkCommandBuffer cmd = commandBuffers[frame.frameIndex];

    // Begin GPU profiling frame
    profiler.beginFrame(cmd, frame.frameIndex);

    // Build render resources and context for pipeline stages
    RenderResources resources = buildRenderResources(imageIndex);
    RenderContext ctx(cmd, frame.frameIndex, frame, resources);

    // Execute all compute passes via pipeline
    renderPipeline.computeStage.execute(ctx);

    // Shadow pass (skip when sun is below horizon)
    if (lastSunIntensity > 0.001f) {
        profiler.beginGpuZone(cmd, "ShadowPass");
        recordShadowPass(cmd, frame.frameIndex, frame.time);
        profiler.endGpuZone(cmd, "ShadowPass");
    }

    // Froxel volumetric fog and atmosphere updates via pipeline
    postProcessSystem.setCameraPlanes(camera.getNearPlane(), camera.getFarPlane());
    if (renderPipeline.froxelStageFn) {
        renderPipeline.froxelStageFn(ctx);
    }

    // Water G-buffer pass (Phase 3) - renders water mesh to mini G-buffer
    // Skip if water was not visible last frame (temporal culling)
    if (waterGBuffer.getPipeline() != VK_NULL_HANDLE &&
        waterTileCull.wasWaterVisibleLastFrame(frame.frameIndex)) {
        profiler.beginGpuZone(cmd, "WaterGBuffer");
        waterGBuffer.beginRenderPass(cmd);

        // Bind G-buffer pipeline and descriptor set
        vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, waterGBuffer.getPipeline());
        VkDescriptorSet gbufferDescSet = waterGBuffer.getDescriptorSet(frame.frameIndex);
        vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
                                waterGBuffer.getPipelineLayout(), 0, 1,
                                &gbufferDescSet, 0, nullptr);

        // Draw water mesh
        waterSystem.recordMeshDraw(cmd);

        waterGBuffer.endRenderPass(cmd);
        profiler.endGpuZone(cmd, "WaterGBuffer");
    }

    // HDR scene render pass
    profiler.beginGpuZone(cmd, "HDRPass");
    recordHDRPass(cmd, frame.frameIndex, frame.time);
    profiler.endGpuZone(cmd, "HDRPass");

    // Screen-Space Reflections compute pass (Phase 10)
    // Computes SSR for next frame's water - uses current scene for temporal stability
    if (ssrSystem.isEnabled()) {
        profiler.beginGpuZone(cmd, "SSR");
        ssrSystem.recordCompute(cmd, frame.frameIndex,
                                postProcessSystem.getHDRColorView(),
                                postProcessSystem.getHDRDepthView(),
                                frame.view, frame.projection,
                                frame.cameraPosition);
        profiler.endGpuZone(cmd, "SSR");
    }

    // Water tile culling compute pass (Phase 7)
    // Determines which screen tiles contain water for optimized rendering
    if (waterTileCull.isEnabled()) {
        profiler.beginGpuZone(cmd, "WaterTileCull");
        glm::mat4 viewProj = frame.projection * frame.view;
        waterTileCull.recordTileCull(cmd, frame.frameIndex,
                                      viewProj, frame.cameraPosition,
                                      waterSystem.getWaterLevel(),
                                      postProcessSystem.getHDRDepthView());
        profiler.endGpuZone(cmd, "WaterTileCull");
    }

    // Hi-Z pyramid and Bloom via pipeline post stage
    if (renderPipeline.postStage.hiZRecordFn) {
        renderPipeline.postStage.hiZRecordFn(ctx);
    }
    if (renderPipeline.postStage.bloomRecordFn) {
        renderPipeline.postStage.bloomRecordFn(ctx);
    }

    // Post-process pass (with optional GUI overlay callback)
    // Note: This is not in postStage because it needs framebuffer and guiRenderCallback
    profiler.beginGpuZone(cmd, "PostProcess");
    postProcessSystem.recordPostProcess(cmd, frame.frameIndex, framebuffers[imageIndex], frame.deltaTime, guiRenderCallback);
    profiler.endGpuZone(cmd, "PostProcess");

    // End GPU profiling frame
    profiler.endFrame(cmd, frame.frameIndex);

    vkEndCommandBuffer(cmd);

    // Queue submission
    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    VkSemaphore waitSemaphores[] = {imageAvailableSemaphores[currentFrame]};
    VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
    submitInfo.waitSemaphoreCount = 1;
    submitInfo.pWaitSemaphores = waitSemaphores;
    submitInfo.pWaitDstStageMask = waitStages;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &cmd;

    VkSemaphore signalSemaphores[] = {renderFinishedSemaphores[currentFrame]};
    submitInfo.signalSemaphoreCount = 1;
    submitInfo.pSignalSemaphores = signalSemaphores;

    result = vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFences[currentFrame]);
    if (result == VK_ERROR_DEVICE_LOST) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Device lost during queue submit");
        framebufferResized = true;
        return false;
    } else if (result != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to submit draw command buffer: %d", result);
        return false;
    }

    // Present
    VkPresentInfoKHR presentInfo{};
    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    presentInfo.waitSemaphoreCount = 1;
    presentInfo.pWaitSemaphores = signalSemaphores;

    VkSwapchainKHR swapChains[] = {swapchain};
    presentInfo.swapchainCount = 1;
    presentInfo.pSwapchains = swapChains;
    presentInfo.pImageIndices = &imageIndex;

    result = vkQueuePresentKHR(presentQueue, &presentInfo);

    if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) {
        framebufferResized = true;
    } else if (result == VK_ERROR_SURFACE_LOST_KHR || result == VK_ERROR_DEVICE_LOST) {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Surface/device lost during present, will recover");
        framebufferResized = true;
    } else if (result != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to present swapchain image: %d", result);
    }

    // Advance grass double-buffer sets after frame submission
    // This swaps compute/render buffer sets so next frame can overlap:
    // - Next frame's compute writes to what was the render set
    // - Next frame's render reads from what was the compute set (now contains fresh data)
    grassSystem.advanceBufferSet();
    weatherSystem.advanceBufferSet();
    leafSystem.advanceBufferSet();

    // Update water tile cull visibility tracking (uses absolute frame counter)
    waterTileCull.endFrame(currentFrame);

    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
    return true;
}

void Renderer::waitIdle() {
    vulkanContext.waitIdle();
}

void Renderer::waitForPreviousFrame() {
    // Wait for the previous frame's fence to ensure GPU is done with resources
    // we might be about to destroy/update.
    //
    // With double-buffering (MAX_FRAMES_IN_FLIGHT=2):
    // - Frame N uses fence[N % 2]
    // - Before updating meshes for frame N, we need frame N-1's GPU work complete
    // - Previous frame's fence is fence[(N-1) % 2] = fence[(currentFrame + 1) % 2]
    //
    // This prevents race conditions where we destroy mesh buffers while the GPU
    // is still reading them from the previous frame's commands.
    uint32_t previousFrame = (currentFrame + MAX_FRAMES_IN_FLIGHT - 1) % MAX_FRAMES_IN_FLIGHT;
    vkWaitForFences(vulkanContext.getDevice(), 1, &inFlightFences[previousFrame], VK_TRUE, UINT64_MAX);
}

void Renderer::destroyDepthImageAndView() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();

    if (depthImageView != VK_NULL_HANDLE) {
        vkDestroyImageView(device, depthImageView, nullptr);
        depthImageView = VK_NULL_HANDLE;
    }
    if (depthImage != VK_NULL_HANDLE) {
        vmaDestroyImage(allocator, depthImage, depthImageAllocation);
        depthImage = VK_NULL_HANDLE;
        depthImageAllocation = VK_NULL_HANDLE;
    }
}

void Renderer::destroyFramebuffers() {
    VkDevice device = vulkanContext.getDevice();
    for (auto framebuffer : framebuffers) {
        vkDestroyFramebuffer(device, framebuffer, nullptr);
    }
    framebuffers.clear();
}

bool Renderer::handleResize() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();

    // Wait for GPU to finish all work
    vkDeviceWaitIdle(device);

    // Recreate swapchain
    if (!vulkanContext.recreateSwapchain()) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to recreate swapchain");
        return false;
    }

    VkExtent2D newExtent = vulkanContext.getSwapchainExtent();

    // Handle minimized window (extent = 0)
    if (newExtent.width == 0 || newExtent.height == 0) {
        return true;  // Don't recreate resources for minimized window
    }

    SDL_Log("Window resized to %ux%u", newExtent.width, newExtent.height);

    // Destroy and recreate depth resources (keep sampler)
    destroyDepthImageAndView();

    // Recreate depth image and view (reusing existing depthFormat and depthSampler)
    VkImageCreateInfo imageInfo{};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.width = newExtent.width;
    imageInfo.extent.height = newExtent.height;
    imageInfo.extent.depth = 1;
    imageInfo.mipLevels = 1;
    imageInfo.arrayLayers = 1;
    imageInfo.format = depthFormat;
    imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    imageInfo.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    VmaAllocationCreateInfo allocInfo{};
    allocInfo.usage = VMA_MEMORY_USAGE_AUTO;

    if (vmaCreateImage(allocator, &imageInfo, &allocInfo, &depthImage, &depthImageAllocation, nullptr) != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create depth image during resize");
        return false;
    }

    VkImageViewCreateInfo viewInfo{};
    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    viewInfo.image = depthImage;
    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    viewInfo.format = depthFormat;
    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
    viewInfo.subresourceRange.baseMipLevel = 0;
    viewInfo.subresourceRange.levelCount = 1;
    viewInfo.subresourceRange.baseArrayLayer = 0;
    viewInfo.subresourceRange.layerCount = 1;

    if (vkCreateImageView(device, &viewInfo, nullptr, &depthImageView) != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create depth image view during resize");
        return false;
    }

    // Destroy and recreate framebuffers
    destroyFramebuffers();
    if (!createFramebuffers()) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to recreate framebuffers during resize");
        return false;
    }

    // Resize post-process system (HDR render target)
    postProcessSystem.resize(device, allocator, newExtent);

    // Resize bloom system
    bloomSystem.resize(device, allocator, newExtent);

    // Rebind bloom texture to post-process system (bloom image views changed)
    postProcessSystem.setBloomTexture(bloomSystem.getBloomOutput(), bloomSystem.getBloomSampler());

    // Resize froxel system (volumetric fog)
    froxelSystem.resize(device, allocator, newExtent);

    // Resize Hi-Z system (occlusion culling)
    hiZSystem.resize(newExtent);

    // Resize SSR system (screen-space reflections)
    ssrSystem.resize(newExtent);

    // Resize water tile cull system
    waterTileCull.resize(newExtent);

    // Resize water G-buffer
    waterGBuffer.resize(newExtent);

    // Update extent on all rendering subsystems for viewport/scissor
    terrainSystem.setExtent(newExtent);
    skySystem.setExtent(newExtent);
    waterSystem.setExtent(newExtent);
    grassSystem.setExtent(newExtent);
    weatherSystem.setExtent(newExtent);
    leafSystem.setExtent(newExtent);
    catmullClarkSystem.setExtent(newExtent);
    skinnedMeshRenderer.setExtent(newExtent);
    treeEditSystem.updateExtent(newExtent);

    framebufferResized = false;
    return true;
}

// Pure calculation helper - sun screen position for god rays

glm::vec2 Renderer::calculateSunScreenPos(const Camera& camera, const glm::vec3& sunDir) const {
    glm::vec3 sunWorldPos = camera.getPosition() + sunDir * 1000.0f;
    glm::vec4 sunClipPos = camera.getProjectionMatrix() * camera.getViewMatrix() * glm::vec4(sunWorldPos, 1.0f);

    glm::vec2 sunScreenPos(0.5f, 0.5f);
    if (sunClipPos.w > 0.0f) {
        glm::vec3 sunNDC = glm::vec3(sunClipPos) / sunClipPos.w;
        sunScreenPos = glm::vec2(sunNDC.x * 0.5f + 0.5f, sunNDC.y * 0.5f + 0.5f);
        sunScreenPos.y = 1.0f - sunScreenPos.y;
    }
    return sunScreenPos;
}

FrameData Renderer::buildFrameData(const Camera& camera, float deltaTime, float time) const {
    FrameData frame;

    frame.frameIndex = currentFrame;
    frame.deltaTime = deltaTime;
    frame.time = time;
    frame.timeOfDay = timeSystem.getTimeOfDay();

    frame.cameraPosition = camera.getPosition();
    frame.view = camera.getViewMatrix();
    frame.projection = camera.getProjectionMatrix();
    frame.viewProj = frame.projection * frame.view;

    // Get sun direction from last computed UBO (already computed in updateUniformBuffer)
    UniformBufferObject* ubo = static_cast<UniformBufferObject*>(globalBufferManager.uniformBuffers.mappedPointers[currentFrame]);
    frame.sunDirection = glm::normalize(glm::vec3(ubo->sunDirection));
    frame.sunIntensity = ubo->sunDirection.w;

    frame.playerPosition = playerPosition;
    frame.playerVelocity = playerVelocity;
    frame.playerCapsuleRadius = playerCapsuleRadius;

    const auto& terrainConfig = terrainSystem.getConfig();
    frame.terrainSize = terrainConfig.size;
    frame.heightScale = terrainConfig.heightScale;

    // Populate wind/weather/snow data
    const auto& envSettings = windSystem.getEnvironmentSettings();
    frame.windDirection = envSettings.windDirection;
    frame.windStrength = envSettings.windStrength;
    frame.windSpeed = envSettings.windSpeed;
    frame.gustFrequency = envSettings.gustFrequency;
    frame.gustAmplitude = envSettings.gustAmplitude;

    frame.weatherType = weatherSystem.getWeatherType();
    frame.weatherIntensity = weatherSystem.getIntensity();

    frame.snowAmount = environmentSettings.snowAmount;
    frame.snowColor = environmentSettings.snowColor;

    // Lighting data
    frame.sunColor = glm::vec3(ubo->sunColor);
    frame.moonDirection = glm::normalize(glm::vec3(ubo->moonDirection));
    frame.moonIntensity = ubo->moonDirection.w;

    return frame;
}

RenderResources Renderer::buildRenderResources(uint32_t swapchainImageIndex) const {
    RenderResources resources;

    // HDR target (from PostProcessSystem)
    resources.hdrRenderPass = postProcessSystem.getHDRRenderPass();
    resources.hdrFramebuffer = postProcessSystem.getHDRFramebuffer();
    resources.hdrExtent = postProcessSystem.getExtent();
    resources.hdrColorView = postProcessSystem.getHDRColorView();
    resources.hdrDepthView = postProcessSystem.getHDRDepthView();

    // Shadow resources (from ShadowSystem)
    resources.shadowRenderPass = shadowSystem.getShadowRenderPass();
    resources.shadowMapView = shadowSystem.getShadowImageView();
    resources.shadowSampler = shadowSystem.getShadowSampler();
    resources.shadowPipeline = shadowSystem.getShadowPipeline();
    resources.shadowPipelineLayout = shadowSystem.getShadowPipelineLayout();

    // Copy cascade matrices
    const auto& cascadeMatrices = shadowSystem.getCascadeMatrices();
    for (size_t i = 0; i < cascadeMatrices.size(); ++i) {
        resources.cascadeMatrices[i] = cascadeMatrices[i];
    }

    // Copy cascade split depths
    const auto& splitDepths = shadowSystem.getCascadeSplitDepths();
    for (size_t i = 0; i < std::min(splitDepths.size(), size_t(4)); ++i) {
        resources.cascadeSplitDepths[i] = splitDepths[i];
    }

    // Bloom output (from BloomSystem)
    resources.bloomOutput = bloomSystem.getBloomOutput();
    resources.bloomSampler = bloomSystem.getBloomSampler();

    // Swapchain target
    resources.swapchainRenderPass = renderPass;
    resources.swapchainFramebuffer = framebuffers[swapchainImageIndex];
    resources.swapchainExtent = {vulkanContext.getWidth(), vulkanContext.getHeight()};

    // Main scene pipeline
    resources.graphicsPipeline = graphicsPipeline;
    resources.pipelineLayout = pipelineLayout;
    resources.descriptorSetLayout = descriptorSetLayout;

    return resources;
}

// Render pass recording helpers - pure command recording, no state mutation

void Renderer::recordShadowPass(VkCommandBuffer cmd, uint32_t frameIndex, float grassTime) {
    // Delegate to the shadow system with callbacks for terrain and grass
    auto terrainCallback = [this, frameIndex](VkCommandBuffer cb, uint32_t cascade, const glm::mat4& lightMatrix) {
        if (terrainEnabled) {
            terrainSystem.recordShadowDraw(cb, frameIndex, lightMatrix, static_cast<int>(cascade));
        }
    };

    auto grassCallback = [this, frameIndex, grassTime](VkCommandBuffer cb, uint32_t cascade, const glm::mat4& lightMatrix) {
        (void)lightMatrix;  // Grass uses cascade index only
        grassSystem.recordShadowDraw(cb, frameIndex, grassTime, cascade);
    };

    // Combine scene objects and rock objects for shadow rendering
    // Skip player character - it's rendered separately with skinned shadow pipeline
    std::vector<Renderable> allObjects;
    const auto& sceneObjects = sceneManager.getRenderables();
    size_t playerIndex = sceneManager.getSceneBuilder().getPlayerObjectIndex();
    bool hasCharacter = sceneManager.getSceneBuilder().hasCharacter();

    allObjects.reserve(sceneObjects.size() + rockSystem.getSceneObjects().size());
    for (size_t i = 0; i < sceneObjects.size(); ++i) {
        // Skip player character - rendered with skinned shadow pipeline
        if (hasCharacter && i == playerIndex) {
            continue;
        }
        allObjects.push_back(sceneObjects[i]);
    }
    allObjects.insert(allObjects.end(), rockSystem.getSceneObjects().begin(), rockSystem.getSceneObjects().end());

    // Skinned character shadow callback (renders with GPU skinning)
    ShadowSystem::DrawCallback skinnedCallback = nullptr;
    if (hasCharacter) {
        skinnedCallback = [this, frameIndex, playerIndex](VkCommandBuffer cb, uint32_t cascade, const glm::mat4& lightMatrix) {
            (void)lightMatrix;  // Not used, cascade matrices are in UBO
            SceneBuilder& sceneBuilder = sceneManager.getSceneBuilder();
            const auto& sceneObjs = sceneBuilder.getRenderables();
            if (playerIndex >= sceneObjs.size()) return;

            const Renderable& playerObj = sceneObjs[playerIndex];
            AnimatedCharacter& character = sceneBuilder.getAnimatedCharacter();
            SkinnedMesh& skinnedMesh = character.getSkinnedMesh();

            // Bind skinned shadow pipeline with descriptor set that has bone matrices
            shadowSystem.bindSkinnedShadowPipeline(cb, skinnedMeshRenderer.getDescriptorSet(frameIndex));

            // Record the skinned mesh shadow
            shadowSystem.recordSkinnedMeshShadow(cb, cascade, playerObj.transform, skinnedMesh);
        };
    }

    // Use any MaterialRegistry descriptor set for shadow pass (only needs common bindings/UBO)
    // MaterialId 0 is the first registered material (crate)
    const auto& materialRegistry = sceneManager.getSceneBuilder().getMaterialRegistry();
    VkDescriptorSet shadowDescriptorSet = materialRegistry.getDescriptorSet(0, frameIndex);
    shadowSystem.recordShadowPass(cmd, frameIndex, shadowDescriptorSet,
                                   allObjects,
                                   terrainCallback, grassCallback, skinnedCallback);
}

void Renderer::recordSceneObjects(VkCommandBuffer cmd, uint32_t frameIndex) {
    // Get MaterialRegistry for descriptor set lookup
    const auto& materialRegistry = sceneManager.getSceneBuilder().getMaterialRegistry();

    // Helper lambda to render a scene object with a descriptor set
    auto renderObject = [&](const Renderable& obj, VkDescriptorSet descSet) {
        PushConstants push{};
        push.model = obj.transform;
        push.roughness = obj.roughness;
        push.metallic = obj.metallic;
        push.emissiveIntensity = obj.emissiveIntensity;
        push.opacity = obj.opacity;
        push.emissiveColor = glm::vec4(obj.emissiveColor, 1.0f);
        push.pbrFlags = obj.pbrFlags;

        vkCmdPushConstants(cmd, pipelineLayout,
                          VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,
                          0, sizeof(PushConstants), &push);

        vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
                                pipelineLayout, 0, 1, &descSet, 0, nullptr);

        VkBuffer vertexBuffers[] = {obj.mesh->getVertexBuffer()};
        VkDeviceSize offsets[] = {0};
        vkCmdBindVertexBuffers(cmd, 0, 1, vertexBuffers, offsets);
        vkCmdBindIndexBuffer(cmd, obj.mesh->getIndexBuffer(), 0, VK_INDEX_TYPE_UINT32);

        vkCmdDrawIndexed(cmd, obj.mesh->getIndexCount(), 1, 0, 0, 0);
    };

    // Render scene manager objects using MaterialRegistry for descriptor set lookup
    const auto& sceneObjects = sceneManager.getRenderables();
    size_t playerIndex = sceneManager.getSceneBuilder().getPlayerObjectIndex();
    bool hasCharacter = sceneManager.getSceneBuilder().hasCharacter();

    for (size_t i = 0; i < sceneObjects.size(); ++i) {
        // Skip player character (rendered separately with GPU skinning)
        if (hasCharacter && i == playerIndex) {
            continue;
        }

        const auto& obj = sceneObjects[i];

        // Use MaterialRegistry to get descriptor set by materialId
        // This replaces the brittle texture pointer comparison
        VkDescriptorSet descSet = materialRegistry.getDescriptorSet(obj.materialId, frameIndex);
        if (descSet == VK_NULL_HANDLE) {
            // Fallback: skip objects with invalid materialId
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,
                "Skipping object with invalid materialId %u", obj.materialId);
            continue;
        }
        renderObject(obj, descSet);
    }

    // Render procedural rocks (RockSystem uses its own descriptor sets)
    VkDescriptorSet rockDescSet = rockDescriptorSets[frameIndex];
    for (const auto& rock : rockSystem.getSceneObjects()) {
        renderObject(rock, rockDescSet);
    }
}

void Renderer::recordHDRPass(VkCommandBuffer cmd, uint32_t frameIndex, float grassTime) {
    VkRenderPassBeginInfo hdrPassInfo{};
    hdrPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    hdrPassInfo.renderPass = postProcessSystem.getHDRRenderPass();
    hdrPassInfo.framebuffer = postProcessSystem.getHDRFramebuffer();
    hdrPassInfo.renderArea.offset = {0, 0};
    hdrPassInfo.renderArea.extent = postProcessSystem.getExtent();

    std::array<VkClearValue, 2> clearValues{};
    clearValues[0].color = {{0.0f, 0.0f, 0.0f, 1.0f}};
    clearValues[1].depthStencil = {1.0f, 0};

    hdrPassInfo.clearValueCount = static_cast<uint32_t>(clearValues.size());
    hdrPassInfo.pClearValues = clearValues.data();

    vkCmdBeginRenderPass(cmd, &hdrPassInfo, VK_SUBPASS_CONTENTS_INLINE);

    // Draw sky (with atmosphere LUT bindings)
    skySystem.recordDraw(cmd, frameIndex);

    // Draw terrain (LEB adaptive tessellation)
    if (terrainEnabled) {
        terrainSystem.recordDraw(cmd, frameIndex);
    }

    // Draw Catmull-Clark subdivision surfaces
    catmullClarkSystem.recordDraw(cmd, frameIndex);

    // Draw scene objects (static meshes)
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
    recordSceneObjects(cmd, frameIndex);

    // Draw skinned character with GPU skinning
    {
        SceneBuilder& sceneBuilder = sceneManager.getSceneBuilder();
        if (sceneBuilder.hasCharacter()) {
            const auto& sceneObjects = sceneBuilder.getRenderables();
            size_t playerIndex = sceneBuilder.getPlayerObjectIndex();
            if (playerIndex < sceneObjects.size()) {
                const Renderable& playerObj = sceneObjects[playerIndex];
                skinnedMeshRenderer.record(cmd, frameIndex, playerObj, sceneBuilder.getAnimatedCharacter());
            }
        }
    }

    // Draw tree editor (when enabled)
    treeEditSystem.recordDraw(cmd, frameIndex);

    // Draw grass
    grassSystem.recordDraw(cmd, frameIndex, grassTime);

    // Draw water surface (after opaque geometry, blended)
    // Use temporal tile culling: skip if no tiles were visible last frame
    if (waterTileCull.wasWaterVisibleLastFrame(frameIndex)) {
        waterSystem.recordDraw(cmd, frameIndex);
    }

    // Draw falling leaves - after grass, before weather
    leafSystem.recordDraw(cmd, frameIndex, grassTime);

    // Draw weather particles (rain/snow) - after opaque geometry
    weatherSystem.recordDraw(cmd, frameIndex, grassTime);

    // Draw physics debug lines (if enabled and lines available)
#ifdef JPH_DEBUG_RENDERER
    if (physicsDebugEnabled && debugLineSystem.hasLines()) {
        // Set up viewport and scissor for debug rendering
        VkViewport viewport{};
        viewport.x = 0.0f;
        viewport.y = 0.0f;
        viewport.width = static_cast<float>(postProcessSystem.getExtent().width);
        viewport.height = static_cast<float>(postProcessSystem.getExtent().height);
        viewport.minDepth = 0.0f;
        viewport.maxDepth = 1.0f;
        vkCmdSetViewport(cmd, 0, 1, &viewport);

        VkRect2D scissor{};
        scissor.offset = {0, 0};
        scissor.extent = postProcessSystem.getExtent();
        vkCmdSetScissor(cmd, 0, 1, &scissor);

        // Need to get viewProj from the current frame data
        // For now, use the last known values (could be improved by passing as parameter)
        debugLineSystem.recordCommands(cmd, lastViewProj);
    }
#endif

    vkCmdEndRenderPass(cmd);
}

// ===== GPU Skinning Implementation =====

bool Renderer::initSkinnedMeshRenderer() {
    SkinnedMeshRenderer::InitInfo info{};
    info.device = vulkanContext.getDevice();
    info.allocator = vulkanContext.getAllocator();
    info.descriptorPool = &*descriptorManagerPool;
    info.renderPass = postProcessSystem.getHDRRenderPass();
    info.extent = vulkanContext.getSwapchainExtent();
    info.shaderPath = resourcePath + "/shaders";
    info.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    info.addCommonBindings = [this](DescriptorManager::LayoutBuilder& builder) {
        addCommonDescriptorBindings(builder);
    };

    return skinnedMeshRenderer.init(info);
}

bool Renderer::createSkinnedMeshRendererDescriptorSets() {
    const auto& whiteTexture = sceneManager.getSceneBuilder().getWhiteTexture();
    const auto& emissiveMap = sceneManager.getSceneBuilder().getDefaultEmissiveMap();

    // Build point and spot shadow views for all frames
    std::vector<VkImageView> pointShadowViews(MAX_FRAMES_IN_FLIGHT);
    std::vector<VkImageView> spotShadowViews(MAX_FRAMES_IN_FLIGHT);
    for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        pointShadowViews[i] = shadowSystem.getPointShadowArrayView(i);
        spotShadowViews[i] = shadowSystem.getSpotShadowArrayView(i);
    }

    SkinnedMeshRenderer::DescriptorResources resources{};
    resources.globalBufferManager = &globalBufferManager;
    resources.shadowMapView = shadowSystem.getShadowImageView();
    resources.shadowMapSampler = shadowSystem.getShadowSampler();
    resources.emissiveMapView = emissiveMap.getImageView();
    resources.emissiveMapSampler = emissiveMap.getSampler();
    resources.pointShadowViews = &pointShadowViews;
    resources.pointShadowSampler = shadowSystem.getPointShadowSampler();
    resources.spotShadowViews = &spotShadowViews;
    resources.spotShadowSampler = shadowSystem.getSpotShadowSampler();
    resources.snowMaskView = snowMaskSystem.getSnowMaskView();
    resources.snowMaskSampler = snowMaskSystem.getSnowMaskSampler();
    resources.whiteTextureView = whiteTexture.getImageView();
    resources.whiteTextureSampler = whiteTexture.getSampler();

    return skinnedMeshRenderer.createDescriptorSets(resources);
}

void Renderer::updateHiZObjectData() {
    std::vector<CullObjectData> cullObjects;

    // Gather scene objects for culling
    const auto& sceneObjects = sceneManager.getRenderables();
    for (size_t i = 0; i < sceneObjects.size(); ++i) {
        const auto& obj = sceneObjects[i];
        if (obj.mesh == nullptr) continue;

        // Get local AABB and transform to world space
        const AABB& localBounds = obj.mesh->getBounds();
        AABB worldBounds = localBounds.transformed(obj.transform);

        CullObjectData cullData{};

        // Calculate bounding sphere from transformed AABB
        glm::vec3 center = worldBounds.getCenter();
        glm::vec3 extents = worldBounds.getExtents();
        float radius = glm::length(extents);

        cullData.boundingSphere = glm::vec4(center, radius);
        cullData.aabbMin = glm::vec4(worldBounds.min, 0.0f);
        cullData.aabbMax = glm::vec4(worldBounds.max, 0.0f);
        cullData.meshIndex = static_cast<uint32_t>(i);
        cullData.firstIndex = 0;  // Single mesh per object
        cullData.indexCount = obj.mesh->getIndexCount();
        cullData.vertexOffset = 0;

        cullObjects.push_back(cullData);
    }

    // Also add procedural rocks
    const auto& rockObjects = rockSystem.getSceneObjects();
    for (size_t i = 0; i < rockObjects.size(); ++i) {
        const auto& obj = rockObjects[i];
        if (obj.mesh == nullptr) continue;

        const AABB& localBounds = obj.mesh->getBounds();
        AABB worldBounds = localBounds.transformed(obj.transform);

        CullObjectData cullData{};
        glm::vec3 center = worldBounds.getCenter();
        glm::vec3 extents = worldBounds.getExtents();
        float radius = glm::length(extents);

        cullData.boundingSphere = glm::vec4(center, radius);
        cullData.aabbMin = glm::vec4(worldBounds.min, 0.0f);
        cullData.aabbMax = glm::vec4(worldBounds.max, 0.0f);
        cullData.meshIndex = static_cast<uint32_t>(sceneObjects.size() + i);
        cullData.firstIndex = 0;
        cullData.indexCount = obj.mesh->getIndexCount();
        cullData.vertexOffset = 0;

        cullObjects.push_back(cullData);
    }

    hiZSystem.updateObjectData(cullObjects);
}

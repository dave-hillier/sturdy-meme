#define VMA_IMPLEMENTATION
#include "Renderer.h"
#include "ShaderLoader.h"
#include "BindingBuilder.h"
#include "GraphicsPipelineFactory.h"
#include "MaterialDescriptorFactory.h"
#include "Bindings.h"
#include <SDL3/SDL_vulkan.h>
#include <glm/gtc/matrix_transform.hpp>
#include <stdexcept>
#include <cstring>
#include <cmath>
#include <cstddef>
#include <array>
#include <limits>

bool Renderer::init(SDL_Window* win, const std::string& resPath) {
    window = win;
    resourcePath = resPath;

    // Initialize Vulkan context (instance, device, queues, allocator, swapchain)
    if (!vulkanContext.init(window)) {
        SDL_Log("Failed to initialize Vulkan context");
        return false;
    }

    // Get convenience references for the rest of initialization
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();
    VkPhysicalDevice physicalDevice = vulkanContext.getPhysicalDevice();
    VkQueue graphicsQueue = vulkanContext.getGraphicsQueue();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();
    VkFormat swapchainImageFormat = vulkanContext.getSwapchainImageFormat();
    if (!createRenderPass()) return false;
    if (!createDepthResources()) return false;
    if (!createFramebuffers()) return false;
    if (!createCommandPool()) return false;
    if (!createDescriptorSetLayout()) return false;
    if (!createDescriptorPool()) return false;

    // Initialize post-process system early to get HDR render pass
    PostProcessSystem::InitInfo postProcessInfo{};
    postProcessInfo.device = device;
    postProcessInfo.allocator = allocator;
    postProcessInfo.outputRenderPass = renderPass;
    postProcessInfo.descriptorPool = &*descriptorManagerPool;
    postProcessInfo.extent = swapchainExtent;
    postProcessInfo.swapchainFormat = swapchainImageFormat;
    postProcessInfo.shaderPath = resourcePath + "/shaders";
    postProcessInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!postProcessSystem.init(postProcessInfo)) return false;

    // Initialize bloom system
    BloomSystem::InitInfo bloomInfo{};
    bloomInfo.device = device;
    bloomInfo.allocator = allocator;
    bloomInfo.descriptorPool = &*descriptorManagerPool;
    bloomInfo.extent = swapchainExtent;
    bloomInfo.shaderPath = resourcePath + "/shaders";

    if (!bloomSystem.init(bloomInfo)) return false;

    // Bind bloom texture to post-process system
    postProcessSystem.setBloomTexture(bloomSystem.getBloomOutput(), bloomSystem.getBloomSampler());

    if (!createGraphicsPipeline()) return false;

    // Initialize skinned mesh rendering (GPU skinning for animated characters)
    if (!createSkinnedDescriptorSetLayout()) return false;
    if (!createSkinnedGraphicsPipeline()) return false;
    if (!createBoneMatricesBuffers()) return false;

    // Initialize sky system (needs HDR render pass from postProcessSystem)
    SkySystem::InitInfo skyInfo{};
    skyInfo.device = device;
    skyInfo.allocator = allocator;
    skyInfo.descriptorPool = &*descriptorManagerPool;
    skyInfo.shaderPath = resourcePath + "/shaders";
    skyInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    skyInfo.extent = swapchainExtent;
    skyInfo.hdrRenderPass = postProcessSystem.getHDRRenderPass();

    if (!skySystem.init(skyInfo)) return false;
    if (!createCommandBuffers()) return false;
    if (!createUniformBuffers()) return false;
    if (!createLightBuffers()) return false;

    // Initialize shadow system (needs descriptor set layout for pipeline compatibility)
    ShadowSystem::InitInfo shadowInfo{};
    shadowInfo.device = device;
    shadowInfo.physicalDevice = physicalDevice;
    shadowInfo.allocator = allocator;
    shadowInfo.mainDescriptorSetLayout = descriptorSetLayout;
    shadowInfo.skinnedDescriptorSetLayout = skinnedDescriptorSetLayout;  // For skinned shadow pipeline
    shadowInfo.shaderPath = resourcePath + "/shaders";
    shadowInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!shadowSystem.init(shadowInfo)) return false;

    // Initialize terrain system BEFORE scene so scene objects can query terrain height
    std::string heightmapPath = resourcePath + "/assets/terrain/isleofwight-0m-200m.png";
    std::string terrainDataPath = resourcePath + "/terrain_data";

    // Load erosion/water placement data (generated by erosion_preprocess tool during build)
    // DISABLED: Slow startup - uncomment when needed
    // ErosionLoadConfig erosionConfig{};
    // erosionConfig.sourceHeightmapPath = heightmapPath;
    // erosionConfig.cacheDirectory = terrainDataPath;
    // // Sea level: real-world 0m altitude maps to worldY = 0 - minAltitude = 15m
    // erosionConfig.seaLevel = 15.0f;
    //
    // if (erosionDataLoader.isCacheValid(erosionConfig)) {
    //     if (erosionDataLoader.loadFromCache(erosionConfig)) {
    //         const auto& waterData = erosionDataLoader.getWaterData();
    //         SDL_Log("Water placement loaded: %zu rivers, %zu lakes",
    //                 waterData.rivers.size(), waterData.lakes.size());
    //     } else {
    //         SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Failed to load erosion data");
    //     }
    // } else {
    //     SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,
    //         "Erosion data not found. Ensure build completed successfully.");
    // }

    // Initialize terrain system with CBT (loads heightmap directly)
    TerrainSystem::InitInfo terrainInfo{};
    terrainInfo.device = device;
    terrainInfo.physicalDevice = physicalDevice;
    terrainInfo.allocator = allocator;
    terrainInfo.renderPass = postProcessSystem.getHDRRenderPass();
    terrainInfo.shadowRenderPass = shadowSystem.getShadowRenderPass();
    terrainInfo.descriptorPool = &*descriptorManagerPool;
    terrainInfo.extent = swapchainExtent;
    terrainInfo.shadowMapSize = shadowSystem.getShadowMapSize();
    terrainInfo.shaderPath = resourcePath + "/shaders";
    terrainInfo.texturePath = resourcePath + "/textures";
    terrainInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    terrainInfo.graphicsQueue = graphicsQueue;
    terrainInfo.commandPool = commandPool;

    TerrainConfig terrainConfig{};
    terrainConfig.size = 16384.0f;
    terrainConfig.maxDepth = 20;
    terrainConfig.minDepth = 5;
    terrainConfig.targetEdgePixels = 16.0f;
    terrainConfig.splitThreshold = 100.0f;
    terrainConfig.mergeThreshold = 50.0f;
    // Load Isle of Wight heightmap (-15m to 200m altitude range, includes beaches below sea level)
    terrainConfig.heightmapPath = resourcePath + "/assets/terrain/isleofwight-0m-200m.png";
    terrainConfig.minAltitude = -15.0f;
    terrainConfig.maxAltitude = 220.0f;
    // heightScale is computed from minAltitude/maxAltitude during init

    // Enable LOD-based tile streaming from preprocessed tile cache
    terrainConfig.tileCacheDir = resourcePath + "/terrain_data";
    terrainConfig.tileLoadRadius = 2000.0f;   // Load high-res tiles within 2km
    terrainConfig.tileUnloadRadius = 3000.0f; // Unload tiles beyond 3km

    if (!terrainSystem.init(terrainInfo, terrainConfig)) return false;

    // Initialize scene (meshes, textures, objects, lights)
    // Pass terrain height function so objects can be placed on terrain
    SceneBuilder::InitInfo sceneInfo{};
    sceneInfo.allocator = allocator;
    sceneInfo.device = device;
    sceneInfo.commandPool = commandPool;
    sceneInfo.graphicsQueue = graphicsQueue;
    sceneInfo.physicalDevice = physicalDevice;
    sceneInfo.resourcePath = resourcePath;
    sceneInfo.getTerrainHeight = [this](float x, float z) {
        return terrainSystem.getHeightAt(x, z);
    };

    if (!sceneManager.init(sceneInfo)) return false;

    // Initialize snow mask system early (before createDescriptorSets, since shader.frag needs binding 8)
    SnowMaskSystem::InitInfo snowMaskInfo{};
    snowMaskInfo.device = device;
    snowMaskInfo.allocator = allocator;
    snowMaskInfo.renderPass = postProcessSystem.getHDRRenderPass();
    snowMaskInfo.descriptorPool = &*descriptorManagerPool;
    snowMaskInfo.extent = swapchainExtent;
    snowMaskInfo.shaderPath = resourcePath + "/shaders";
    snowMaskInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!snowMaskSystem.init(snowMaskInfo)) return false;

    // Initialize volumetric snow system (cascaded heightfield)
    VolumetricSnowSystem::InitInfo volumetricSnowInfo{};
    volumetricSnowInfo.device = device;
    volumetricSnowInfo.allocator = allocator;
    volumetricSnowInfo.renderPass = postProcessSystem.getHDRRenderPass();
    volumetricSnowInfo.descriptorPool = &*descriptorManagerPool;
    volumetricSnowInfo.extent = swapchainExtent;
    volumetricSnowInfo.shaderPath = resourcePath + "/shaders";
    volumetricSnowInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!volumetricSnowSystem.init(volumetricSnowInfo)) return false;

    if (!createDescriptorSets()) return false;
    if (!createSkinnedDescriptorSets()) return false;

    // Initialize grass system using HDR render pass
    GrassSystem::InitInfo grassInfo{};
    grassInfo.device = device;
    grassInfo.allocator = allocator;
    grassInfo.renderPass = postProcessSystem.getHDRRenderPass();
    grassInfo.shadowRenderPass = shadowSystem.getShadowRenderPass();
    grassInfo.descriptorPool = &*descriptorManagerPool;
    grassInfo.extent = swapchainExtent;
    grassInfo.shadowMapSize = shadowSystem.getShadowMapSize();
    grassInfo.shaderPath = resourcePath + "/shaders";
    grassInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!grassSystem.init(grassInfo)) return false;

    // Initialize wind system
    WindSystem::InitInfo windInfo{};
    windInfo.device = device;
    windInfo.allocator = allocator;
    windInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!windSystem.init(windInfo)) return false;

    const EnvironmentSettings* environmentSettings = &windSystem.getEnvironmentSettings();
    grassSystem.setEnvironmentSettings(environmentSettings);
    leafSystem.setEnvironmentSettings(environmentSettings);

    // Get wind buffers for grass descriptor sets
    std::vector<VkBuffer> windBuffers(MAX_FRAMES_IN_FLIGHT);
    for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        windBuffers[i] = windSystem.getBufferInfo(i).buffer;
    }
    grassSystem.updateDescriptorSets(device, uniformBuffers, shadowSystem.getShadowImageView(), shadowSystem.getShadowSampler(), windBuffers, lightBuffers,
                                      terrainSystem.getHeightMapView(), terrainSystem.getHeightMapSampler(),
                                      snowBuffers, cloudShadowBuffers,
                                      cloudShadowSystem.getShadowMapView(), cloudShadowSystem.getShadowMapSampler());

    // Update terrain descriptor sets with shared resources
    terrainSystem.updateDescriptorSets(device, uniformBuffers, shadowSystem.getShadowImageView(), shadowSystem.getShadowSampler(),
                                        snowBuffers, cloudShadowBuffers);

    // Initialize rock system (uses terrain for height queries)
    RockSystem::InitInfo rockInfo{};
    rockInfo.device = device;
    rockInfo.allocator = allocator;
    rockInfo.commandPool = commandPool;
    rockInfo.graphicsQueue = graphicsQueue;
    rockInfo.physicalDevice = physicalDevice;
    rockInfo.resourcePath = resourcePath;
    rockInfo.terrainSize = terrainConfig.size;
    rockInfo.getTerrainHeight = [this](float x, float z) {
        return terrainSystem.getHeightAt(x, z);
    };

    RockConfig rockConfig{};
    rockConfig.rockVariations = 6;
    rockConfig.rocksPerVariation = 10;
    rockConfig.minRadius = 0.4f;
    rockConfig.maxRadius = 2.0f;
    rockConfig.placementRadius = 100.0f;
    rockConfig.minDistanceBetween = 4.0f;
    rockConfig.roughness = 0.35f;
    rockConfig.asymmetry = 0.3f;
    rockConfig.subdivisions = 3;
    rockConfig.materialRoughness = 0.75f;
    rockConfig.materialMetallic = 0.0f;

    if (!rockSystem.init(rockInfo, rockConfig)) return false;

    // Update rock descriptor sets now that rock textures are loaded
    {
        MaterialDescriptorFactory factory(device);
        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            MaterialDescriptorFactory::CommonBindings common{};
            common.uniformBuffer = uniformBuffers[i];
            common.uniformBufferSize = sizeof(UniformBufferObject);
            common.shadowMapView = shadowSystem.getShadowImageView();
            common.shadowMapSampler = shadowSystem.getShadowSampler();
            common.lightBuffer = lightBuffers[i];
            common.lightBufferSize = sizeof(LightBuffer);
            common.emissiveMapView = sceneManager.getSceneBuilder().getDefaultEmissiveMap().getImageView();
            common.emissiveMapSampler = sceneManager.getSceneBuilder().getDefaultEmissiveMap().getSampler();
            common.pointShadowView = shadowSystem.getPointShadowArrayView(i);
            common.pointShadowSampler = shadowSystem.getPointShadowSampler();
            common.spotShadowView = shadowSystem.getSpotShadowArrayView(i);
            common.spotShadowSampler = shadowSystem.getSpotShadowSampler();
            common.snowMaskView = snowMaskSystem.getSnowMaskView();
            common.snowMaskSampler = snowMaskSystem.getSnowMaskSampler();
            // Placeholder texture for unused PBR bindings (13-16)
            common.placeholderTextureView = sceneManager.getSceneBuilder().getWhiteTexture().getImageView();
            common.placeholderTextureSampler = sceneManager.getSceneBuilder().getWhiteTexture().getSampler();

            MaterialDescriptorFactory::MaterialTextures mat{};
            mat.diffuseView = rockSystem.getRockTexture().getImageView();
            mat.diffuseSampler = rockSystem.getRockTexture().getSampler();
            mat.normalView = rockSystem.getRockNormalMap().getImageView();
            mat.normalSampler = rockSystem.getRockNormalMap().getSampler();
            factory.writeDescriptorSet(rockDescriptorSets[i], common, mat);
        }
    }

    // Initialize weather particle system (rain/snow)
    WeatherSystem::InitInfo weatherInfo{};
    weatherInfo.device = device;
    weatherInfo.allocator = allocator;
    weatherInfo.renderPass = postProcessSystem.getHDRRenderPass();
    weatherInfo.descriptorPool = &*descriptorManagerPool;
    weatherInfo.extent = swapchainExtent;
    weatherInfo.shaderPath = resourcePath + "/shaders";
    weatherInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!weatherSystem.init(weatherInfo)) return false;

    // Update weather system descriptor sets with wind buffers - use HDR depth where scene is rendered
    weatherSystem.updateDescriptorSets(device, uniformBuffers, windBuffers, postProcessSystem.getHDRDepthView(), shadowSystem.getShadowSampler());

    // Connect snow mask to environment settings (already initialized above)
    snowMaskSystem.setEnvironmentSettings(environmentSettings);
    volumetricSnowSystem.setEnvironmentSettings(environmentSettings);

    // Connect snow mask to terrain system (legacy)
    terrainSystem.setSnowMask(device, snowMaskSystem.getSnowMaskView(), snowMaskSystem.getSnowMaskSampler());

    // Connect volumetric snow cascades to terrain system
    terrainSystem.setVolumetricSnowCascades(device,
        volumetricSnowSystem.getCascadeView(0),
        volumetricSnowSystem.getCascadeView(1),
        volumetricSnowSystem.getCascadeView(2),
        volumetricSnowSystem.getCascadeSampler());

    // Connect snow mask to grass system
    grassSystem.setSnowMask(device, snowMaskSystem.getSnowMaskView(), snowMaskSystem.getSnowMaskSampler());

    // Initialize leaf particle system
    LeafSystem::InitInfo leafInfo{};
    leafInfo.device = device;
    leafInfo.allocator = allocator;
    leafInfo.renderPass = postProcessSystem.getHDRRenderPass();
    leafInfo.descriptorPool = &*descriptorManagerPool;
    leafInfo.extent = swapchainExtent;
    leafInfo.shaderPath = resourcePath + "/shaders";
    leafInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!leafSystem.init(leafInfo)) return false;

    // Update leaf system descriptor sets with wind buffers, terrain heightmap, and displacement map
    leafSystem.updateDescriptorSets(device, uniformBuffers, windBuffers,
                                     terrainSystem.getHeightMapView(), terrainSystem.getHeightMapSampler(),
                                     grassSystem.getDisplacementImageView(), grassSystem.getDisplacementSampler());

    // Set default leaf intensity (autumn scene)
    leafSystem.setIntensity(0.5f);

    // Initialize froxel volumetric fog system (Phase 4.3)
    FroxelSystem::InitInfo froxelInfo{};
    froxelInfo.device = device;
    froxelInfo.allocator = allocator;
    froxelInfo.descriptorPool = &*descriptorManagerPool;
    froxelInfo.extent = swapchainExtent;
    froxelInfo.shaderPath = resourcePath + "/shaders";
    froxelInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    froxelInfo.shadowMapView = shadowSystem.getShadowImageView();
    froxelInfo.shadowSampler = shadowSystem.getShadowSampler();
    froxelInfo.lightBuffers = lightBuffers;  // For local light contribution in fog

    if (!froxelSystem.init(froxelInfo)) return false;

    // Connect froxel volume to post-process system for compositing (use integrated volume)
    postProcessSystem.setFroxelVolume(froxelSystem.getIntegratedVolumeView(), froxelSystem.getVolumeSampler());
    postProcessSystem.setFroxelParams(froxelSystem.getVolumetricFarPlane(), FroxelSystem::DEPTH_DISTRIBUTION);
    postProcessSystem.setFroxelEnabled(true);

    // Connect froxel volume to weather system for fog particle lighting (Phase 4.3.9)
    weatherSystem.setFroxelVolume(froxelSystem.getScatteringVolumeView(), froxelSystem.getVolumeSampler(),
                                   froxelSystem.getVolumetricFarPlane(), FroxelSystem::DEPTH_DISTRIBUTION);

    // Initialize atmosphere LUT system (Phase 4.1)
    AtmosphereLUTSystem::InitInfo atmosphereInfo{};
    atmosphereInfo.device = device;
    atmosphereInfo.allocator = allocator;
    atmosphereInfo.descriptorPool = &*descriptorManagerPool;
    atmosphereInfo.shaderPath = resourcePath + "/shaders";
    atmosphereInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;

    if (!atmosphereLUTSystem.init(atmosphereInfo)) return false;

    // Compute atmosphere LUTs at startup
    VkCommandBuffer cmdBuffer;
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = 1;
    vkAllocateCommandBuffers(device, &allocInfo, &cmdBuffer);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    vkBeginCommandBuffer(cmdBuffer, &beginInfo);

    // Compute transmittance and multi-scatter LUTs (once at startup)
    atmosphereLUTSystem.computeTransmittanceLUT(cmdBuffer);
    atmosphereLUTSystem.computeMultiScatterLUT(cmdBuffer);
    // Compute irradiance LUTs after transmittance (Phase 4.1.9)
    atmosphereLUTSystem.computeIrradianceLUT(cmdBuffer);

    // Compute sky-view LUT for current sun direction
    glm::vec3 sunDir = glm::vec3(0.0f, 0.707f, 0.707f);  // Default 45 degree sun
    atmosphereLUTSystem.computeSkyViewLUT(cmdBuffer, sunDir, glm::vec3(0.0f), 0.0f);

    // Compute cloud map LUT (paraboloid projection)
    atmosphereLUTSystem.computeCloudMapLUT(cmdBuffer, glm::vec3(0.0f), 0.0f);

    vkEndCommandBuffer(cmdBuffer);

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &cmdBuffer;

    vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(graphicsQueue);
    vkFreeCommandBuffers(device, commandPool, 1, &cmdBuffer);

    SDL_Log("Atmosphere LUTs computed successfully");

    // Export LUTs as PNG files for visualization
    atmosphereLUTSystem.exportLUTsAsPNG(resourcePath);
    SDL_Log("Atmosphere LUTs exported as PNG to: %s", resourcePath.c_str());

    // Initialize cloud shadow system
    CloudShadowSystem::InitInfo cloudShadowInfo{};
    cloudShadowInfo.device = device;
    cloudShadowInfo.allocator = allocator;
    cloudShadowInfo.descriptorPool = &*descriptorManagerPool;
    cloudShadowInfo.shaderPath = resourcePath + "/shaders";
    cloudShadowInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    cloudShadowInfo.cloudMapLUTView = atmosphereLUTSystem.getCloudMapLUTView();
    cloudShadowInfo.cloudMapLUTSampler = atmosphereLUTSystem.getLUTSampler();

    if (!cloudShadowSystem.init(cloudShadowInfo)) return false;

    // Connect cloud shadow map to terrain system
    terrainSystem.setCloudShadowMap(device,
        cloudShadowSystem.getShadowMapView(),
        cloudShadowSystem.getShadowMapSampler());

    // Update all descriptor sets with cloud shadow map (binding 9)
    // This is done here because cloudShadowSystem is initialized after createDescriptorSets
    {
        // Update MaterialRegistry-managed descriptor sets
        sceneManager.getSceneBuilder().getMaterialRegistry().updateCloudShadowBinding(
            device,
            cloudShadowSystem.getShadowMapView(),
            cloudShadowSystem.getShadowMapSampler());

        // Update descriptor sets not managed by MaterialRegistry (rocks, skinned)
        MaterialDescriptorFactory factory(device);
        VkDescriptorSet otherSets[] = {
            rockDescriptorSets[0], rockDescriptorSets[1],
            skinnedDescriptorSets[0], skinnedDescriptorSets[1]
        };
        for (auto set : otherSets) {
            factory.updateCloudShadowBinding(set,
                cloudShadowSystem.getShadowMapView(),
                cloudShadowSystem.getShadowMapSampler());
        }
    }

    // Initialize Catmull-Clark subdivision system
    CatmullClarkSystem::InitInfo catmullClarkInfo{};
    catmullClarkInfo.device = device;
    catmullClarkInfo.physicalDevice = physicalDevice;
    catmullClarkInfo.allocator = allocator;
    catmullClarkInfo.renderPass = postProcessSystem.getHDRRenderPass();
    catmullClarkInfo.descriptorPool = &*descriptorManagerPool;
    catmullClarkInfo.extent = swapchainExtent;
    catmullClarkInfo.shaderPath = resourcePath + "/shaders";
    catmullClarkInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    catmullClarkInfo.graphicsQueue = graphicsQueue;
    catmullClarkInfo.commandPool = commandPool;

    CatmullClarkConfig catmullClarkConfig{};
    float suzanneX = 5.0f, suzanneZ = -5.0f;
    float terrainY = terrainSystem.getHeightAt(suzanneX, suzanneZ);
    catmullClarkConfig.position = glm::vec3(suzanneX, terrainY + 2.0f, suzanneZ);
    catmullClarkConfig.scale = glm::vec3(2.0f);
    catmullClarkConfig.targetEdgePixels = 12.0f;
    catmullClarkConfig.maxDepth = 16;
    catmullClarkConfig.splitThreshold = 18.0f;
    catmullClarkConfig.mergeThreshold = 6.0f;
    catmullClarkConfig.objPath = resourcePath + "/assets/suzanne.obj";

    if (!catmullClarkSystem.init(catmullClarkInfo, catmullClarkConfig)) return false;

    // Update Catmull-Clark descriptor sets with shared resources
    catmullClarkSystem.updateDescriptorSets(device, uniformBuffers);

    // Create sky descriptor sets now that uniform buffers and LUTs are ready
    if (!skySystem.createDescriptorSets(uniformBuffers, sizeof(UniformBufferObject), atmosphereLUTSystem)) return false;

    // Initialize Hi-Z occlusion culling system
    HiZSystem::InitInfo hiZInfo{};
    hiZInfo.device = device;
    hiZInfo.allocator = allocator;
    hiZInfo.descriptorPool = &*descriptorManagerPool;
    hiZInfo.extent = swapchainExtent;
    hiZInfo.shaderPath = resourcePath + "/shaders";
    hiZInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    hiZInfo.depthFormat = depthFormat;

    if (!hiZSystem.init(hiZInfo)) {
        SDL_Log("Warning: Hi-Z system initialization failed, occlusion culling disabled");
        // Continue without Hi-Z - it's an optional optimization
    } else {
        // Connect depth buffer to Hi-Z system - use HDR depth where scene is rendered
        hiZSystem.setDepthBuffer(postProcessSystem.getHDRDepthView(), depthSampler);

        // Initialize object data for culling
        updateHiZObjectData();
    }

    // Initialize profiler for GPU and CPU timing
    if (!profiler.init(device, physicalDevice, MAX_FRAMES_IN_FLIGHT)) {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Profiler initialization failed - profiling disabled");
        // Continue without profiling - it's optional
    }

    // Initialize water system - sea covering terrain areas below sea level
    WaterSystem::InitInfo waterInfo{};
    waterInfo.device = device;
    waterInfo.physicalDevice = physicalDevice;
    waterInfo.allocator = allocator;
    waterInfo.descriptorPool = &*descriptorManagerPool;
    waterInfo.hdrRenderPass = postProcessSystem.getHDRRenderPass();
    waterInfo.shaderPath = resourcePath + "/shaders";
    waterInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    waterInfo.extent = swapchainExtent;
    waterInfo.commandPool = commandPool;
    waterInfo.graphicsQueue = graphicsQueue;
    waterInfo.waterSize = 65536.0f;  // Extend well beyond terrain for horizon
    waterInfo.assetPath = resourcePath;

    if (!waterSystem.init(waterInfo)) return false;

    // Configure water surface
    // Terrain formula is worldY = h * heightScale, where h is normalized [0,1]
    // h=0 maps to minAltitude, h=1 maps to maxAltitude
    // Real-world 0m altitude corresponds to worldY = 0 - minAltitude = 15m
    float seaLevel = -terrainConfig.minAltitude;  // = 15.0f for minAltitude = -15
    waterSystem.setWaterLevel(seaLevel);
    waterSystem.setWaterExtent(glm::vec2(0.0f, 0.0f), glm::vec2(65536.0f, 65536.0f));
    // English estuary/coastal water style - murky grey-green, moderate chop
    waterSystem.setWaterColor(glm::vec4(0.15f, 0.22f, 0.25f, 0.9f));  // Grey-green estuary
    waterSystem.setWaveAmplitude(0.3f);   // English Channel swell
    waterSystem.setWaveLength(15.0f);     // Medium wavelengths
    waterSystem.setWaveSteepness(0.25f);
    waterSystem.setWaveSpeed(0.5f);
    waterSystem.setTidalRange(3.0f);      // Â±3m tidal range (English Channel has large tides)

    // Set terrain params for shore detection
    waterSystem.setTerrainParams(terrainConfig.size, terrainConfig.heightScale);
    waterSystem.setShoreBlendDistance(8.0f);   // Wider soft edge (was 3.0)
    waterSystem.setShoreFoamWidth(15.0f);      // Shore foam band 15m wide (was 8.0)

    // Set camera planes for depth linearization (used for soft edges, intersection foam)
    // Values must match Camera.cpp defaults: nearPlane=0.1f, farPlane=50000.0f
    waterSystem.setCameraPlanes(0.1f, 50000.0f);

    // Initialize flow map generator
    if (!flowMapGenerator.init(device, allocator, commandPool, graphicsQueue)) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to initialize flow map generator");
        return false;
    }

    // Generate flow map from terrain data
    FlowMapGenerator::Config flowConfig{};
    flowConfig.resolution = 512;
    flowConfig.worldSize = terrainConfig.size;
    flowConfig.waterLevel = seaLevel;
    flowConfig.maxFlowSpeed = 1.0f;
    flowConfig.slopeInfluence = 2.0f;  // Water flows faster on steeper slopes
    flowConfig.shoreDistance = 100.0f; // Max shore distance for foam

    // Get terrain height data and generate slope-based flow
    const float* heightData = terrainSystem.getHeightMapData();
    uint32_t heightRes = terrainSystem.getHeightMapResolution();
    if (heightData && heightRes > 0) {
        std::vector<float> heightVec(heightData, heightData + heightRes * heightRes);
        if (!flowMapGenerator.generateFromTerrain(heightVec, heightRes, terrainConfig.heightScale, flowConfig)) {
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Flow map generation failed, using radial flow fallback");
            flowMapGenerator.generateRadialFlow(flowConfig, glm::vec2(0.0f));
        }
    } else {
        // Fallback to radial flow for testing
        SDL_Log("No terrain height data available, generating radial flow map");
        flowMapGenerator.generateRadialFlow(flowConfig, glm::vec2(0.0f));
    }

    // Initialize water displacement system (Phase 4: interactive splashes)
    WaterDisplacement::InitInfo dispInfo{};
    dispInfo.device = device;
    dispInfo.physicalDevice = physicalDevice;
    dispInfo.allocator = allocator;
    dispInfo.commandPool = commandPool;
    dispInfo.computeQueue = graphicsQueue;  // Use graphics queue for compute
    dispInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    dispInfo.displacementResolution = 512;
    dispInfo.worldSize = 65536.0f;

    if (!waterDisplacement.init(dispInfo)) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to initialize water displacement");
        return false;
    }

    // Initialize foam buffer (Phase 14: temporal foam persistence)
    FoamBuffer::InitInfo foamInfo{};
    foamInfo.device = device;
    foamInfo.physicalDevice = physicalDevice;
    foamInfo.allocator = allocator;
    foamInfo.commandPool = commandPool;
    foamInfo.computeQueue = graphicsQueue;
    foamInfo.shaderPath = resourcePath + "/shaders";
    foamInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    foamInfo.resolution = 512;
    foamInfo.worldSize = 65536.0f;

    if (!foamBuffer.init(foamInfo)) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to initialize foam buffer");
        return false;
    }

    // Initialize SSR system (Phase 10: Screen-Space Reflections)
    SSRSystem::InitInfo ssrInfo{};
    ssrInfo.device = device;
    ssrInfo.physicalDevice = physicalDevice;
    ssrInfo.allocator = allocator;
    ssrInfo.commandPool = commandPool;
    ssrInfo.computeQueue = graphicsQueue;
    ssrInfo.shaderPath = resourcePath + "/shaders";
    ssrInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    ssrInfo.extent = swapchainExtent;

    if (!ssrSystem.init(ssrInfo)) {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Failed to initialize SSR system - continuing without SSR");
        // Don't fail init - SSR is optional
    }

    // Initialize water tile culling (Phase 7: screen-space tile visibility)
    WaterTileCull::InitInfo tileCullInfo{};
    tileCullInfo.device = device;
    tileCullInfo.physicalDevice = physicalDevice;
    tileCullInfo.allocator = allocator;
    tileCullInfo.commandPool = commandPool;
    tileCullInfo.computeQueue = graphicsQueue;
    tileCullInfo.shaderPath = resourcePath + "/shaders";
    tileCullInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    tileCullInfo.extent = swapchainExtent;
    tileCullInfo.tileSize = 32;

    if (!waterTileCull.init(tileCullInfo)) {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Failed to initialize water tile cull - continuing without");
        // Don't fail init - tile culling is optional optimization
    }

    // Initialize water G-buffer (Phase 3)
    WaterGBuffer::InitInfo gbufferInfo{};
    gbufferInfo.device = device;
    gbufferInfo.physicalDevice = physicalDevice;
    gbufferInfo.allocator = allocator;
    gbufferInfo.fullResExtent = swapchainExtent;
    gbufferInfo.resolutionScale = 0.5f;  // Half resolution for performance
    gbufferInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    gbufferInfo.shaderPath = resourcePath + "/shaders";
    gbufferInfo.descriptorPool = &*descriptorManagerPool;

    if (!waterGBuffer.init(gbufferInfo)) {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Failed to initialize water G-buffer - continuing without");
        // Don't fail init - G-buffer is optional optimization
    }

    // Create water descriptor sets with terrain heightmap, flow map, displacement map, temporal foam, SSR, and scene depth
    if (!waterSystem.createDescriptorSets(uniformBuffers, sizeof(UniformBufferObject), shadowSystem,
                                          terrainSystem.getHeightMapView(), terrainSystem.getHeightMapSampler(),
                                          flowMapGenerator.getFlowMapView(), flowMapGenerator.getFlowMapSampler(),
                                          waterDisplacement.getDisplacementMapView(), waterDisplacement.getSampler(),
                                          foamBuffer.getFoamBufferView(), foamBuffer.getSampler(),
                                          ssrSystem.getSSRResultView(), ssrSystem.getSampler(),
                                          postProcessSystem.getHDRDepthView(), depthSampler)) return false;

    // Create water G-buffer descriptor sets
    if (waterGBuffer.getPipeline() != VK_NULL_HANDLE) {
        if (!waterGBuffer.createDescriptorSets(
                uniformBuffers, sizeof(UniformBufferObject),
                waterSystem.getUniformBuffers(), WaterSystem::getUniformBufferSize(),
                terrainSystem.getHeightMapView(), terrainSystem.getHeightMapSampler(),
                flowMapGenerator.getFlowMapView(), flowMapGenerator.getFlowMapSampler())) {
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Failed to create water G-buffer descriptor sets");
        }
    }

    // Initialize tree edit system
    TreeEditSystem::InitInfo treeEditInfo{};
    treeEditInfo.device = device;
    treeEditInfo.physicalDevice = physicalDevice;
    treeEditInfo.allocator = allocator;
    treeEditInfo.renderPass = postProcessSystem.getHDRRenderPass();
    treeEditInfo.descriptorPool = &*descriptorManagerPool;
    treeEditInfo.extent = swapchainExtent;
    treeEditInfo.shaderPath = resourcePath + "/shaders";
    treeEditInfo.framesInFlight = MAX_FRAMES_IN_FLIGHT;
    treeEditInfo.graphicsQueue = graphicsQueue;
    treeEditInfo.commandPool = commandPool;

    if (!treeEditSystem.init(treeEditInfo)) return false;

    // Update tree edit system descriptor sets with scene UBOs
    treeEditSystem.updateDescriptorSets(device, uniformBuffers);

    if (!createSyncObjects()) return false;

    return true;
}

void Renderer::setWeatherIntensity(float intensity) {
    weatherSystem.setIntensity(intensity);
}

void Renderer::setWeatherType(uint32_t type) {
    weatherSystem.setWeatherType(type);
}

void Renderer::setPlayerPosition(const glm::vec3& position, float radius) {
    setPlayerState(position, glm::vec3(0.0f), radius);
}

void Renderer::setPlayerState(const glm::vec3& position, const glm::vec3& velocity, float radius) {
    playerPosition = position;
    playerVelocity = velocity;
    playerCapsuleRadius = radius;
}

void Renderer::shutdown() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();

    if (device != VK_NULL_HANDLE) {
        vkDeviceWaitIdle(device);

        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr);
            vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr);
            vkDestroyFence(device, inFlightFences[i], nullptr);
        }

        sceneManager.destroy(allocator, device);

        // Clean up the auto-growing descriptor pool
        if (descriptorManagerPool.has_value()) {
            descriptorManagerPool->destroy();
            descriptorManagerPool.reset();
        }

        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            vmaDestroyBuffer(allocator, uniformBuffers[i], uniformBuffersAllocations[i]);
        }

        // Clean up snow UBO buffers
        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            if (snowBuffers.size() > i && snowBuffers[i] != VK_NULL_HANDLE) {
                vmaDestroyBuffer(allocator, snowBuffers[i], snowBuffersAllocations[i]);
            }
        }

        // Clean up cloud shadow UBO buffers
        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            if (cloudShadowBuffers.size() > i && cloudShadowBuffers[i] != VK_NULL_HANDLE) {
                vmaDestroyBuffer(allocator, cloudShadowBuffers[i], cloudShadowBuffersAllocations[i]);
            }
        }

        // Clean up light buffers
        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            if (lightBuffers.size() > i && lightBuffers[i] != VK_NULL_HANDLE) {
                vmaDestroyBuffer(allocator, lightBuffers[i], lightBufferAllocations[i]);
            }
        }

        grassSystem.destroy(device, allocator);
        terrainSystem.destroy(device, allocator);
        catmullClarkSystem.destroy(device, allocator);
        rockSystem.destroy(allocator, device);
        windSystem.destroy(device, allocator);
        weatherSystem.destroy(device, allocator);
        snowMaskSystem.destroy(device, allocator);
        volumetricSnowSystem.destroy(device, allocator);
        leafSystem.destroy(device, allocator);
        froxelSystem.destroy(device, allocator);
        cloudShadowSystem.destroy();
        hiZSystem.destroy();
        profiler.shutdown();
        waterSystem.destroy(device, allocator);
        waterDisplacement.destroy();
        foamBuffer.destroy();
        ssrSystem.destroy();
        waterTileCull.destroy();
        waterGBuffer.destroy();
        flowMapGenerator.destroy(device, allocator);
        treeEditSystem.destroy(device, allocator);
        atmosphereLUTSystem.destroy(device, allocator);
        skySystem.destroy(device, allocator);
        postProcessSystem.destroy(device, allocator);
        bloomSystem.destroy(device, allocator);

        vkDestroyPipeline(device, graphicsPipeline, nullptr);
        vkDestroyPipelineLayout(device, pipelineLayout, nullptr);
        vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr);

        // Clean up skinned mesh resources
        if (skinnedGraphicsPipeline != VK_NULL_HANDLE) {
            vkDestroyPipeline(device, skinnedGraphicsPipeline, nullptr);
        }
        if (skinnedPipelineLayout != VK_NULL_HANDLE) {
            vkDestroyPipelineLayout(device, skinnedPipelineLayout, nullptr);
        }
        if (skinnedDescriptorSetLayout != VK_NULL_HANDLE) {
            vkDestroyDescriptorSetLayout(device, skinnedDescriptorSetLayout, nullptr);
        }
        for (size_t i = 0; i < boneMatricesBuffers.size(); ++i) {
            if (boneMatricesBuffers[i] != VK_NULL_HANDLE) {
                vmaDestroyBuffer(allocator, boneMatricesBuffers[i], boneMatricesAllocations[i]);
            }
        }

        // Shadow system cleanup
        shadowSystem.destroy();

        vkDestroyCommandPool(device, commandPool, nullptr);

        // Clean up Renderer-specific resources (depth, framebuffers, renderPass)
        destroyRenderResources();
    }

    vulkanContext.shutdown();
}

void Renderer::destroyRenderResources() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();

    if (depthSampler != VK_NULL_HANDLE) {
        vkDestroySampler(device, depthSampler, nullptr);
        depthSampler = VK_NULL_HANDLE;
    }
    if (depthImageView != VK_NULL_HANDLE) {
        vkDestroyImageView(device, depthImageView, nullptr);
        depthImageView = VK_NULL_HANDLE;
    }
    if (depthImage != VK_NULL_HANDLE) {
        vmaDestroyImage(allocator, depthImage, depthImageAllocation);
        depthImage = VK_NULL_HANDLE;
    }

    for (auto framebuffer : framebuffers) {
        vkDestroyFramebuffer(device, framebuffer, nullptr);
    }
    framebuffers.clear();

    if (renderPass != VK_NULL_HANDLE) {
        vkDestroyRenderPass(device, renderPass, nullptr);
        renderPass = VK_NULL_HANDLE;
    }
}

bool Renderer::createRenderPass() {
    VkDevice device = vulkanContext.getDevice();
    VkFormat swapchainImageFormat = vulkanContext.getSwapchainImageFormat();

    VkAttachmentDescription colorAttachment{};
    colorAttachment.format = swapchainImageFormat;
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    VkAttachmentDescription depthAttachment{};
    depthAttachment.format = VK_FORMAT_D32_SFLOAT;
    depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    // Store depth for Hi-Z pyramid generation
    depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    // Transition to shader read for Hi-Z
    depthAttachment.finalLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

    depthFormat = VK_FORMAT_D32_SFLOAT;

    VkAttachmentReference colorAttachmentRef{};
    colorAttachmentRef.attachment = 0;
    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    VkAttachmentReference depthAttachmentRef{};
    depthAttachmentRef.attachment = 1;
    depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkSubpassDescription subpass{};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &colorAttachmentRef;
    subpass.pDepthStencilAttachment = &depthAttachmentRef;

    VkSubpassDependency dependency{};
    dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
    dependency.dstSubpass = 0;
    dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    dependency.srcAccessMask = 0;
    dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

    std::array<VkAttachmentDescription, 2> attachments = {colorAttachment, depthAttachment};

    VkRenderPassCreateInfo renderPassInfo{};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
    renderPassInfo.pAttachments = attachments.data();
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &subpass;
    renderPassInfo.dependencyCount = 1;
    renderPassInfo.pDependencies = &dependency;

    if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) {
        SDL_Log("Failed to create render pass");
        return false;
    }

    return true;
}

bool Renderer::createDepthResources() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();

    VkImageCreateInfo imageInfo{};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.width = swapchainExtent.width;
    imageInfo.extent.height = swapchainExtent.height;
    imageInfo.extent.depth = 1;
    imageInfo.mipLevels = 1;
    imageInfo.arrayLayers = 1;
    imageInfo.format = depthFormat;
    imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    // Add SAMPLED_BIT for Hi-Z pyramid generation
    imageInfo.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    VmaAllocationCreateInfo allocInfo{};
    allocInfo.usage = VMA_MEMORY_USAGE_AUTO;

    if (vmaCreateImage(allocator, &imageInfo, &allocInfo, &depthImage, &depthImageAllocation, nullptr) != VK_SUCCESS) {
        SDL_Log("Failed to create depth image");
        return false;
    }

    VkImageViewCreateInfo viewInfo{};
    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    viewInfo.image = depthImage;
    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    viewInfo.format = depthFormat;
    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
    viewInfo.subresourceRange.baseMipLevel = 0;
    viewInfo.subresourceRange.levelCount = 1;
    viewInfo.subresourceRange.baseArrayLayer = 0;
    viewInfo.subresourceRange.layerCount = 1;

    if (vkCreateImageView(device, &viewInfo, nullptr, &depthImageView) != VK_SUCCESS) {
        SDL_Log("Failed to create depth image view");
        return false;
    }

    // Create depth sampler for Hi-Z pyramid generation
    VkSamplerCreateInfo samplerInfo{};
    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    samplerInfo.magFilter = VK_FILTER_NEAREST;
    samplerInfo.minFilter = VK_FILTER_NEAREST;
    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;
    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    samplerInfo.minLod = 0.0f;
    samplerInfo.maxLod = 0.0f;
    samplerInfo.borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;

    if (vkCreateSampler(device, &samplerInfo, nullptr, &depthSampler) != VK_SUCCESS) {
        SDL_Log("Failed to create depth sampler");
        return false;
    }

    return true;
}

bool Renderer::createFramebuffers() {
    VkDevice device = vulkanContext.getDevice();
    const auto& swapchainImageViews = vulkanContext.getSwapchainImageViews();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();

    framebuffers.resize(swapchainImageViews.size());

    for (size_t i = 0; i < swapchainImageViews.size(); i++) {
        std::array<VkImageView, 2> attachments = {
            swapchainImageViews[i],
            depthImageView
        };

        VkFramebufferCreateInfo framebufferInfo{};
        framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass = renderPass;
        framebufferInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
        framebufferInfo.pAttachments = attachments.data();
        framebufferInfo.width = swapchainExtent.width;
        framebufferInfo.height = swapchainExtent.height;
        framebufferInfo.layers = 1;

        if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &framebuffers[i]) != VK_SUCCESS) {
            SDL_Log("Failed to create framebuffer");
            return false;
        }
    }

    return true;
}

bool Renderer::createCommandPool() {
    VkDevice device = vulkanContext.getDevice();
    uint32_t queueFamilyIndex = vulkanContext.getGraphicsQueueFamily();

    VkCommandPoolCreateInfo poolInfo{};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    poolInfo.queueFamilyIndex = queueFamilyIndex;

    if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
        SDL_Log("Failed to create command pool");
        return false;
    }

    return true;
}

bool Renderer::createCommandBuffers() {
    VkDevice device = vulkanContext.getDevice();

    commandBuffers.resize(MAX_FRAMES_IN_FLIGHT);

    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = static_cast<uint32_t>(commandBuffers.size());

    if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) {
        SDL_Log("Failed to allocate command buffers");
        return false;
    }

    return true;
}

bool Renderer::createSyncObjects() {
    VkDevice device = vulkanContext.getDevice();

    imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
    inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

    VkSemaphoreCreateInfo semaphoreInfo{};
    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

    VkFenceCreateInfo fenceInfo{};
    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphores[i]) != VK_SUCCESS ||
            vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphores[i]) != VK_SUCCESS ||
            vkCreateFence(device, &fenceInfo, nullptr, &inFlightFences[i]) != VK_SUCCESS) {
            SDL_Log("Failed to create sync objects");
            return false;
        }
    }

    return true;
}

// Adds the common descriptor bindings shared between main and skinned layouts.
// This ensures both layouts stay in sync for bindings used by shader.frag.
void Renderer::addCommonDescriptorBindings(DescriptorManager::LayoutBuilder& builder) {
    builder
        .addUniformBuffer(VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT)  // 0: UBO
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 1: diffuse
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 2: shadow
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 3: normal
        .addStorageBuffer(VK_SHADER_STAGE_FRAGMENT_BIT)         // 4: lights
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 5: emissive
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 6: point shadow
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 7: spot shadow
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 8: snow mask
        .addCombinedImageSampler(VK_SHADER_STAGE_FRAGMENT_BIT)  // 9: cloud shadow map
        .addUniformBuffer(VK_SHADER_STAGE_FRAGMENT_BIT)         // 10: Snow UBO
        .addUniformBuffer(VK_SHADER_STAGE_FRAGMENT_BIT)         // 11: Cloud shadow UBO
        // Note: binding 12 (bone matrices) is added separately for skinned layout
        .addBinding(Bindings::ROUGHNESS_MAP, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT)  // 13: roughness
        .addBinding(Bindings::METALLIC_MAP, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT)   // 14: metallic
        .addBinding(Bindings::AO_MAP, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT)         // 15: AO
        .addBinding(Bindings::HEIGHT_MAP, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT);    // 16: height
}

bool Renderer::createDescriptorSetLayout() {
    VkDevice device = vulkanContext.getDevice();

    // Main scene descriptor set layout - uses common bindings (0-11, 13-16)
    DescriptorManager::LayoutBuilder builder(device);
    addCommonDescriptorBindings(builder);
    descriptorSetLayout = builder.build();

    if (descriptorSetLayout == VK_NULL_HANDLE) {
        SDL_Log("Failed to create descriptor set layout");
        return false;
    }

    return true;
}

bool Renderer::createGraphicsPipeline() {
    VkDevice device = vulkanContext.getDevice();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();

    // Create pipeline layout (still needed - factory expects it to be provided)
    VkPushConstantRange pushConstantRange{};
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange.offset = 0;
    pushConstantRange.size = sizeof(PushConstants);

    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout;
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;

    if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create pipeline layout");
        return false;
    }

    // Use factory for pipeline creation
    auto bindingDescription = Vertex::getBindingDescription();
    auto attributeDescriptions = Vertex::getAttributeDescriptions();

    GraphicsPipelineFactory factory(device);
    bool success = factory
        .applyPreset(GraphicsPipelineFactory::Preset::Default)
        .setShaders(resourcePath + "/shaders/shader.vert.spv",
                    resourcePath + "/shaders/shader.frag.spv")
        .setVertexInput({bindingDescription},
                        {attributeDescriptions.begin(), attributeDescriptions.end()})
        .setRenderPass(postProcessSystem.getHDRRenderPass())
        .setPipelineLayout(pipelineLayout)
        .setExtent(swapchainExtent)
        .setBlendMode(GraphicsPipelineFactory::BlendMode::Alpha)
        .build(graphicsPipeline);

    if (!success) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create graphics pipeline");
        return false;
    }

    return true;
}

bool Renderer::createUniformBuffers() {
    VmaAllocator allocator = vulkanContext.getAllocator();
    VkDeviceSize bufferSize = sizeof(UniformBufferObject);

    uniformBuffers.resize(MAX_FRAMES_IN_FLIGHT);
    uniformBuffersAllocations.resize(MAX_FRAMES_IN_FLIGHT);
    uniformBuffersMapped.resize(MAX_FRAMES_IN_FLIGHT);

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        VkBufferCreateInfo bufferInfo{};
        bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = bufferSize;
        bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
        bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

        VmaAllocationCreateInfo allocInfo{};
        allocInfo.usage = VMA_MEMORY_USAGE_AUTO;
        allocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_MAPPED_BIT;

        VmaAllocationInfo allocationInfo;
        if (vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &uniformBuffers[i],
                            &uniformBuffersAllocations[i], &allocationInfo) != VK_SUCCESS) {
            SDL_Log("Failed to create uniform buffer");
            return false;
        }

        uniformBuffersMapped[i] = allocationInfo.pMappedData;
    }

    // Create snow UBO buffers (binding 14)
    snowBuffers.resize(MAX_FRAMES_IN_FLIGHT);
    snowBuffersAllocations.resize(MAX_FRAMES_IN_FLIGHT);
    snowBuffersMapped.resize(MAX_FRAMES_IN_FLIGHT);

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        VkBufferCreateInfo bufferInfo{};
        bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = sizeof(SnowUBO);
        bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
        bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

        VmaAllocationCreateInfo allocInfo{};
        allocInfo.usage = VMA_MEMORY_USAGE_AUTO;
        allocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_MAPPED_BIT;

        VmaAllocationInfo allocationInfo;
        if (vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &snowBuffers[i],
                            &snowBuffersAllocations[i], &allocationInfo) != VK_SUCCESS) {
            SDL_Log("Failed to create snow UBO buffer");
            return false;
        }

        snowBuffersMapped[i] = allocationInfo.pMappedData;
    }

    // Create cloud shadow UBO buffers (binding 15)
    cloudShadowBuffers.resize(MAX_FRAMES_IN_FLIGHT);
    cloudShadowBuffersAllocations.resize(MAX_FRAMES_IN_FLIGHT);
    cloudShadowBuffersMapped.resize(MAX_FRAMES_IN_FLIGHT);

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        VkBufferCreateInfo bufferInfo{};
        bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = sizeof(CloudShadowUBO);
        bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
        bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

        VmaAllocationCreateInfo allocInfo{};
        allocInfo.usage = VMA_MEMORY_USAGE_AUTO;
        allocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_MAPPED_BIT;

        VmaAllocationInfo allocationInfo;
        if (vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &cloudShadowBuffers[i],
                            &cloudShadowBuffersAllocations[i], &allocationInfo) != VK_SUCCESS) {
            SDL_Log("Failed to create cloud shadow UBO buffer");
            return false;
        }

        cloudShadowBuffersMapped[i] = allocationInfo.pMappedData;
    }

    return true;
}

bool Renderer::createLightBuffers() {
    VmaAllocator allocator = vulkanContext.getAllocator();
    VkDeviceSize bufferSize = sizeof(LightBuffer);

    lightBuffers.resize(MAX_FRAMES_IN_FLIGHT);
    lightBufferAllocations.resize(MAX_FRAMES_IN_FLIGHT);
    lightBuffersMapped.resize(MAX_FRAMES_IN_FLIGHT);

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        VkBufferCreateInfo bufferInfo{};
        bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = bufferSize;
        bufferInfo.usage = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
        bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

        VmaAllocationCreateInfo allocInfo{};
        allocInfo.usage = VMA_MEMORY_USAGE_AUTO;
        allocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_MAPPED_BIT;

        VmaAllocationInfo allocationInfo;
        if (vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &lightBuffers[i],
                            &lightBufferAllocations[i], &allocationInfo) != VK_SUCCESS) {
            SDL_Log("Failed to create light buffer");
            return false;
        }

        lightBuffersMapped[i] = allocationInfo.pMappedData;

        // Initialize with empty light buffer
        LightBuffer emptyBuffer{};
        emptyBuffer.lightCount = glm::uvec4(0, 0, 0, 0);
        memcpy(lightBuffersMapped[i], &emptyBuffer, sizeof(LightBuffer));
    }

    return true;
}

void Renderer::updateLightBuffer(uint32_t currentImage, const Camera& camera) {
    LightBuffer buffer{};
    glm::mat4 viewProj = camera.getProjectionMatrix() * camera.getViewMatrix();
    sceneManager.getLightManager().buildLightBuffer(buffer, camera.getPosition(), camera.getFront(), viewProj, lightCullRadius);
    memcpy(lightBuffersMapped[currentImage], &buffer, sizeof(LightBuffer));
}

bool Renderer::createDescriptorPool() {
    VkDevice device = vulkanContext.getDevice();

    // Create the auto-growing descriptor pool
    // Initial capacity of 64 sets per pool, will automatically grow if exhausted
    // All subsystems now use this managed pool for consistent descriptor allocation
    descriptorManagerPool.emplace(device, 64);

    return true;
}

bool Renderer::createDescriptorSets() {
    VkDevice device = vulkanContext.getDevice();

    // Create descriptor sets for all materials via MaterialRegistry
    // This replaces the hardcoded per-material descriptor set allocation
    auto& materialRegistry = sceneManager.getSceneBuilder().getMaterialRegistry();

    // Lambda to build common bindings for a given frame
    auto getCommonBindings = [this](uint32_t frameIndex) -> MaterialDescriptorFactory::CommonBindings {
        MaterialDescriptorFactory::CommonBindings common{};
        common.uniformBuffer = uniformBuffers[frameIndex];
        common.uniformBufferSize = sizeof(UniformBufferObject);
        common.shadowMapView = shadowSystem.getShadowImageView();
        common.shadowMapSampler = shadowSystem.getShadowSampler();
        common.lightBuffer = lightBuffers[frameIndex];
        common.lightBufferSize = sizeof(LightBuffer);
        common.emissiveMapView = sceneManager.getSceneBuilder().getDefaultEmissiveMap().getImageView();
        common.emissiveMapSampler = sceneManager.getSceneBuilder().getDefaultEmissiveMap().getSampler();
        common.pointShadowView = shadowSystem.getPointShadowArrayView(frameIndex);
        common.pointShadowSampler = shadowSystem.getPointShadowSampler();
        common.spotShadowView = shadowSystem.getSpotShadowArrayView(frameIndex);
        common.spotShadowSampler = shadowSystem.getSpotShadowSampler();
        common.snowMaskView = snowMaskSystem.getSnowMaskView();
        common.snowMaskSampler = snowMaskSystem.getSnowMaskSampler();
        // Snow and cloud shadow UBOs (bindings 10 and 11)
        common.snowUboBuffer = snowBuffers[frameIndex];
        common.snowUboBufferSize = sizeof(SnowUBO);
        common.cloudShadowUboBuffer = cloudShadowBuffers[frameIndex];
        common.cloudShadowUboBufferSize = sizeof(CloudShadowUBO);
        // Cloud shadow texture is added later in init() after cloudShadowSystem is initialized
        // Placeholder texture for unused PBR bindings (13-16)
        common.placeholderTextureView = sceneManager.getSceneBuilder().getWhiteTexture().getImageView();
        common.placeholderTextureSampler = sceneManager.getSceneBuilder().getWhiteTexture().getSampler();
        return common;
    };

    materialRegistry.createDescriptorSets(
        device,
        *descriptorManagerPool,
        descriptorSetLayout,
        MAX_FRAMES_IN_FLIGHT,
        getCommonBindings);

    if (!materialRegistry.hasDescriptorSets()) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create MaterialRegistry descriptor sets");
        return false;
    }

    // Rock descriptor sets (RockSystem has its own textures, not in MaterialRegistry)
    rockDescriptorSets = descriptorManagerPool->allocate(descriptorSetLayout, MAX_FRAMES_IN_FLIGHT);
    if (rockDescriptorSets.empty()) {
        SDL_Log("Failed to allocate rock descriptor sets");
        return false;
    }

    // Write rock descriptor sets
    MaterialDescriptorFactory factory(device);
    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        MaterialDescriptorFactory::CommonBindings common = getCommonBindings(static_cast<uint32_t>(i));

        MaterialDescriptorFactory::MaterialTextures mat{};
        mat.diffuseView = rockSystem.getRockTexture().getImageView();
        mat.diffuseSampler = rockSystem.getRockTexture().getSampler();
        mat.normalView = rockSystem.getRockNormalMap().getImageView();
        mat.normalSampler = rockSystem.getRockNormalMap().getSampler();
        factory.writeDescriptorSet(rockDescriptorSets[i], common, mat);
    }

    return true;
}


void Renderer::updateUniformBuffer(uint32_t currentImage, const Camera& camera) {
    // Update time of day (state mutation)
    static auto startTime = std::chrono::high_resolution_clock::now();
    auto currentTime = std::chrono::high_resolution_clock::now();
    float time = std::chrono::duration<float, std::chrono::seconds::period>(currentTime - startTime).count();

    float cycleDuration = 120.0f;
    if (useManualTime) {
        currentTimeOfDay = manualTime;
    } else {
        currentTimeOfDay = fmod((time * timeScale) / cycleDuration, 1.0f);
    }

    // Pure calculations
    LightingParams lighting = calculateLightingParams(currentTimeOfDay);

    // Calculate and apply tide based on celestial positions
    DateTime dateTime = DateTime::fromTimeOfDay(currentTimeOfDay, currentYear, currentMonth, currentDay);
    TideInfo tide = celestialCalculator.calculateTide(dateTime);
    waterSystem.updateTide(tide.height);

    // Update cascade matrices via shadow system
    shadowSystem.updateCascadeMatrices(lighting.sunDir, camera);

    // Build UBO data (pure calculation)
    UniformBufferObject ubo = buildUniformBufferData(camera, lighting, currentTimeOfDay);
    SnowUBO snowUbo = buildSnowUBOData();
    CloudShadowUBO cloudShadowUbo = buildCloudShadowUBOData();

    // State mutations
    lastSunIntensity = lighting.sunIntensity;
    memcpy(uniformBuffersMapped[currentImage], &ubo, sizeof(ubo));
    memcpy(snowBuffersMapped[currentImage], &snowUbo, sizeof(snowUbo));
    memcpy(cloudShadowBuffersMapped[currentImage], &cloudShadowUbo, sizeof(cloudShadowUbo));

    // Update light buffer with camera-based culling
    updateLightBuffer(currentImage, camera);

    // Calculate sun screen position (pure) and update post-process (state mutation)
    glm::vec2 sunScreenPos = calculateSunScreenPos(camera, lighting.sunDir);
    postProcessSystem.setSunScreenPos(sunScreenPos);

    // Update HDR enabled state
    postProcessSystem.setHDREnabled(hdrEnabled);
}

void Renderer::render(const Camera& camera) {
    VkDevice device = vulkanContext.getDevice();
    VkSwapchainKHR swapchain = vulkanContext.getSwapchain();
    VkQueue graphicsQueue = vulkanContext.getGraphicsQueue();
    VkQueue presentQueue = vulkanContext.getPresentQueue();

    // Handle pending resize before acquiring next image
    if (framebufferResized) {
        handleResize();
        swapchain = vulkanContext.getSwapchain();  // Update after resize
    }

    // Skip rendering if window is minimized
    VkExtent2D extent = vulkanContext.getSwapchainExtent();
    if (extent.width == 0 || extent.height == 0) {
        return;
    }

    // Frame synchronization
    vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

    uint32_t imageIndex;
    VkResult result = vkAcquireNextImageKHR(device, swapchain, UINT64_MAX,
                                            imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);

    if (result == VK_ERROR_OUT_OF_DATE_KHR) {
        handleResize();
        return;
    } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to acquire swapchain image");
        return;
    }

    vkResetFences(device, 1, &inFlightFences[currentFrame]);

    // Begin CPU profiling for this frame
    profiler.beginCpuZone("UniformUpdates");

    // Update uniform buffer data
    updateUniformBuffer(currentFrame, camera);

    // Update bone matrices for GPU skinning
    updateBoneMatrices(currentFrame);

    profiler.endCpuZone("UniformUpdates");

    // Calculate frame timing
    static auto startTime = std::chrono::high_resolution_clock::now();
    static auto lastTime = startTime;
    auto currentTime = std::chrono::high_resolution_clock::now();
    float grassTime = std::chrono::duration<float>(currentTime - startTime).count();
    float deltaTime = std::chrono::duration<float>(currentTime - lastTime).count();
    lastTime = currentTime;

    // Build per-frame shared state
    FrameData frame = buildFrameData(camera, deltaTime, grassTime);

#ifdef JPH_DEBUG_RENDERER
    currentFrameViewProj = frame.viewProj;
#endif

    // Update subsystems (state mutations)
    profiler.beginCpuZone("SystemUpdates");

    windSystem.update(frame.deltaTime);
    windSystem.updateUniforms(frame.frameIndex);

    grassSystem.updateUniforms(frame.frameIndex, frame.cameraPosition, frame.viewProj,
                               frame.terrainSize, frame.heightScale);
    grassSystem.updateDisplacementSources(frame.playerPosition, frame.playerCapsuleRadius, frame.deltaTime);
    weatherSystem.updateUniforms(frame.frameIndex, frame.cameraPosition, frame.viewProj, frame.deltaTime, frame.time, windSystem);
    terrainSystem.updateUniforms(frame.frameIndex, frame.cameraPosition, frame.view, frame.projection,
                                  volumetricSnowSystem.getCascadeParams(), useVolumetricSnow, MAX_SNOW_HEIGHT);

    // Update snow mask system - accumulation/melting based on weather type
    bool isSnowing = (weatherSystem.getWeatherType() == 1);  // 1 = snow
    float weatherIntensity = weatherSystem.getIntensity();
    // Auto-adjust snow amount based on weather state
    if (isSnowing && weatherIntensity > 0.0f) {
        environmentSettings.snowAmount = glm::min(environmentSettings.snowAmount + environmentSettings.snowAccumulationRate * frame.deltaTime, 1.0f);
    } else if (environmentSettings.snowAmount > 0.0f) {
        environmentSettings.snowAmount = glm::max(environmentSettings.snowAmount - environmentSettings.snowMeltRate * frame.deltaTime, 0.0f);
    }
    snowMaskSystem.setMaskCenter(frame.cameraPosition);
    snowMaskSystem.updateUniforms(frame.frameIndex, frame.deltaTime, isSnowing, weatherIntensity, environmentSettings);

    // Update volumetric snow system
    volumetricSnowSystem.setCameraPosition(frame.cameraPosition);
    volumetricSnowSystem.setWindDirection(glm::vec2(windSystem.getEnvironmentSettings().windDirection.x,
                                                     windSystem.getEnvironmentSettings().windDirection.y));
    volumetricSnowSystem.setWindStrength(windSystem.getEnvironmentSettings().windStrength);
    volumetricSnowSystem.updateUniforms(frame.frameIndex, frame.deltaTime, isSnowing, weatherIntensity, environmentSettings);

    // Add player footprint interaction with snow
    if (environmentSettings.snowAmount > 0.1f) {
        snowMaskSystem.addInteraction(frame.playerPosition, frame.playerCapsuleRadius * 1.5f, 0.3f);
        volumetricSnowSystem.addInteraction(frame.playerPosition, frame.playerCapsuleRadius * 1.5f, 0.3f);
    }

    // Update leaf system with player position and velocity for disruption
    leafSystem.updateUniforms(frame.frameIndex, frame.cameraPosition, frame.viewProj, frame.cameraPosition, frame.playerVelocity, frame.deltaTime, frame.time,
                               frame.terrainSize, frame.heightScale);

    // Update water system uniforms
    waterSystem.updateUniforms(frame.frameIndex);

    profiler.endCpuZone("SystemUpdates");

    // Begin command buffer recording
    vkResetCommandBuffer(commandBuffers[frame.frameIndex], 0);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkBeginCommandBuffer(commandBuffers[frame.frameIndex], &beginInfo);

    VkCommandBuffer cmd = commandBuffers[frame.frameIndex];

    // Begin GPU profiling frame
    profiler.beginFrame(cmd, frame.frameIndex);

    // Terrain compute pass (adaptive subdivision)
    // Detailed per-phase profiling inside recordCompute
    profiler.beginGpuZone(cmd, "TerrainCompute");
    terrainSystem.recordCompute(cmd, frame.frameIndex, &profiler.getGpuProfiler());
    profiler.endGpuZone(cmd, "TerrainCompute");

    // Catmull-Clark subdivision compute pass
    profiler.beginGpuZone(cmd, "SubdivisionCompute");
    catmullClarkSystem.recordCompute(cmd, frame.frameIndex);
    profiler.endGpuZone(cmd, "SubdivisionCompute");

    // Grass displacement update (player/NPC interaction)
    profiler.beginGpuZone(cmd, "GrassCompute");
    grassSystem.recordDisplacementUpdate(cmd, frame.frameIndex);

    // Grass compute pass
    grassSystem.recordResetAndCompute(cmd, frame.frameIndex, frame.time);
    profiler.endGpuZone(cmd, "GrassCompute");

    // Weather particle compute pass
    profiler.beginGpuZone(cmd, "WeatherCompute");
    weatherSystem.recordResetAndCompute(cmd, frame.frameIndex, frame.time, frame.deltaTime);
    profiler.endGpuZone(cmd, "WeatherCompute");

    // Snow mask accumulation compute pass
    profiler.beginGpuZone(cmd, "SnowCompute");
    snowMaskSystem.recordCompute(cmd, frame.frameIndex);

    // Volumetric snow cascade compute pass
    volumetricSnowSystem.recordCompute(cmd, frame.frameIndex);
    profiler.endGpuZone(cmd, "SnowCompute");

    // Leaf particle compute pass
    profiler.beginGpuZone(cmd, "LeafCompute");
    leafSystem.recordResetAndCompute(cmd, frame.frameIndex, frame.time, frame.deltaTime);
    profiler.endGpuZone(cmd, "LeafCompute");

    // Water foam persistence compute pass (Phase 14)
    profiler.beginGpuZone(cmd, "FoamCompute");
    foamBuffer.recordCompute(cmd, frame.frameIndex, frame.deltaTime,
                             flowMapGenerator.getFlowMapView(), flowMapGenerator.getFlowMapSampler());
    profiler.endGpuZone(cmd, "FoamCompute");

    // Cloud shadow map compute pass
    if (cloudShadowSystem.isEnabled()) {
        profiler.beginGpuZone(cmd, "CloudShadow");
        // Wind offset for cloud animation (matching cloud LUT animation)
        glm::vec2 windDir = windSystem.getWindDirection();
        float windSpeed = windSystem.getWindSpeed();
        float windTime = windSystem.getTime();
        float cloudTimeScale = 0.02f;  // Match cloud map LUT speed
        glm::vec3 windOffset = glm::vec3(windDir.x * windSpeed * windTime * cloudTimeScale,
                                          windTime * 0.002f,
                                          windDir.y * windSpeed * windTime * cloudTimeScale);

        cloudShadowSystem.recordUpdate(cmd, frame.frameIndex, frame.sunDirection, frame.sunIntensity,
                                        windOffset, windTime * cloudTimeScale, frame.cameraPosition);
        profiler.endGpuZone(cmd, "CloudShadow");
    }

    // Shadow pass (skip when sun is below horizon)
    if (lastSunIntensity > 0.001f) {
        profiler.beginGpuZone(cmd, "ShadowPass");
        recordShadowPass(cmd, frame.frameIndex, frame.time);
        profiler.endGpuZone(cmd, "ShadowPass");
    }

    // Froxel volumetric fog compute pass
    {
        profiler.beginGpuZone(cmd, "Atmosphere");
        UniformBufferObject* ubo = static_cast<UniformBufferObject*>(uniformBuffersMapped[frame.frameIndex]);
        glm::vec3 sunColor = glm::vec3(ubo->sunColor);

        // Pass cascade matrices for volumetric shadow sampling
        froxelSystem.recordFroxelUpdate(cmd, frame.frameIndex,
                                        frame.view, frame.projection,
                                        frame.cameraPosition,
                                        frame.sunDirection, frame.sunIntensity, sunColor,
                                        shadowSystem.getCascadeMatrices().data(),
                                        ubo->cascadeSplits);

        postProcessSystem.setCameraPlanes(camera.getNearPlane(), camera.getFarPlane());

        // Recompute static LUTs if atmosphere parameters changed (e.g., from UI)
        if (atmosphereLUTSystem.needsRecompute()) {
            atmosphereLUTSystem.recomputeStaticLUTs(cmd);
        }

        // Update sky-view LUT with current sun direction (Phase 4.1.5)
        // This precomputes atmospheric scattering for all view directions
        atmosphereLUTSystem.updateSkyViewLUT(cmd, frame.frameIndex, frame.sunDirection, frame.cameraPosition, 0.0f);

        // Update cloud map LUT with wind animation (Paraboloid projection)
        glm::vec2 windDir = windSystem.getWindDirection();
        float windSpeed = windSystem.getWindSpeed();
        float windTime = windSystem.getTime();
        // Slow down cloud animation for realistic drift (0.02x speed)
        float cloudTimeScale = 0.02f;
        glm::vec3 windOffset = glm::vec3(windDir.x * windSpeed * windTime * cloudTimeScale,
                                          windTime * 0.002f,  // Slow vertical evolution
                                          windDir.y * windSpeed * windTime * cloudTimeScale);
        atmosphereLUTSystem.updateCloudMapLUT(cmd, frame.frameIndex, windOffset, windTime * cloudTimeScale);
        profiler.endGpuZone(cmd, "Atmosphere");
    }

    // Water G-buffer pass (Phase 3) - renders water mesh to mini G-buffer
    // Skip if water was not visible last frame (temporal culling)
    if (waterGBuffer.getPipeline() != VK_NULL_HANDLE &&
        waterTileCull.wasWaterVisibleLastFrame(frame.frameIndex)) {
        profiler.beginGpuZone(cmd, "WaterGBuffer");
        waterGBuffer.beginRenderPass(cmd);

        // Bind G-buffer pipeline and descriptor set
        vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, waterGBuffer.getPipeline());
        VkDescriptorSet gbufferDescSet = waterGBuffer.getDescriptorSet(frame.frameIndex);
        vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
                                waterGBuffer.getPipelineLayout(), 0, 1,
                                &gbufferDescSet, 0, nullptr);

        // Draw water mesh
        waterSystem.recordMeshDraw(cmd);

        waterGBuffer.endRenderPass(cmd);
        profiler.endGpuZone(cmd, "WaterGBuffer");
    }

    // HDR scene render pass
    profiler.beginGpuZone(cmd, "HDRPass");
    recordHDRPass(cmd, frame.frameIndex, frame.time);
    profiler.endGpuZone(cmd, "HDRPass");

    // Screen-Space Reflections compute pass (Phase 10)
    // Computes SSR for next frame's water - uses current scene for temporal stability
    if (ssrSystem.isEnabled()) {
        profiler.beginGpuZone(cmd, "SSR");
        ssrSystem.recordCompute(cmd, frame.frameIndex,
                                postProcessSystem.getHDRColorView(),
                                postProcessSystem.getHDRDepthView(),
                                frame.view, frame.projection,
                                frame.cameraPosition);
        profiler.endGpuZone(cmd, "SSR");
    }

    // Water tile culling compute pass (Phase 7)
    // Determines which screen tiles contain water for optimized rendering
    if (waterTileCull.isEnabled()) {
        profiler.beginGpuZone(cmd, "WaterTileCull");
        glm::mat4 viewProj = frame.projection * frame.view;
        waterTileCull.recordTileCull(cmd, frame.frameIndex,
                                      viewProj, frame.cameraPosition,
                                      waterSystem.getWaterLevel(),
                                      postProcessSystem.getHDRDepthView());
        profiler.endGpuZone(cmd, "WaterTileCull");
    }

    // Generate Hi-Z pyramid from scene depth (before bloom to ensure bloom doesn't affect it)
    profiler.beginGpuZone(cmd, "HiZPyramid");
    hiZSystem.recordPyramidGeneration(cmd, frame.frameIndex);
    profiler.endGpuZone(cmd, "HiZPyramid");

    // Multi-pass bloom
    profiler.beginGpuZone(cmd, "Bloom");
    bloomSystem.setThreshold(postProcessSystem.getBloomThreshold());
    bloomSystem.recordBloomPass(cmd, postProcessSystem.getHDRColorView());
    profiler.endGpuZone(cmd, "Bloom");

    // Post-process pass (with optional GUI overlay callback)
    profiler.beginGpuZone(cmd, "PostProcess");
    postProcessSystem.recordPostProcess(cmd, frame.frameIndex, framebuffers[imageIndex], frame.deltaTime, guiRenderCallback);
    profiler.endGpuZone(cmd, "PostProcess");

    // End GPU profiling frame
    profiler.endFrame(cmd, frame.frameIndex);

    vkEndCommandBuffer(cmd);

    // Queue submission
    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    VkSemaphore waitSemaphores[] = {imageAvailableSemaphores[currentFrame]};
    VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
    submitInfo.waitSemaphoreCount = 1;
    submitInfo.pWaitSemaphores = waitSemaphores;
    submitInfo.pWaitDstStageMask = waitStages;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &cmd;

    VkSemaphore signalSemaphores[] = {renderFinishedSemaphores[currentFrame]};
    submitInfo.signalSemaphoreCount = 1;
    submitInfo.pSignalSemaphores = signalSemaphores;

    vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFences[currentFrame]);

    // Present
    VkPresentInfoKHR presentInfo{};
    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    presentInfo.waitSemaphoreCount = 1;
    presentInfo.pWaitSemaphores = signalSemaphores;

    VkSwapchainKHR swapChains[] = {swapchain};
    presentInfo.swapchainCount = 1;
    presentInfo.pSwapchains = swapChains;
    presentInfo.pImageIndices = &imageIndex;

    result = vkQueuePresentKHR(presentQueue, &presentInfo);

    if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) {
        framebufferResized = true;
    } else if (result != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to present swapchain image");
    }

    // Advance grass double-buffer sets after frame submission
    // This swaps compute/render buffer sets so next frame can overlap:
    // - Next frame's compute writes to what was the render set
    // - Next frame's render reads from what was the compute set (now contains fresh data)
    grassSystem.advanceBufferSet();
    weatherSystem.advanceBufferSet();
    leafSystem.advanceBufferSet();

    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}

void Renderer::waitIdle() {
    vulkanContext.waitIdle();
}

void Renderer::waitForPreviousFrame() {
    // Wait for the previous frame's fence to ensure GPU is done with resources
    // we might be about to destroy/update.
    //
    // With double-buffering (MAX_FRAMES_IN_FLIGHT=2):
    // - Frame N uses fence[N % 2]
    // - Before updating meshes for frame N, we need frame N-1's GPU work complete
    // - Previous frame's fence is fence[(N-1) % 2] = fence[(currentFrame + 1) % 2]
    //
    // This prevents race conditions where we destroy mesh buffers while the GPU
    // is still reading them from the previous frame's commands.
    uint32_t previousFrame = (currentFrame + MAX_FRAMES_IN_FLIGHT - 1) % MAX_FRAMES_IN_FLIGHT;
    vkWaitForFences(vulkanContext.getDevice(), 1, &inFlightFences[previousFrame], VK_TRUE, UINT64_MAX);
}

void Renderer::destroyDepthImageAndView() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();

    if (depthImageView != VK_NULL_HANDLE) {
        vkDestroyImageView(device, depthImageView, nullptr);
        depthImageView = VK_NULL_HANDLE;
    }
    if (depthImage != VK_NULL_HANDLE) {
        vmaDestroyImage(allocator, depthImage, depthImageAllocation);
        depthImage = VK_NULL_HANDLE;
        depthImageAllocation = VK_NULL_HANDLE;
    }
}

void Renderer::destroyFramebuffers() {
    VkDevice device = vulkanContext.getDevice();
    for (auto framebuffer : framebuffers) {
        vkDestroyFramebuffer(device, framebuffer, nullptr);
    }
    framebuffers.clear();
}

bool Renderer::handleResize() {
    VkDevice device = vulkanContext.getDevice();
    VmaAllocator allocator = vulkanContext.getAllocator();

    // Wait for GPU to finish all work
    vkDeviceWaitIdle(device);

    // Recreate swapchain
    if (!vulkanContext.recreateSwapchain()) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to recreate swapchain");
        return false;
    }

    VkExtent2D newExtent = vulkanContext.getSwapchainExtent();

    // Handle minimized window (extent = 0)
    if (newExtent.width == 0 || newExtent.height == 0) {
        return true;  // Don't recreate resources for minimized window
    }

    SDL_Log("Window resized to %ux%u", newExtent.width, newExtent.height);

    // Destroy and recreate depth resources (keep sampler)
    destroyDepthImageAndView();

    // Recreate depth image and view (reusing existing depthFormat and depthSampler)
    VkImageCreateInfo imageInfo{};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.width = newExtent.width;
    imageInfo.extent.height = newExtent.height;
    imageInfo.extent.depth = 1;
    imageInfo.mipLevels = 1;
    imageInfo.arrayLayers = 1;
    imageInfo.format = depthFormat;
    imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    imageInfo.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    VmaAllocationCreateInfo allocInfo{};
    allocInfo.usage = VMA_MEMORY_USAGE_AUTO;

    if (vmaCreateImage(allocator, &imageInfo, &allocInfo, &depthImage, &depthImageAllocation, nullptr) != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create depth image during resize");
        return false;
    }

    VkImageViewCreateInfo viewInfo{};
    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    viewInfo.image = depthImage;
    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    viewInfo.format = depthFormat;
    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
    viewInfo.subresourceRange.baseMipLevel = 0;
    viewInfo.subresourceRange.levelCount = 1;
    viewInfo.subresourceRange.baseArrayLayer = 0;
    viewInfo.subresourceRange.layerCount = 1;

    if (vkCreateImageView(device, &viewInfo, nullptr, &depthImageView) != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create depth image view during resize");
        return false;
    }

    // Destroy and recreate framebuffers
    destroyFramebuffers();
    if (!createFramebuffers()) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to recreate framebuffers during resize");
        return false;
    }

    // Resize post-process system (HDR render target)
    postProcessSystem.resize(device, allocator, newExtent);

    // Resize bloom system
    bloomSystem.resize(device, allocator, newExtent);

    // Rebind bloom texture to post-process system (bloom image views changed)
    postProcessSystem.setBloomTexture(bloomSystem.getBloomOutput(), bloomSystem.getBloomSampler());

    // Resize froxel system (volumetric fog)
    froxelSystem.resize(device, allocator, newExtent);

    // Resize Hi-Z system (occlusion culling)
    hiZSystem.resize(newExtent);

    // Resize SSR system (screen-space reflections)
    ssrSystem.resize(newExtent);

    // Resize water tile cull system
    waterTileCull.resize(newExtent);

    // Resize water G-buffer
    waterGBuffer.resize(newExtent);

    // Update extent on all rendering subsystems for viewport/scissor
    terrainSystem.setExtent(newExtent);
    skySystem.setExtent(newExtent);
    waterSystem.setExtent(newExtent);
    grassSystem.setExtent(newExtent);
    weatherSystem.setExtent(newExtent);
    leafSystem.setExtent(newExtent);
    catmullClarkSystem.setExtent(newExtent);

    framebufferResized = false;
    return true;
}

// Pure calculation helpers - no state mutation

Renderer::LightingParams Renderer::calculateLightingParams(float timeOfDay) const {
    LightingParams params{};

    DateTime dateTime = DateTime::fromTimeOfDay(timeOfDay, currentYear, currentMonth, currentDay);
    CelestialPosition sunPos = celestialCalculator.calculateSunPosition(dateTime);
    MoonPosition moonPos = celestialCalculator.calculateMoonPosition(dateTime);

    params.sunDir = sunPos.direction;
    params.moonDir = moonPos.direction;
    params.sunIntensity = sunPos.intensity;
    params.moonIntensity = moonPos.intensity;

    // Smooth transition for moon as light source during twilight
    if (moonPos.altitude > -5.0f) {
        float twilightFactor = glm::smoothstep(10.0f, -6.0f, sunPos.altitude);
        params.moonIntensity *= (1.0f + twilightFactor * 1.0f);
    }

    // Apply user-controlled moon brightness multiplier
    params.moonIntensity *= moonBrightness;

    params.sunColor = celestialCalculator.getSunColor(sunPos.altitude);
    params.moonColor = celestialCalculator.getMoonColor(moonPos.altitude, moonPos.illumination);
    params.ambientColor = celestialCalculator.getAmbientColor(sunPos.altitude);

    // Apply moon phase override if enabled, otherwise use astronomical calculation
    if (useMoonPhaseOverride) {
        params.moonPhase = manualMoonPhase;
        // Recalculate illumination based on manual phase
        float phaseAngle = params.moonPhase * 2.0f * glm::pi<float>();
        float illumination = (1.0f - std::cos(phaseAngle)) * 0.5f;
        // Adjust moon color based on manual phase illumination
        params.moonColor = celestialCalculator.getMoonColor(moonPos.altitude, illumination);
    } else {
        params.moonPhase = moonPos.phase;
    }
    currentMoonPhase = params.moonPhase;  // Track current effective phase

    // Eclipse simulation - affects sun intensity
    params.eclipseAmount = eclipseEnabled ? eclipseAmount : 0.0f;

    params.julianDay = dateTime.toJulianDay();

    return params;
}

UniformBufferObject Renderer::buildUniformBufferData(const Camera& camera, const LightingParams& lighting, float timeOfDay) const {
    UniformBufferObject ubo{};
    ubo.model = glm::mat4(1.0f);
    ubo.view = camera.getViewMatrix();
    ubo.proj = camera.getProjectionMatrix();

    // Copy cascade matrices from shadow system
    const auto& cascadeMatrices = shadowSystem.getCascadeMatrices();
    for (uint32_t i = 0; i < NUM_SHADOW_CASCADES; i++) {
        ubo.cascadeViewProj[i] = cascadeMatrices[i];
    }

    // Store view-space split depths from shadow system
    const auto& cascadeSplitDepths = shadowSystem.getCascadeSplitDepths();
    ubo.cascadeSplits = glm::vec4(
        cascadeSplitDepths[1],
        cascadeSplitDepths[2],
        cascadeSplitDepths[3],
        cascadeSplitDepths[4]
    );

    ubo.sunDirection = glm::vec4(lighting.sunDir, lighting.sunIntensity);
    ubo.moonDirection = glm::vec4(lighting.moonDir, lighting.moonIntensity);
    ubo.sunColor = glm::vec4(lighting.sunColor, 1.0f);
    ubo.moonColor = glm::vec4(lighting.moonColor, lighting.moonPhase);  // Pass moon phase in alpha channel
    ubo.ambientColor = glm::vec4(lighting.ambientColor, 1.0f);
    ubo.cameraPosition = glm::vec4(camera.getPosition(), 1.0f);

    // Point light from the glowing sphere (position updated by physics)
    float pointLightIntensity = 5.0f;
    float pointLightRadius = 8.0f;
    ubo.pointLightPosition = glm::vec4(sceneManager.getOrbLightPosition(), pointLightIntensity);
    ubo.pointLightColor = glm::vec4(1.0f, 0.9f, 0.7f, pointLightRadius);

    // Wind parameters for cloud animation
    glm::vec2 windDir = windSystem.getWindDirection();
    float windSpeed = windSystem.getWindSpeed();
    float windTime = windSystem.getTime();
    ubo.windDirectionAndSpeed = glm::vec4(windDir.x, windDir.y, windSpeed, windTime);

    ubo.timeOfDay = timeOfDay;
    ubo.shadowMapSize = static_cast<float>(shadowSystem.getShadowMapSize());
    ubo.debugCascades = showCascadeDebug ? 1.0f : 0.0f;
    ubo.julianDay = static_cast<float>(lighting.julianDay);
    ubo.cloudStyle = useParaboloidClouds ? 1.0f : 0.0f;
    ubo.cameraNear = camera.getNearPlane();
    ubo.cameraFar = camera.getFarPlane();
    ubo.eclipseAmount = lighting.eclipseAmount;

    // Copy atmosphere parameters from AtmosphereLUTSystem for use in atmosphere_common.glsl
    const auto& atmosParams = atmosphereLUTSystem.getAtmosphereParams();
    ubo.atmosRayleighScattering = glm::vec4(atmosParams.rayleighScatteringBase, atmosParams.rayleighScaleHeight);
    ubo.atmosMieParams = glm::vec4(atmosParams.mieScatteringBase, atmosParams.mieAbsorptionBase,
                                   atmosParams.mieScaleHeight, atmosParams.mieAnisotropy);
    ubo.atmosOzoneAbsorption = glm::vec4(atmosParams.ozoneAbsorption, atmosParams.ozoneLayerCenter);
    ubo.atmosOzoneWidth = atmosParams.ozoneLayerWidth;

    // Copy height fog parameters from FroxelSystem for use in atmosphere_common.glsl
    ubo.heightFogParams = glm::vec4(froxelSystem.getFogBaseHeight(),
                                     froxelSystem.getFogScaleHeight(),
                                     froxelSystem.getFogDensity(),
                                     0.0f);
    ubo.heightFogLayerParams = glm::vec4(froxelSystem.getLayerThickness(),
                                          froxelSystem.getLayerDensity(),
                                          0.0f, 0.0f);

    // Cloud parameters for sky.frag and cloud systems
    ubo.cloudCoverage = cloudCoverage;
    ubo.cloudDensity = cloudDensity;

    // Moon rendering parameters for sky.frag
    ubo.moonBrightness = moonBrightness;
    ubo.moonDiscIntensity = moonDiscIntensity;
    ubo.moonEarthshine = moonEarthshine;
    ubo.moonPad = 0.0f;

    return ubo;
}

SnowUBO Renderer::buildSnowUBOData() const {
    SnowUBO snow{};

    snow.snowAmount = environmentSettings.snowAmount;
    snow.snowRoughness = environmentSettings.snowRoughness;
    snow.snowTexScale = environmentSettings.snowTexScale;
    snow.useVolumetricSnow = useVolumetricSnow ? 1.0f : 0.0f;
    snow.snowColor = glm::vec4(environmentSettings.snowColor, 1.0f);
    snow.snowMaskParams = glm::vec4(snowMaskSystem.getMaskOrigin(), snowMaskSystem.getMaskSize(), 0.0f);

    // Volumetric snow cascade parameters
    auto cascadeParams = volumetricSnowSystem.getCascadeParams();
    snow.snowCascade0Params = cascadeParams[0];
    snow.snowCascade1Params = cascadeParams[1];
    snow.snowCascade2Params = cascadeParams[2];
    snow.snowMaxHeight = MAX_SNOW_HEIGHT;
    snow.debugSnowDepth = showSnowDepthDebug ? 1.0f : 0.0f;
    snow.snowPadding = glm::vec2(0.0f);

    return snow;
}

CloudShadowUBO Renderer::buildCloudShadowUBOData() const {
    CloudShadowUBO cloudShadowUbo{};

    cloudShadowUbo.cloudShadowMatrix = cloudShadowSystem.getWorldToShadowUV();
    cloudShadowUbo.cloudShadowIntensity = cloudShadowSystem.getShadowIntensity();
    cloudShadowUbo.cloudShadowEnabled = cloudShadowSystem.isEnabled() ? 1.0f : 0.0f;
    cloudShadowUbo.cloudShadowPadding = glm::vec2(0.0f);

    return cloudShadowUbo;
}

glm::vec2 Renderer::calculateSunScreenPos(const Camera& camera, const glm::vec3& sunDir) const {
    glm::vec3 sunWorldPos = camera.getPosition() + sunDir * 1000.0f;
    glm::vec4 sunClipPos = camera.getProjectionMatrix() * camera.getViewMatrix() * glm::vec4(sunWorldPos, 1.0f);

    glm::vec2 sunScreenPos(0.5f, 0.5f);
    if (sunClipPos.w > 0.0f) {
        glm::vec3 sunNDC = glm::vec3(sunClipPos) / sunClipPos.w;
        sunScreenPos = glm::vec2(sunNDC.x * 0.5f + 0.5f, sunNDC.y * 0.5f + 0.5f);
        sunScreenPos.y = 1.0f - sunScreenPos.y;
    }
    return sunScreenPos;
}

FrameData Renderer::buildFrameData(const Camera& camera, float deltaTime, float time) const {
    FrameData frame;

    frame.frameIndex = currentFrame;
    frame.deltaTime = deltaTime;
    frame.time = time;
    frame.timeOfDay = currentTimeOfDay;

    frame.cameraPosition = camera.getPosition();
    frame.view = camera.getViewMatrix();
    frame.projection = camera.getProjectionMatrix();
    frame.viewProj = frame.projection * frame.view;

    // Get sun direction from last computed UBO (already computed in updateUniformBuffer)
    UniformBufferObject* ubo = static_cast<UniformBufferObject*>(uniformBuffersMapped[currentFrame]);
    frame.sunDirection = glm::normalize(glm::vec3(ubo->sunDirection));
    frame.sunIntensity = ubo->sunDirection.w;

    frame.playerPosition = playerPosition;
    frame.playerVelocity = playerVelocity;
    frame.playerCapsuleRadius = playerCapsuleRadius;

    const auto& terrainConfig = terrainSystem.getConfig();
    frame.terrainSize = terrainConfig.size;
    frame.heightScale = terrainConfig.heightScale;

    // Populate wind/weather/snow data
    const auto& envSettings = windSystem.getEnvironmentSettings();
    frame.windDirection = envSettings.windDirection;
    frame.windStrength = envSettings.windStrength;
    frame.windSpeed = envSettings.windSpeed;
    frame.gustFrequency = envSettings.gustFrequency;
    frame.gustAmplitude = envSettings.gustAmplitude;

    frame.weatherType = weatherSystem.getWeatherType();
    frame.weatherIntensity = weatherSystem.getIntensity();

    frame.snowAmount = environmentSettings.snowAmount;
    frame.snowColor = environmentSettings.snowColor;

    // Lighting data
    frame.sunColor = glm::vec3(ubo->sunColor);
    frame.moonDirection = glm::normalize(glm::vec3(ubo->moonDirection));
    frame.moonIntensity = ubo->moonDirection.w;

    return frame;
}

RenderResources Renderer::buildRenderResources(uint32_t swapchainImageIndex) const {
    RenderResources resources;

    // HDR target (from PostProcessSystem)
    resources.hdrRenderPass = postProcessSystem.getHDRRenderPass();
    resources.hdrFramebuffer = postProcessSystem.getHDRFramebuffer();
    resources.hdrExtent = postProcessSystem.getExtent();
    resources.hdrColorView = postProcessSystem.getHDRColorView();
    resources.hdrDepthView = postProcessSystem.getHDRDepthView();

    // Shadow resources (from ShadowSystem)
    resources.shadowRenderPass = shadowSystem.getShadowRenderPass();
    resources.shadowMapView = shadowSystem.getShadowImageView();
    resources.shadowSampler = shadowSystem.getShadowSampler();
    resources.shadowPipeline = shadowSystem.getShadowPipeline();
    resources.shadowPipelineLayout = shadowSystem.getShadowPipelineLayout();

    // Copy cascade matrices
    const auto& cascadeMatrices = shadowSystem.getCascadeMatrices();
    for (size_t i = 0; i < cascadeMatrices.size(); ++i) {
        resources.cascadeMatrices[i] = cascadeMatrices[i];
    }

    // Copy cascade split depths
    const auto& splitDepths = shadowSystem.getCascadeSplitDepths();
    for (size_t i = 0; i < std::min(splitDepths.size(), size_t(4)); ++i) {
        resources.cascadeSplitDepths[i] = splitDepths[i];
    }

    // Bloom output (from BloomSystem)
    resources.bloomOutput = bloomSystem.getBloomOutput();
    resources.bloomSampler = bloomSystem.getBloomSampler();

    // Swapchain target
    resources.swapchainRenderPass = renderPass;
    resources.swapchainFramebuffer = framebuffers[swapchainImageIndex];
    resources.swapchainExtent = {vulkanContext.getWidth(), vulkanContext.getHeight()};

    // Main scene pipeline
    resources.graphicsPipeline = graphicsPipeline;
    resources.pipelineLayout = pipelineLayout;
    resources.descriptorSetLayout = descriptorSetLayout;

    return resources;
}

// Render pass recording helpers - pure command recording, no state mutation

void Renderer::recordShadowPass(VkCommandBuffer cmd, uint32_t frameIndex, float grassTime) {
    // Delegate to the shadow system with callbacks for terrain and grass
    auto terrainCallback = [this, frameIndex](VkCommandBuffer cb, uint32_t cascade, const glm::mat4& lightMatrix) {
        terrainSystem.recordShadowDraw(cb, frameIndex, lightMatrix, static_cast<int>(cascade));
    };

    auto grassCallback = [this, frameIndex, grassTime](VkCommandBuffer cb, uint32_t cascade, const glm::mat4& lightMatrix) {
        (void)lightMatrix;  // Grass uses cascade index only
        grassSystem.recordShadowDraw(cb, frameIndex, grassTime, cascade);
    };

    // Combine scene objects and rock objects for shadow rendering
    // Skip player character - it's rendered separately with skinned shadow pipeline
    std::vector<Renderable> allObjects;
    const auto& sceneObjects = sceneManager.getRenderables();
    size_t playerIndex = sceneManager.getSceneBuilder().getPlayerObjectIndex();
    bool hasCharacter = sceneManager.getSceneBuilder().hasCharacter();

    allObjects.reserve(sceneObjects.size() + rockSystem.getSceneObjects().size());
    for (size_t i = 0; i < sceneObjects.size(); ++i) {
        // Skip player character - rendered with skinned shadow pipeline
        if (hasCharacter && i == playerIndex) {
            continue;
        }
        allObjects.push_back(sceneObjects[i]);
    }
    allObjects.insert(allObjects.end(), rockSystem.getSceneObjects().begin(), rockSystem.getSceneObjects().end());

    // Skinned character shadow callback (renders with GPU skinning)
    ShadowSystem::DrawCallback skinnedCallback = nullptr;
    if (hasCharacter) {
        skinnedCallback = [this, frameIndex, playerIndex](VkCommandBuffer cb, uint32_t cascade, const glm::mat4& lightMatrix) {
            (void)lightMatrix;  // Not used, cascade matrices are in UBO
            SceneBuilder& sceneBuilder = sceneManager.getSceneBuilder();
            const auto& sceneObjs = sceneBuilder.getRenderables();
            if (playerIndex >= sceneObjs.size()) return;

            const Renderable& playerObj = sceneObjs[playerIndex];
            AnimatedCharacter& character = sceneBuilder.getAnimatedCharacter();
            SkinnedMesh& skinnedMesh = character.getSkinnedMesh();

            // Bind skinned shadow pipeline with descriptor set that has bone matrices
            shadowSystem.bindSkinnedShadowPipeline(cb, skinnedDescriptorSets[frameIndex]);

            // Record the skinned mesh shadow
            shadowSystem.recordSkinnedMeshShadow(cb, cascade, playerObj.transform, skinnedMesh);
        };
    }

    // Use any MaterialRegistry descriptor set for shadow pass (only needs common bindings/UBO)
    // MaterialId 0 is the first registered material (crate)
    const auto& materialRegistry = sceneManager.getSceneBuilder().getMaterialRegistry();
    VkDescriptorSet shadowDescriptorSet = materialRegistry.getDescriptorSet(0, frameIndex);
    shadowSystem.recordShadowPass(cmd, frameIndex, shadowDescriptorSet,
                                   allObjects,
                                   terrainCallback, grassCallback, skinnedCallback);
}

void Renderer::recordSceneObjects(VkCommandBuffer cmd, uint32_t frameIndex) {
    // Get MaterialRegistry for descriptor set lookup
    const auto& materialRegistry = sceneManager.getSceneBuilder().getMaterialRegistry();

    // Helper lambda to render a scene object with a descriptor set
    auto renderObject = [&](const Renderable& obj, VkDescriptorSet descSet) {
        PushConstants push{};
        push.model = obj.transform;
        push.roughness = obj.roughness;
        push.metallic = obj.metallic;
        push.emissiveIntensity = obj.emissiveIntensity;
        push.opacity = obj.opacity;
        push.emissiveColor = glm::vec4(obj.emissiveColor, 1.0f);
        push.pbrFlags = obj.pbrFlags;

        vkCmdPushConstants(cmd, pipelineLayout,
                          VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,
                          0, sizeof(PushConstants), &push);

        vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
                                pipelineLayout, 0, 1, &descSet, 0, nullptr);

        VkBuffer vertexBuffers[] = {obj.mesh->getVertexBuffer()};
        VkDeviceSize offsets[] = {0};
        vkCmdBindVertexBuffers(cmd, 0, 1, vertexBuffers, offsets);
        vkCmdBindIndexBuffer(cmd, obj.mesh->getIndexBuffer(), 0, VK_INDEX_TYPE_UINT32);

        vkCmdDrawIndexed(cmd, obj.mesh->getIndexCount(), 1, 0, 0, 0);
    };

    // Render scene manager objects using MaterialRegistry for descriptor set lookup
    const auto& sceneObjects = sceneManager.getRenderables();
    size_t playerIndex = sceneManager.getSceneBuilder().getPlayerObjectIndex();
    bool hasCharacter = sceneManager.getSceneBuilder().hasCharacter();

    for (size_t i = 0; i < sceneObjects.size(); ++i) {
        // Skip player character (rendered separately with GPU skinning)
        if (hasCharacter && i == playerIndex) {
            continue;
        }

        const auto& obj = sceneObjects[i];

        // Use MaterialRegistry to get descriptor set by materialId
        // This replaces the brittle texture pointer comparison
        VkDescriptorSet descSet = materialRegistry.getDescriptorSet(obj.materialId, frameIndex);
        if (descSet == VK_NULL_HANDLE) {
            // Fallback: skip objects with invalid materialId
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,
                "Skipping object with invalid materialId %u", obj.materialId);
            continue;
        }
        renderObject(obj, descSet);
    }

    // Render procedural rocks (RockSystem uses its own descriptor sets)
    VkDescriptorSet rockDescSet = rockDescriptorSets[frameIndex];
    for (const auto& rock : rockSystem.getSceneObjects()) {
        renderObject(rock, rockDescSet);
    }
}

void Renderer::recordHDRPass(VkCommandBuffer cmd, uint32_t frameIndex, float grassTime) {
    VkRenderPassBeginInfo hdrPassInfo{};
    hdrPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    hdrPassInfo.renderPass = postProcessSystem.getHDRRenderPass();
    hdrPassInfo.framebuffer = postProcessSystem.getHDRFramebuffer();
    hdrPassInfo.renderArea.offset = {0, 0};
    hdrPassInfo.renderArea.extent = postProcessSystem.getExtent();

    std::array<VkClearValue, 2> clearValues{};
    clearValues[0].color = {{0.0f, 0.0f, 0.0f, 1.0f}};
    clearValues[1].depthStencil = {1.0f, 0};

    hdrPassInfo.clearValueCount = static_cast<uint32_t>(clearValues.size());
    hdrPassInfo.pClearValues = clearValues.data();

    vkCmdBeginRenderPass(cmd, &hdrPassInfo, VK_SUBPASS_CONTENTS_INLINE);

    // Draw sky (with atmosphere LUT bindings)
    skySystem.recordDraw(cmd, frameIndex);

    // Draw terrain (LEB adaptive tessellation)
    terrainSystem.recordDraw(cmd, frameIndex);

    // Draw Catmull-Clark subdivision surfaces
    catmullClarkSystem.recordDraw(cmd, frameIndex);

    // Draw scene objects (static meshes)
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
    recordSceneObjects(cmd, frameIndex);

    // Draw skinned character with GPU skinning
    recordSkinnedCharacter(cmd, frameIndex);

    // Draw tree editor (when enabled)
    treeEditSystem.recordDraw(cmd, frameIndex);

    // Draw grass
    grassSystem.recordDraw(cmd, frameIndex, grassTime);

    // Draw water surface (after opaque geometry, blended)
    // Use temporal tile culling: skip if no tiles were visible last frame
    if (waterTileCull.wasWaterVisibleLastFrame(frameIndex)) {
        waterSystem.recordDraw(cmd, frameIndex);
    }

    // Draw falling leaves - after grass, before weather
    leafSystem.recordDraw(cmd, frameIndex, grassTime);

    // Draw weather particles (rain/snow) - after opaque geometry
    weatherSystem.recordDraw(cmd, frameIndex, grassTime);

#ifdef JPH_DEBUG_RENDERER
    // Draw physics debug visualization (wireframe collision shapes)
    if (physicsDebugCallback) {
        physicsDebugCallback(cmd, currentFrameViewProj, postProcessSystem.getExtent());
    }
#endif

    vkCmdEndRenderPass(cmd);
}

// ===== GPU Skinning Implementation =====

bool Renderer::createSkinnedDescriptorSetLayout() {
    VkDevice device = vulkanContext.getDevice();

    // Skinned descriptor set layout:
    // Same as main layout but with additional binding 12 for bone matrices UBO
    DescriptorManager::LayoutBuilder builder(device);
    addCommonDescriptorBindings(builder);
    // Add skinned-specific binding
    builder.addBinding(Bindings::BONE_MATRICES, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_VERTEX_BIT);  // 12: bone matrices
    skinnedDescriptorSetLayout = builder.build();

    if (skinnedDescriptorSetLayout == VK_NULL_HANDLE) {
        SDL_Log("Failed to create skinned descriptor set layout");
        return false;
    }

    return true;
}

bool Renderer::createSkinnedGraphicsPipeline() {
    VkDevice device = vulkanContext.getDevice();
    VkExtent2D swapchainExtent = vulkanContext.getSwapchainExtent();

    // Create pipeline layout (still needed - factory expects it to be provided)
    VkPushConstantRange pushConstantRange{};
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange.offset = 0;
    pushConstantRange.size = sizeof(PushConstants);

    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &skinnedDescriptorSetLayout;
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;

    if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &skinnedPipelineLayout) != VK_SUCCESS) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create skinned pipeline layout");
        return false;
    }

    // Use factory for pipeline creation with SkinnedVertex input
    auto bindingDescription = SkinnedVertex::getBindingDescription();
    auto attributeDescriptions = SkinnedVertex::getAttributeDescriptions();

    GraphicsPipelineFactory factory(device);
    bool success = factory
        .applyPreset(GraphicsPipelineFactory::Preset::Default)
        .setShaders(resourcePath + "/shaders/skinned.vert.spv",
                    resourcePath + "/shaders/shader.frag.spv")
        .setVertexInput({bindingDescription},
                        {attributeDescriptions.begin(), attributeDescriptions.end()})
        .setRenderPass(postProcessSystem.getHDRRenderPass())
        .setPipelineLayout(skinnedPipelineLayout)
        .setExtent(swapchainExtent)
        .setBlendMode(GraphicsPipelineFactory::BlendMode::Alpha)
        .build(skinnedGraphicsPipeline);

    if (!success) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to create skinned graphics pipeline");
        return false;
    }

    SDL_Log("Created skinned graphics pipeline for GPU skinning");
    return true;
}

bool Renderer::createBoneMatricesBuffers() {
    VmaAllocator allocator = vulkanContext.getAllocator();
    VkDeviceSize bufferSize = sizeof(BoneMatricesUBO);

    boneMatricesBuffers.resize(MAX_FRAMES_IN_FLIGHT);
    boneMatricesAllocations.resize(MAX_FRAMES_IN_FLIGHT);
    boneMatricesMapped.resize(MAX_FRAMES_IN_FLIGHT);

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        VkBufferCreateInfo bufferInfo{};
        bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = bufferSize;
        bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
        bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

        VmaAllocationCreateInfo allocInfo{};
        allocInfo.usage = VMA_MEMORY_USAGE_AUTO;
        allocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_MAPPED_BIT;

        VmaAllocationInfo allocationInfo;
        if (vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &boneMatricesBuffers[i],
                            &boneMatricesAllocations[i], &allocationInfo) != VK_SUCCESS) {
            SDL_Log("Failed to create bone matrices buffer");
            return false;
        }

        boneMatricesMapped[i] = allocationInfo.pMappedData;

        // Initialize with identity matrices
        BoneMatricesUBO* ubo = static_cast<BoneMatricesUBO*>(boneMatricesMapped[i]);
        for (uint32_t j = 0; j < MAX_BONES; j++) {
            ubo->bones[j] = glm::mat4(1.0f);
        }
    }

    SDL_Log("Created bone matrices buffers for GPU skinning");
    return true;
}

bool Renderer::createSkinnedDescriptorSets() {
    VkDevice device = vulkanContext.getDevice();

    // Allocate skinned descriptor sets using the pool manager
    skinnedDescriptorSets = descriptorManagerPool->allocate(skinnedDescriptorSetLayout, MAX_FRAMES_IN_FLIGHT);
    if (skinnedDescriptorSets.empty()) {
        SDL_Log("Failed to allocate skinned descriptor sets");
        return false;
    }

    // Use factory to write skinned descriptor sets
    MaterialDescriptorFactory factory(device);
    const auto& whiteTexture = sceneManager.getSceneBuilder().getWhiteTexture();
    const auto& emissiveMap = sceneManager.getSceneBuilder().getDefaultEmissiveMap();

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        MaterialDescriptorFactory::CommonBindings common{};
        common.uniformBuffer = uniformBuffers[i];
        common.uniformBufferSize = sizeof(UniformBufferObject);
        common.shadowMapView = shadowSystem.getShadowImageView();
        common.shadowMapSampler = shadowSystem.getShadowSampler();
        common.lightBuffer = lightBuffers[i];
        common.lightBufferSize = sizeof(LightBuffer);
        common.emissiveMapView = emissiveMap.getImageView();
        common.emissiveMapSampler = emissiveMap.getSampler();
        // Point/spot shadow maps need proper array/cube textures, not 2D emissive
        common.pointShadowView = shadowSystem.getPointShadowArrayView(i);
        common.pointShadowSampler = shadowSystem.getPointShadowSampler();
        common.spotShadowView = shadowSystem.getSpotShadowArrayView(i);
        common.spotShadowSampler = shadowSystem.getSpotShadowSampler();
        common.snowMaskView = snowMaskSystem.getSnowMaskView();
        common.snowMaskSampler = snowMaskSystem.getSnowMaskSampler();
        // Cloud shadow system may not be initialized yet - use white texture as fallback
        // The binding will be updated later in init() after cloudShadowSystem.init()
        common.cloudShadowView = whiteTexture.getImageView();
        common.cloudShadowSampler = whiteTexture.getSampler();
        // Snow and cloud shadow UBOs (bindings 10 and 11)
        common.snowUboBuffer = snowBuffers[i];
        common.snowUboBufferSize = sizeof(SnowUBO);
        common.cloudShadowUboBuffer = cloudShadowBuffers[i];
        common.cloudShadowUboBufferSize = sizeof(CloudShadowUBO);
        // Bone matrices (binding 12)
        common.boneMatricesBuffer = boneMatricesBuffers[i];
        common.boneMatricesBufferSize = sizeof(BoneMatricesUBO);
        // Placeholder texture for unused PBR bindings (13-16)
        common.placeholderTextureView = whiteTexture.getImageView();
        common.placeholderTextureSampler = whiteTexture.getSampler();

        MaterialDescriptorFactory::MaterialTextures mat{};
        mat.diffuseView = whiteTexture.getImageView();
        mat.diffuseSampler = whiteTexture.getSampler();
        mat.normalView = whiteTexture.getImageView();
        mat.normalSampler = whiteTexture.getSampler();
        factory.writeSkinnedDescriptorSet(skinnedDescriptorSets[i], common, mat);
    }

    SDL_Log("Created skinned descriptor sets for GPU skinning");
    return true;
}

void Renderer::updateBoneMatrices(uint32_t currentImage) {
    BoneMatricesUBO* ubo = static_cast<BoneMatricesUBO*>(boneMatricesMapped[currentImage]);

    SceneBuilder& sceneBuilder = sceneManager.getSceneBuilder();
    if (!sceneBuilder.hasCharacter()) {
        // Ensure identity matrices when no character to prevent garbage data
        for (uint32_t i = 0; i < MAX_BONES; i++) {
            ubo->bones[i] = glm::mat4(1.0f);
        }
        return;
    }

    // Get bone matrices from animated character
    std::vector<glm::mat4> boneMatrices;
    sceneBuilder.getAnimatedCharacter().computeBoneMatrices(boneMatrices);

    // Copy to mapped buffer
    size_t numBones = std::min(boneMatrices.size(), static_cast<size_t>(MAX_BONES));
    for (size_t i = 0; i < numBones; i++) {
        ubo->bones[i] = boneMatrices[i];
    }
    // Fill remaining slots with identity to prevent garbage data in unused bones
    for (size_t i = numBones; i < MAX_BONES; i++) {
        ubo->bones[i] = glm::mat4(1.0f);
    }
}

void Renderer::recordSkinnedCharacter(VkCommandBuffer cmd, uint32_t frameIndex) {
    SceneBuilder& sceneBuilder = sceneManager.getSceneBuilder();
    if (!sceneBuilder.hasCharacter()) return;

    // Bind skinned pipeline
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, skinnedGraphicsPipeline);

    // Bind skinned descriptor set
    vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
                            skinnedPipelineLayout, 0, 1, &skinnedDescriptorSets[frameIndex], 0, nullptr);

    // Get the player object to get transform
    const auto& sceneObjects = sceneBuilder.getRenderables();
    size_t playerIndex = sceneBuilder.getPlayerObjectIndex();
    if (playerIndex >= sceneObjects.size()) return;

    const Renderable& playerObj = sceneObjects[playerIndex];

    // Push constants
    PushConstants push{};
    push.model = playerObj.transform;
    push.roughness = playerObj.roughness;
    push.metallic = playerObj.metallic;
    push.emissiveIntensity = playerObj.emissiveIntensity;
    push.opacity = playerObj.opacity;
    push.emissiveColor = glm::vec4(playerObj.emissiveColor, 1.0f);
    push.pbrFlags = playerObj.pbrFlags;

    vkCmdPushConstants(cmd, skinnedPipelineLayout,
                       VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,
                       0, sizeof(PushConstants), &push);

    // Bind skinned mesh vertex and index buffers
    AnimatedCharacter& character = sceneBuilder.getAnimatedCharacter();
    SkinnedMesh& skinnedMesh = character.getSkinnedMesh();

    VkBuffer vertexBuffers[] = {skinnedMesh.getVertexBuffer()};
    VkDeviceSize offsets[] = {0};
    vkCmdBindVertexBuffers(cmd, 0, 1, vertexBuffers, offsets);
    vkCmdBindIndexBuffer(cmd, skinnedMesh.getIndexBuffer(), 0, VK_INDEX_TYPE_UINT32);

    vkCmdDrawIndexed(cmd, skinnedMesh.getIndexCount(), 1, 0, 0, 0);
}

void Renderer::updateHiZObjectData() {
    std::vector<CullObjectData> cullObjects;

    // Gather scene objects for culling
    const auto& sceneObjects = sceneManager.getRenderables();
    for (size_t i = 0; i < sceneObjects.size(); ++i) {
        const auto& obj = sceneObjects[i];
        if (obj.mesh == nullptr) continue;

        // Get local AABB and transform to world space
        const AABB& localBounds = obj.mesh->getBounds();
        AABB worldBounds = localBounds.transformed(obj.transform);

        CullObjectData cullData{};

        // Calculate bounding sphere from transformed AABB
        glm::vec3 center = worldBounds.getCenter();
        glm::vec3 extents = worldBounds.getExtents();
        float radius = glm::length(extents);

        cullData.boundingSphere = glm::vec4(center, radius);
        cullData.aabbMin = glm::vec4(worldBounds.min, 0.0f);
        cullData.aabbMax = glm::vec4(worldBounds.max, 0.0f);
        cullData.meshIndex = static_cast<uint32_t>(i);
        cullData.firstIndex = 0;  // Single mesh per object
        cullData.indexCount = obj.mesh->getIndexCount();
        cullData.vertexOffset = 0;

        cullObjects.push_back(cullData);
    }

    // Also add procedural rocks
    const auto& rockObjects = rockSystem.getSceneObjects();
    for (size_t i = 0; i < rockObjects.size(); ++i) {
        const auto& obj = rockObjects[i];
        if (obj.mesh == nullptr) continue;

        const AABB& localBounds = obj.mesh->getBounds();
        AABB worldBounds = localBounds.transformed(obj.transform);

        CullObjectData cullData{};
        glm::vec3 center = worldBounds.getCenter();
        glm::vec3 extents = worldBounds.getExtents();
        float radius = glm::length(extents);

        cullData.boundingSphere = glm::vec4(center, radius);
        cullData.aabbMin = glm::vec4(worldBounds.min, 0.0f);
        cullData.aabbMax = glm::vec4(worldBounds.max, 0.0f);
        cullData.meshIndex = static_cast<uint32_t>(sceneObjects.size() + i);
        cullData.firstIndex = 0;
        cullData.indexCount = obj.mesh->getIndexCount();
        cullData.vertexOffset = 0;

        cullObjects.push_back(cullData);
    }

    hiZSystem.updateObjectData(cullObjects);
}

#version 450
#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"

// Compute-based bloom upsample with additive blending
// Uses 9-tap tent filter for smooth upsampling
// Avoids render pass overhead of fragment shader approach

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Source texture (smaller mip level to upsample from)
layout(binding = 0) uniform sampler2D srcMip;

// Destination mip level (read-modify-write for additive blend)
layout(binding = 1, rgba16f) uniform image2D dstMip;

// Push constants
layout(push_constant) uniform PushConstants {
    vec2 srcResolution;    // Source mip resolution
    float filterRadius;    // Upsample filter radius (default 1.0)
    float padding;
} pc;

void main() {
    ivec2 dstCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dstSize = imageSize(dstMip);

    // Early out if outside destination bounds
    if (dstCoord.x >= dstSize.x || dstCoord.y >= dstSize.y) {
        return;
    }

    // Calculate UV in source texture
    vec2 texelSize = pc.filterRadius / pc.srcResolution;
    vec2 uv = (vec2(dstCoord) + 0.5) / vec2(dstSize);

    // 9-tap tent filter (3x3 weighted)
    // Weights: 1 2 1 / 2 4 2 / 1 2 1 = sum 16
    vec3 result = vec3(0.0);

    // Center (4x weight)
    result += texture(srcMip, uv).rgb * 4.0;

    // Edge samples (2x weight)
    result += texture(srcMip, uv + vec2(-1.0,  0.0) * texelSize).rgb * 2.0;
    result += texture(srcMip, uv + vec2( 1.0,  0.0) * texelSize).rgb * 2.0;
    result += texture(srcMip, uv + vec2( 0.0, -1.0) * texelSize).rgb * 2.0;
    result += texture(srcMip, uv + vec2( 0.0,  1.0) * texelSize).rgb * 2.0;

    // Corner samples (1x weight)
    result += texture(srcMip, uv + vec2(-1.0, -1.0) * texelSize).rgb;
    result += texture(srcMip, uv + vec2( 1.0, -1.0) * texelSize).rgb;
    result += texture(srcMip, uv + vec2(-1.0,  1.0) * texelSize).rgb;
    result += texture(srcMip, uv + vec2( 1.0,  1.0) * texelSize).rgb;

    result /= 16.0;

    // Read existing value and add (additive blending)
    vec3 existing = imageLoad(dstMip, dstCoord).rgb;
    imageStore(dstMip, dstCoord, vec4(existing + result, 1.0));
}

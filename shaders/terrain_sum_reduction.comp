#version 450

// CBT Sum Reduction Compute Shader
// Counts leaf nodes in the CBT bitfield
// A leaf is a node with its bit set AND neither child has its bit set

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer CBTBuffer {
    uint cbtData[];
};

layout(push_constant) uniform PushConstants {
    uint passIndex;     // Currently unused - single pass design
    uint maxDepth;
    uint numWorkgroups;
    uint padding;
} pc;

shared uint localSums[256];

// Bitfield starts at offset 16
const uint BITFIELD_OFFSET = 16u;

// Check if a heap index is a leaf (has bit set but no children have bits set)
bool isLeaf(uint heapIndex) {
    uint maxD = pc.maxDepth;
    uint depth = findMSB(heapIndex);

    // At max depth, always a leaf if bit is set
    if (depth >= maxD) return true;

    // Check if children have bits set
    uint leftChild = heapIndex * 2u;
    uint rightChild = heapIndex * 2u + 1u;

    uint leftBitIdx = leftChild - 1u;
    uint rightBitIdx = rightChild - 1u;

    uint leftWordIdx = leftBitIdx / 32u;
    uint leftBitPos = leftBitIdx % 32u;
    uint rightWordIdx = rightBitIdx / 32u;
    uint rightBitPos = rightBitIdx % 32u;

    bool leftExists = (cbtData[BITFIELD_OFFSET + leftWordIdx] & (1u << leftBitPos)) != 0u;
    bool rightExists = (cbtData[BITFIELD_OFFSET + rightWordIdx] & (1u << rightBitPos)) != 0u;

    return !leftExists && !rightExists;
}

void main() {
    uint threadId = gl_LocalInvocationIndex;

    // Count leaves in a range of heap indices
    // Heap index 1 is virtual root, actual nodes start at 2
    // With maxDepth=10, valid heap indices are 2 to 2^11 - 1 = 2047

    uint maxHeapIndex = (1u << (pc.maxDepth + 1u)) - 1u;
    uint numValidIndices = maxHeapIndex - 1u;  // exclude heap index 1
    uint indicesPerThread = (numValidIndices + 255u) / 256u;

    uint startIdx = threadId * indicesPerThread + 2u;  // heap indices start at 2
    uint endIdx = min(startIdx + indicesPerThread, maxHeapIndex + 1u);

    uint leafCount = 0u;

    for (uint heapIdx = startIdx; heapIdx < endIdx; heapIdx++) {
        // Check if this node's bit is set
        uint bitIdx = heapIdx - 1u;
        uint wordIdx = bitIdx / 32u;
        uint bitPos = bitIdx % 32u;

        bool bitSet = (cbtData[BITFIELD_OFFSET + wordIdx] & (1u << bitPos)) != 0u;

        if (bitSet && isLeaf(heapIdx)) {
            leafCount++;
        }
    }

    // Store in shared memory
    localSums[threadId] = leafCount;
    barrier();

    // Parallel reduction within workgroup
    for (uint stride = 128u; stride > 0u; stride >>= 1u) {
        if (threadId < stride) {
            localSums[threadId] += localSums[threadId + stride];
        }
        barrier();
    }

    // Thread 0 writes final result to root
    if (threadId == 0u) {
        // Ensure we have at least 2 leaves (the base triangles)
        uint total = max(localSums[0], 2u);
        cbtData[0] = total;
    }
}

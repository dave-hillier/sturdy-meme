#version 450

// Phase 3: Two-Phase Leaf Culling
// This shader processes leaves only for visible trees (determined by tree_filter.comp)
// One workgroup per visible tree - much more efficient than global leaf dispatch

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"
#include "tree_leaf_cull_common.glsl"

// Workgroup size: 256 threads per workgroup
// Each workgroup processes one visible tree's leaves
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Distance-based budget tiers to prioritize nearby tree leaves
// Aligned with 64m cell size for consistency with spatial index
const uint NUM_DISTANCE_TIERS = 3;
const float TIER_DISTANCES[NUM_DISTANCE_TIERS] = float[](64.0, 128.0, 256.0);
// Budget allocation per tier (as fraction of maxLeavesPerType):
// Tier 0 (0-64m):    50% - close trees always get leaves
// Tier 1 (64-128m):  30% - medium distance
// Tier 2 (128m+):    20% - distant trees share remainder
const float TIER_BUDGET_FRACTIONS[NUM_DISTANCE_TIERS] = float[](0.5, 0.3, 0.2);

// Visible tree data (from tree_filter.comp)
struct VisibleTreeData {
    uint originalTreeIndex;        // Index into TreeCullData array
    uint leafFirstInstance;        // Offset into leaf instance buffer
    uint leafInstanceCount;        // Number of leaves for this tree
    uint leafTypeIndex;            // Leaf type (0=oak, 1=ash, 2=aspen, 3=pine)
    float lodBlendFactor;          // LOD blend factor
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Input: Visible trees (from tree_filter.comp)
layout(std430, binding = BINDING_LEAF_CULL_P3_VISIBLE_TREES) readonly buffer VisibleTreesBuffer {
    uint visibleTreeCount;
    VisibleTreeData visibleTrees[];
};

// Input: All tree cull data (for model matrix)
layout(std430, binding = BINDING_LEAF_CULL_P3_ALL_TREES) readonly buffer AllTreesBuffer {
    TreeCullData allTrees[];
};

// Input: All leaf instances (tree-local space)
layout(std430, binding = BINDING_LEAF_CULL_P3_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: Visible leaf instances (world space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_LEAF_CULL_P3_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
// Also includes per-tier budget tracking for distance-based prioritization
layout(std430, binding = BINDING_LEAF_CULL_P3_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
    // Per-type, per-tier instance counts for budget enforcement
    // Layout: tierCounts[leafType][tier]
    uint tierCounts[NUM_LEAF_TYPES * NUM_DISTANCE_TIERS];
};

// Global culling uniforms
layout(binding = BINDING_LEAF_CULL_P3_UNIFORMS) uniform TreeLeafCullUniforms {
    vec4 cameraPosition;
    vec4 frustumPlanes[6];
    float maxDrawDistance;
    float lodTransitionStart;
    float lodTransitionEnd;
    float maxLodDropRate;
    uint numTrees;                 // Not used in Phase 3 (we use visibleTreeCount)
    uint totalLeafInstances;       // Not used in Phase 3
    uint maxLeavesPerType;
    uint _pad1;
};

// Get distance tier for budget allocation
uint getDistanceTier(float dist) {
    if (dist < TIER_DISTANCES[0]) return 0;
    if (dist < TIER_DISTANCES[1]) return 1;
    return 2;
}

// Get budget limit for a specific tier within a leaf type
uint getTierBudgetLimit(uint leafType, uint tier) {
    // Each tier gets a fraction of the per-type budget
    // Cumulative: tier 0 gets its fraction, tier 1 gets tier0 + its fraction, etc.
    float cumulativeFraction = 0.0;
    for (uint t = 0; t <= tier; t++) {
        cumulativeFraction += TIER_BUDGET_FRACTIONS[t];
    }
    return uint(float(maxLeavesPerType) * cumulativeFraction);
}

void main() {
    uint localIdx = gl_LocalInvocationID.x;     // Leaf index within this tree
    uint visibleTreeIdx = gl_WorkGroupID.x;     // Which visible tree we're processing

    // First thread in first workgroup initializes indirect commands
    if (gl_GlobalInvocationID.x == 0) {
        for (uint i = 0; i < NUM_LEAF_TYPES; i++) {
            drawCmds[i].indexCount = 6;
            drawCmds[i].instanceCount = 0;
            drawCmds[i].firstIndex = 0;
            drawCmds[i].vertexOffset = 0;
            drawCmds[i].firstInstance = i * maxLeavesPerType;
        }
        // Initialize tier counts
        for (uint i = 0; i < NUM_LEAF_TYPES * NUM_DISTANCE_TIERS; i++) {
            tierCounts[i] = 0;
        }
    }

    // Ensure initialization is complete
    barrier();
    memoryBarrierBuffer();

    // Early exit if beyond visible tree count
    if (visibleTreeIdx >= visibleTreeCount) {
        return;
    }

    // Get visible tree data
    VisibleTreeData visTree = visibleTrees[visibleTreeIdx];

    // Skip if fully in impostor mode (should be filtered by tree_filter, but double-check)
    if (visTree.lodBlendFactor >= 1.0) {
        return;
    }

    // Get original tree data for model matrix
    TreeCullData tree = allTrees[visTree.originalTreeIndex];

    // Process leaves for this tree
    // Each thread handles multiple leaves if the tree has more than 256
    for (uint i = localIdx; i < visTree.leafInstanceCount; i += 256) {
        uint globalLeafIdx = visTree.leafFirstInstance + i;

        // Get input leaf instance
        LeafInstance leaf = inputInstances[globalLeafIdx];

        // Cull leaf using shared function
        vec4 worldPos;
        float leafSize;
        float distToCamera;

        if (cullLeaf(
            leaf.positionAndSize.xyz,
            leaf.positionAndSize.w,
            tree.treeModel,
            visTree.lodBlendFactor,
            cameraPosition.xyz,
            frustumPlanes,
            maxDrawDistance,
            lodTransitionStart,
            lodTransitionEnd,
            maxLodDropRate,
            worldPos,
            leafSize,
            distToCamera
        )) {
            continue;
        }

        // Get leaf type and distance tier
        uint leafType = min(visTree.leafTypeIndex, NUM_LEAF_TYPES - 1);
        uint tier = getDistanceTier(distToCamera);

        // Tiered budget allocation:
        // - Tier 0 (close): gets first 50% of slots
        // - Tier 1 (medium): gets next 30% of slots
        // - Tier 2 (far): gets remaining 20% of slots
        // This ensures nearby trees always have leaves even when total budget is exhausted

        uint tierIndex = leafType * NUM_DISTANCE_TIERS + tier;

        // Calculate tier capacity
        uint tierBudget = getTierBudgetLimit(leafType, tier);
        uint prevTierBudget = (tier > 0) ? getTierBudgetLimit(leafType, tier - 1) : 0;
        uint tierCapacity = tierBudget - prevTierBudget;

        // Fast path: use atomicAdd for tier tracking (for statistics)
        // and check bounds after - slight over-allocation is acceptable
        uint tierSlot = atomicAdd(tierCounts[tierIndex], 1);
        if (tierSlot >= tierCapacity) {
            continue;
        }

        // Allocate output slot with simple atomicAdd
        uint typeLocalSlot = atomicAdd(drawCmds[leafType].instanceCount, 1);
        if (typeLocalSlot >= maxLeavesPerType) {
            continue;
        }

        // Calculate global output slot
        uint outputSlot = leafType * maxLeavesPerType + typeLocalSlot;

        // Write world-space leaf with tree index
        outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
        outputInstances[outputSlot].worldOrientation = transformLeafOrientation(leaf.orientation, tree.treeModel);
        outputInstances[outputSlot].treeIndex = tree.treeIndex;
        outputInstances[outputSlot]._pad0 = 0;
        outputInstances[outputSlot]._pad1 = 0;
        outputInstances[outputSlot]._pad2 = 0;
    }
}

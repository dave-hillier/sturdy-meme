#version 450

// Phase 3: Two-Phase Leaf Culling
// This shader processes leaves only for visible trees (determined by tree_filter.comp)
// One workgroup per visible tree - much more efficient than global leaf dispatch

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"

// Workgroup size: 256 threads per workgroup
// Each workgroup processes one visible tree's leaves
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Number of leaf types (oak=0, ash=1, aspen=2, pine=3)
const uint NUM_LEAF_TYPES = 4;

// Visible tree data (from tree_filter.comp)
struct VisibleTreeData {
    uint originalTreeIndex;        // Index into TreeCullData array
    uint leafFirstInstance;        // Offset into leaf instance buffer
    uint leafInstanceCount;        // Number of leaves for this tree
    uint leafTypeIndex;            // Leaf type (0=oak, 1=ash, 2=aspen, 3=pine)
    float lodBlendFactor;          // LOD blend factor
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Per-tree culling data (for model matrix lookup)
struct TreeCullData {
    mat4 treeModel;
    uint inputFirstInstance;
    uint inputInstanceCount;
    uint treeIndex;
    uint leafTypeIndex;
    float lodBlendFactor;
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Input: Visible trees (from tree_filter.comp)
layout(std430, binding = BINDING_LEAF_CULL_P3_VISIBLE_TREES) readonly buffer VisibleTreesBuffer {
    uint visibleTreeCount;
    VisibleTreeData visibleTrees[];
};

// Input: All tree cull data (for model matrix)
layout(std430, binding = BINDING_LEAF_CULL_P3_ALL_TREES) readonly buffer AllTreesBuffer {
    TreeCullData allTrees[];
};

// Input: All leaf instances (tree-local space)
layout(std430, binding = BINDING_LEAF_CULL_P3_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: Visible leaf instances (world space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_LEAF_CULL_P3_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
layout(std430, binding = BINDING_LEAF_CULL_P3_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
};

// Global culling uniforms
layout(binding = BINDING_LEAF_CULL_P3_UNIFORMS) uniform TreeLeafCullUniforms {
    vec4 cameraPosition;
    vec4 frustumPlanes[6];
    float maxDrawDistance;
    float lodTransitionStart;
    float lodTransitionEnd;
    float maxLodDropRate;
    uint numTrees;                 // Not used in Phase 3 (we use visibleTreeCount)
    uint totalLeafInstances;       // Not used in Phase 3
    uint maxLeavesPerType;
    uint _pad1;
};

void main() {
    uint localIdx = gl_LocalInvocationID.x;     // Leaf index within this tree
    uint visibleTreeIdx = gl_WorkGroupID.x;     // Which visible tree we're processing

    // First thread in first workgroup initializes indirect commands
    if (gl_GlobalInvocationID.x == 0) {
        for (uint i = 0; i < NUM_LEAF_TYPES; i++) {
            drawCmds[i].indexCount = 6;       // Quad: 6 indices
            drawCmds[i].instanceCount = 0;    // Will be atomically incremented
            drawCmds[i].firstIndex = 0;
            drawCmds[i].vertexOffset = 0;
            drawCmds[i].firstInstance = i * maxLeavesPerType;
        }
    }

    // Ensure initialization is complete
    barrier();
    memoryBarrierBuffer();

    // Early exit if beyond visible tree count
    if (visibleTreeIdx >= visibleTreeCount) {
        return;
    }

    // Get visible tree data
    VisibleTreeData visTree = visibleTrees[visibleTreeIdx];

    // Skip if fully in impostor mode (should be filtered by tree_filter, but double-check)
    if (visTree.lodBlendFactor >= 1.0) {
        return;
    }

    // Get original tree data for model matrix
    TreeCullData tree = allTrees[visTree.originalTreeIndex];

    // Process leaves for this tree
    // Each thread handles multiple leaves if the tree has more than 256
    for (uint i = localIdx; i < visTree.leafInstanceCount; i += 256) {
        uint globalLeafIdx = visTree.leafFirstInstance + i;

        // Get input leaf instance
        LeafInstance leaf = inputInstances[globalLeafIdx];

        // Transform leaf position to world space
        vec3 leafLocalPos = leaf.positionAndSize.xyz;
        vec4 worldPos = tree.treeModel * vec4(leafLocalPos, 1.0);

        // Distance culling
        float distToCamera = getDistanceToCamera(worldPos.xyz, cameraPosition.xyz);
        if (distToCamera > maxDrawDistance) {
            continue;
        }

        // Frustum culling with margin for leaf size
        float leafSize = leaf.positionAndSize.w;
        float margin = leafSize * 2.0;
        if (!isInFrustum(frustumPlanes, worldPos.xyz, margin)) {
            continue;
        }

        // LOD blade dropping - use position-based hash for consistent results
        // Incorporate LOD blend factor for smooth transitions
        float instanceHash = hash2D(leafLocalPos.xz);
        float effectiveDropRate = maxLodDropRate + visTree.lodBlendFactor * (1.0 - maxLodDropRate);
        if (lodCull(distToCamera, lodTransitionStart, lodTransitionEnd,
                    effectiveDropRate, instanceHash)) {
            continue;
        }

        // Additional stochastic culling based on LOD blend factor
        // Use a power curve to make leaves fade out faster than the impostor fades in
        // At blendFactor=0.5, about 75% of leaves should be culled (sqrt(0.5) â‰ˆ 0.71 threshold)
        if (visTree.lodBlendFactor > 0.0) {
            float adjustedBlend = sqrt(visTree.lodBlendFactor);  // More aggressive fade-out
            if (instanceHash < adjustedBlend) {
                continue;
            }
        }

        // Get leaf type
        uint leafType = min(visTree.leafTypeIndex, NUM_LEAF_TYPES - 1);

        // Atomically get output slot within this leaf type's region
        uint typeLocalSlot = atomicAdd(drawCmds[leafType].instanceCount, 1);

        // Check bounds
        if (typeLocalSlot >= maxLeavesPerType) {
            atomicAdd(drawCmds[leafType].instanceCount, -1);
            continue;
        }

        // Calculate global output slot
        uint outputSlot = leafType * maxLeavesPerType + typeLocalSlot;

        // Transform orientation to world space
        mat3 rotationMatrix = mat3(tree.treeModel);
        vec4 treeRotQuat = mat3ToQuat(rotationMatrix);
        vec4 worldOrientation = quatMul(treeRotQuat, leaf.orientation);

        // Write world-space leaf with tree index
        outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
        outputInstances[outputSlot].worldOrientation = worldOrientation;
        outputInstances[outputSlot].treeIndex = tree.treeIndex;
        outputInstances[outputSlot]._pad0 = 0;
        outputInstances[outputSlot]._pad1 = 0;
        outputInstances[outputSlot]._pad2 = 0;
    }
}

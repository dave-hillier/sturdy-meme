#version 450

// Phase 3: Two-Phase Leaf Culling
// This shader processes leaves only for visible trees (determined by tree_filter.comp)
// One workgroup per visible tree - much more efficient than global leaf dispatch
//
// Stability: Uses deterministic slot allocation based on leaf distance.
// Closer leaves always get priority, eliminating frame-to-frame flickering
// when the budget is exceeded.

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"
#include "tree_leaf_cull_common.glsl"

// Workgroup size: 256 threads per workgroup
// Each workgroup processes one visible tree's leaves
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Visible tree data (from tree_filter.comp)
struct VisibleTreeData {
    uint originalTreeIndex;        // Index into TreeCullData array
    uint leafFirstInstance;        // Offset into leaf instance buffer
    uint leafInstanceCount;        // Number of leaves for this tree
    uint leafTypeIndex;            // Leaf type (0=oak, 1=ash, 2=aspen, 3=pine)
    float lodBlendFactor;          // LOD blend factor
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Input: Visible trees (from tree_filter.comp)
layout(std430, binding = BINDING_LEAF_CULL_P3_VISIBLE_TREES) readonly buffer VisibleTreesBuffer {
    uint visibleTreeCount;
    VisibleTreeData visibleTrees[];
};

// Input: All tree cull data (for model matrix)
layout(std430, binding = BINDING_LEAF_CULL_P3_ALL_TREES) readonly buffer AllTreesBuffer {
    TreeCullData allTrees[];
};

// Input: All leaf instances (tree-local space)
layout(std430, binding = BINDING_LEAF_CULL_P3_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: Visible leaf instances (world space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_LEAF_CULL_P3_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
layout(std430, binding = BINDING_LEAF_CULL_P3_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
};

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_LEAF_CULL_P3_CULLING
#include "ubo_culling.glsl"

// Phase 3 specific parameters
layout(std140, binding = BINDING_LEAF_CULL_P3_PARAMS) uniform LeafCullP3Params {
    uint maxLeavesPerType;
    uint _pad0;
    uint _pad1;
    uint _pad2;
} leafP3Params;

// Simple hash function for deterministic leaf selection
uint hashLeaf(uint treeIndex, uint leafIndex) {
    uint h = treeIndex * 2654435761u + leafIndex * 2246822519u;
    h ^= h >> 16;
    h *= 2246822519u;
    h ^= h >> 13;
    h *= 3266489917u;
    h ^= h >> 16;
    return h;
}

// Convert distance to a priority value (0-1, closer = higher priority)
// Uses exponential falloff so nearby leaves have much higher priority
float distanceToPriority(float dist, float maxDist) {
    float normalized = clamp(dist / maxDist, 0.0, 1.0);
    // Exponential: close leaves get priority ~1.0, far leaves get priority ~0.0
    return exp(-normalized * 3.0);
}

void main() {
    uint localIdx = gl_LocalInvocationID.x;     // Thread index within workgroup
    uint visibleTreeIdx = gl_WorkGroupID.x;     // Which visible tree we're processing

    // Early exit if beyond visible tree count
    if (visibleTreeIdx >= visibleTreeCount) {
        return;
    }

    // Get visible tree data
    VisibleTreeData visTree = visibleTrees[visibleTreeIdx];

    // Skip if fully in impostor mode
    if (visTree.lodBlendFactor >= 1.0) {
        return;
    }

    // Get original tree data for model matrix
    TreeCullData tree = allTrees[visTree.originalTreeIndex];
    uint leafType = min(visTree.leafTypeIndex, NUM_LEAF_TYPES - 1);

    // Process leaves - each thread handles multiple leaves if tree has more than 256
    for (uint i = localIdx; i < visTree.leafInstanceCount; i += 256) {
        uint globalLeafIdx = visTree.leafFirstInstance + i;
        LeafInstance leaf = inputInstances[globalLeafIdx];

        // Cull leaf
        vec4 worldPos;
        float leafSize;
        float distToCamera;

        bool culled = cullLeaf(
            leaf.positionAndSize.xyz,
            leaf.positionAndSize.w,
            tree.treeModel,
            visTree.lodBlendFactor,
            culling.cameraPosition.xyz,
            culling.frustumPlanes,
            culling.maxDrawDistance,
            culling.lodTransitionStart,
            culling.lodTransitionEnd,
            culling.maxLodDropRate,
            worldPos,
            leafSize,
            distToCamera
        );

        if (culled) {
            continue;
        }

        // Deterministic priority-based selection:
        // - Generate a stable hash for this leaf (same every frame)
        // - Convert to a threshold value [0, 1]
        // - Compare against distance-based priority
        // - Closer leaves have higher priority, so they pass the threshold more often
        //
        // This ensures the SAME leaves are always selected, eliminating flicker.
        // When budget pressure increases, far leaves drop out first (deterministically).

        uint leafHash = hashLeaf(tree.treeIndex, i);
        float hashThreshold = float(leafHash) / float(0xFFFFFFFFu);  // [0, 1]

        // Priority based on distance - closer = higher priority
        float priority = distanceToPriority(distToCamera, culling.maxDrawDistance);

        // Leaves pass if their priority exceeds the hash threshold
        // Close leaves (priority ~1.0) almost always pass
        // Far leaves (priority ~0.05) rarely pass, providing natural LOD
        if (priority < hashThreshold * 0.5) {
            continue;  // Deterministically skip this leaf
        }

        // Allocate output slot
        uint typeLocalSlot = atomicAdd(drawCmds[leafType].instanceCount, 1);

        if (typeLocalSlot < leafP3Params.maxLeavesPerType) {
            uint outputSlot = leafType * leafP3Params.maxLeavesPerType + typeLocalSlot;

            outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
            outputInstances[outputSlot].worldOrientation = transformLeafOrientation(leaf.orientation, tree.treeModel);
            outputInstances[outputSlot].treeIndex = tree.treeIndex;
            outputInstances[outputSlot]._pad0 = 0;
            outputInstances[outputSlot]._pad1 = 0;
            outputInstances[outputSlot]._pad2 = 0;
        }
    }
}

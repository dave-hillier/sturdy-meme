#version 450

// Phase 3: Two-Phase Leaf Culling
// This shader processes leaves only for visible trees (determined by tree_filter.comp)
// One workgroup per visible tree - much more efficient than global leaf dispatch

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"

// Workgroup size: 256 threads per workgroup
// Each workgroup processes one visible tree's leaves
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Number of leaf types (oak=0, ash=1, aspen=2, pine=3)
const uint NUM_LEAF_TYPES = 4;

// Distance-based budget tiers to prioritize nearby tree leaves
// This ensures close trees always have leaves, even when budget is tight
// Aligned with 64m cell size for consistency with spatial index
const uint NUM_DISTANCE_TIERS = 3;
const float TIER_DISTANCES[NUM_DISTANCE_TIERS] = float[](64.0, 128.0, 256.0);
// Budget allocation per tier (as fraction of maxLeavesPerType):
// Tier 0 (0-64m):    50% of budget - close trees always get leaves
// Tier 1 (64-128m):  30% of budget - medium distance
// Tier 2 (128m+):    20% of budget - distant trees share remainder
const float TIER_BUDGET_FRACTIONS[NUM_DISTANCE_TIERS] = float[](0.5, 0.3, 0.2);

// Visible tree data (from tree_filter.comp)
struct VisibleTreeData {
    uint originalTreeIndex;        // Index into TreeCullData array
    uint leafFirstInstance;        // Offset into leaf instance buffer
    uint leafInstanceCount;        // Number of leaves for this tree
    uint leafTypeIndex;            // Leaf type (0=oak, 1=ash, 2=aspen, 3=pine)
    float lodBlendFactor;          // LOD blend factor
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Per-tree culling data (for model matrix lookup)
struct TreeCullData {
    mat4 treeModel;
    uint inputFirstInstance;
    uint inputInstanceCount;
    uint treeIndex;
    uint leafTypeIndex;
    float lodBlendFactor;
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Input: Visible trees (from tree_filter.comp)
layout(std430, binding = BINDING_LEAF_CULL_P3_VISIBLE_TREES) readonly buffer VisibleTreesBuffer {
    uint visibleTreeCount;
    VisibleTreeData visibleTrees[];
};

// Input: All tree cull data (for model matrix)
layout(std430, binding = BINDING_LEAF_CULL_P3_ALL_TREES) readonly buffer AllTreesBuffer {
    TreeCullData allTrees[];
};

// Input: All leaf instances (tree-local space)
layout(std430, binding = BINDING_LEAF_CULL_P3_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: Visible leaf instances (world space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_LEAF_CULL_P3_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
// Also includes per-tier budget tracking for distance-based prioritization
layout(std430, binding = BINDING_LEAF_CULL_P3_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
    // Per-type, per-tier instance counts for budget enforcement
    // Layout: tierCounts[leafType][tier]
    uint tierCounts[NUM_LEAF_TYPES * NUM_DISTANCE_TIERS];
};

// Global culling uniforms
layout(binding = BINDING_LEAF_CULL_P3_UNIFORMS) uniform TreeLeafCullUniforms {
    vec4 cameraPosition;
    vec4 frustumPlanes[6];
    float maxDrawDistance;
    float lodTransitionStart;
    float lodTransitionEnd;
    float maxLodDropRate;
    uint numTrees;                 // Not used in Phase 3 (we use visibleTreeCount)
    uint totalLeafInstances;       // Not used in Phase 3
    uint maxLeavesPerType;
    uint _pad1;
};

// Get distance tier for budget allocation
uint getDistanceTier(float dist) {
    if (dist < TIER_DISTANCES[0]) return 0;
    if (dist < TIER_DISTANCES[1]) return 1;
    return 2;
}

// Get budget limit for a specific tier within a leaf type
uint getTierBudgetLimit(uint leafType, uint tier) {
    // Each tier gets a fraction of the per-type budget
    // Cumulative: tier 0 gets its fraction, tier 1 gets tier0 + its fraction, etc.
    float cumulativeFraction = 0.0;
    for (uint t = 0; t <= tier; t++) {
        cumulativeFraction += TIER_BUDGET_FRACTIONS[t];
    }
    return uint(float(maxLeavesPerType) * cumulativeFraction);
}

void main() {
    uint localIdx = gl_LocalInvocationID.x;     // Leaf index within this tree
    uint visibleTreeIdx = gl_WorkGroupID.x;     // Which visible tree we're processing

    // First thread in first workgroup initializes indirect commands
    if (gl_GlobalInvocationID.x == 0) {
        for (uint i = 0; i < NUM_LEAF_TYPES; i++) {
            drawCmds[i].indexCount = 6;       // Quad: 6 indices
            drawCmds[i].instanceCount = 0;    // Will be atomically incremented
            drawCmds[i].firstIndex = 0;
            drawCmds[i].vertexOffset = 0;
            drawCmds[i].firstInstance = i * maxLeavesPerType;
        }
        // Initialize tier counts
        for (uint i = 0; i < NUM_LEAF_TYPES * NUM_DISTANCE_TIERS; i++) {
            tierCounts[i] = 0;
        }
    }

    // Ensure initialization is complete
    barrier();
    memoryBarrierBuffer();

    // Early exit if beyond visible tree count
    if (visibleTreeIdx >= visibleTreeCount) {
        return;
    }

    // Get visible tree data
    VisibleTreeData visTree = visibleTrees[visibleTreeIdx];

    // Skip if fully in impostor mode (should be filtered by tree_filter, but double-check)
    if (visTree.lodBlendFactor >= 1.0) {
        return;
    }

    // Get original tree data for model matrix
    TreeCullData tree = allTrees[visTree.originalTreeIndex];

    // Process leaves for this tree
    // Each thread handles multiple leaves if the tree has more than 256
    for (uint i = localIdx; i < visTree.leafInstanceCount; i += 256) {
        uint globalLeafIdx = visTree.leafFirstInstance + i;

        // Get input leaf instance
        LeafInstance leaf = inputInstances[globalLeafIdx];

        // Transform leaf position to world space
        vec3 leafLocalPos = leaf.positionAndSize.xyz;
        vec4 worldPos = tree.treeModel * vec4(leafLocalPos, 1.0);

        // Distance culling
        float distToCamera = getDistanceToCamera(worldPos.xyz, cameraPosition.xyz);
        if (distToCamera > maxDrawDistance) {
            continue;
        }

        // Frustum culling with margin for leaf size
        float leafSize = leaf.positionAndSize.w;
        float margin = leafSize * 2.0;
        if (!isInFrustum(frustumPlanes, worldPos.xyz, margin)) {
            continue;
        }

        // LOD blade dropping - use position-based hash for consistent results
        // Incorporate LOD blend factor for smooth transitions
        float instanceHash = hash2D(leafLocalPos.xz);
        float effectiveDropRate = maxLodDropRate + visTree.lodBlendFactor * (1.0 - maxLodDropRate);
        if (lodCull(distToCamera, lodTransitionStart, lodTransitionEnd,
                    effectiveDropRate, instanceHash)) {
            continue;
        }

        // Additional stochastic culling based on LOD blend factor
        // Use a power curve to make leaves fade out faster than the impostor fades in
        // At blendFactor=0.5, about 75% of leaves should be culled (sqrt(0.5) â‰ˆ 0.71 threshold)
        if (visTree.lodBlendFactor > 0.0) {
            float adjustedBlend = sqrt(visTree.lodBlendFactor);  // More aggressive fade-out
            if (instanceHash < adjustedBlend) {
                continue;
            }
        }

        // Get leaf type and distance tier
        uint leafType = min(visTree.leafTypeIndex, NUM_LEAF_TYPES - 1);
        uint tier = getDistanceTier(distToCamera);

        // Tiered budget allocation:
        // - Tier 0 (close): gets first 50% of slots
        // - Tier 1 (medium): gets next 30% of slots
        // - Tier 2 (far): gets remaining 20% of slots
        // This ensures nearby trees always have leaves even when total budget is exhausted

        uint tierIndex = leafType * NUM_DISTANCE_TIERS + tier;

        // Calculate tier capacity
        uint tierBudget = getTierBudgetLimit(leafType, tier);
        uint prevTierBudget = (tier > 0) ? getTierBudgetLimit(leafType, tier - 1) : 0;
        uint tierCapacity = tierBudget - prevTierBudget;

        // Use compare-and-swap to safely reserve tier slot without race condition
        uint tierSlot;
        uint currentTierCount = tierCounts[tierIndex];
        while (true) {
            if (currentTierCount >= tierCapacity) {
                // Tier budget exhausted - this leaf doesn't get rendered
                tierSlot = tierCapacity; // Mark as failed
                break;
            }
            uint prevCount = atomicCompSwap(tierCounts[tierIndex], currentTierCount, currentTierCount + 1);
            if (prevCount == currentTierCount) {
                tierSlot = currentTierCount;
                break;
            }
            currentTierCount = prevCount;
        }

        if (tierSlot >= tierCapacity) {
            continue;
        }

        // Use compare-and-swap to safely reserve output slot without race condition
        uint typeLocalSlot;
        uint currentCount = drawCmds[leafType].instanceCount;
        while (true) {
            if (currentCount >= maxLeavesPerType) {
                // Budget exhausted
                typeLocalSlot = maxLeavesPerType;
                break;
            }
            uint prevCount = atomicCompSwap(drawCmds[leafType].instanceCount, currentCount, currentCount + 1);
            if (prevCount == currentCount) {
                typeLocalSlot = currentCount;
                break;
            }
            currentCount = prevCount;
        }

        if (typeLocalSlot >= maxLeavesPerType) {
            // Undo tier reservation since we couldn't get an output slot
            atomicAdd(tierCounts[tierIndex], -1);
            continue;
        }

        // Calculate global output slot
        uint outputSlot = leafType * maxLeavesPerType + typeLocalSlot;

        // Transform orientation to world space
        mat3 rotationMatrix = mat3(tree.treeModel);
        vec4 treeRotQuat = mat3ToQuat(rotationMatrix);
        vec4 worldOrientation = quatMul(treeRotQuat, leaf.orientation);

        // Write world-space leaf with tree index
        outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
        outputInstances[outputSlot].worldOrientation = worldOrientation;
        outputInstances[outputSlot].treeIndex = tree.treeIndex;
        outputInstances[outputSlot]._pad0 = 0;
        outputInstances[outputSlot]._pad1 = 0;
        outputInstances[outputSlot]._pad2 = 0;
    }
}

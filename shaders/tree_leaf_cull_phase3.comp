#version 450

// Phase 3: Two-Phase Leaf Culling
// This shader processes leaves only for visible trees (determined by tree_filter.comp)
// One workgroup per visible tree - much more efficient than global leaf dispatch

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"
#include "tree_leaf_cull_common.glsl"

// Workgroup size: 256 threads per workgroup
// Each workgroup processes one visible tree's leaves
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Distance-based budget tiers to prioritize nearby tree leaves
// Aligned with 64m cell size for consistency with spatial index
const uint NUM_DISTANCE_TIERS = 3;
const float TIER_DISTANCES[NUM_DISTANCE_TIERS] = float[](64.0, 128.0, 256.0);
// Budget allocation per tier (as fraction of maxLeavesPerType):
// Tier 0 (0-64m):    50% - close trees always get leaves
// Tier 1 (64-128m):  30% - medium distance
// Tier 2 (128m+):    20% - distant trees share remainder
const float TIER_BUDGET_FRACTIONS[NUM_DISTANCE_TIERS] = float[](0.5, 0.3, 0.2);

// Visible tree data (from tree_filter.comp)
struct VisibleTreeData {
    uint originalTreeIndex;        // Index into TreeCullData array
    uint leafFirstInstance;        // Offset into leaf instance buffer
    uint leafInstanceCount;        // Number of leaves for this tree
    uint leafTypeIndex;            // Leaf type (0=oak, 1=ash, 2=aspen, 3=pine)
    float lodBlendFactor;          // LOD blend factor
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Input: Visible trees (from tree_filter.comp)
layout(std430, binding = BINDING_LEAF_CULL_P3_VISIBLE_TREES) readonly buffer VisibleTreesBuffer {
    uint visibleTreeCount;
    VisibleTreeData visibleTrees[];
};

// Input: All tree cull data (for model matrix)
layout(std430, binding = BINDING_LEAF_CULL_P3_ALL_TREES) readonly buffer AllTreesBuffer {
    TreeCullData allTrees[];
};

// Input: All leaf instances (tree-local space)
layout(std430, binding = BINDING_LEAF_CULL_P3_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: Visible leaf instances (world space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_LEAF_CULL_P3_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
// Also includes per-tier budget tracking for distance-based prioritization
layout(std430, binding = BINDING_LEAF_CULL_P3_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
    // Per-type, per-tier instance counts for budget enforcement
    // Layout: tierCounts[leafType][tier]
    uint tierCounts[NUM_LEAF_TYPES * NUM_DISTANCE_TIERS];
};

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_LEAF_CULL_P3_CULLING
#include "ubo_culling.glsl"

// Phase 3 specific parameters
layout(std140, binding = BINDING_LEAF_CULL_P3_PARAMS) uniform LeafCullP3Params {
    uint maxLeavesPerType;
    uint _pad0;
    uint _pad1;
    uint _pad2;
} leafP3Params;

// Get distance tier for budget allocation
uint getDistanceTier(float dist) {
    if (dist < TIER_DISTANCES[0]) return 0;
    if (dist < TIER_DISTANCES[1]) return 1;
    return 2;
}

// Get budget limit for a specific tier within a leaf type
uint getTierBudgetLimit(uint leafType, uint tier) {
    // Each tier gets a fraction of the per-type budget
    // Cumulative: tier 0 gets its fraction, tier 1 gets tier0 + its fraction, etc.
    float cumulativeFraction = 0.0;
    for (uint t = 0; t <= tier; t++) {
        cumulativeFraction += TIER_BUDGET_FRACTIONS[t];
    }
    return uint(float(leafP3Params.maxLeavesPerType) * cumulativeFraction);
}

void main() {
    uint localIdx = gl_LocalInvocationID.x;     // Leaf index within this tree
    uint visibleTreeIdx = gl_WorkGroupID.x;     // Which visible tree we're processing

    // NOTE: Indirect command and tierCounts initialization is done on CPU side via vkCmdUpdateBuffer
    // BEFORE dispatch. Shader-side init with barrier() only syncs within a workgroup,
    // causing race conditions when multiple workgroups run in parallel.

    // Early exit if beyond visible tree count
    if (visibleTreeIdx >= visibleTreeCount) {
        return;
    }

    // Get visible tree data
    VisibleTreeData visTree = visibleTrees[visibleTreeIdx];

    // Skip if fully in impostor mode (should be filtered by tree_filter, but double-check)
    if (visTree.lodBlendFactor >= 1.0) {
        return;
    }

    // Get original tree data for model matrix
    TreeCullData tree = allTrees[visTree.originalTreeIndex];

    // Process leaves for this tree
    // Each thread handles multiple leaves if the tree has more than 256
    for (uint i = localIdx; i < visTree.leafInstanceCount; i += 256) {
        uint globalLeafIdx = visTree.leafFirstInstance + i;

        // Get input leaf instance
        LeafInstance leaf = inputInstances[globalLeafIdx];

        // Cull leaf using shared function
        vec4 worldPos;
        float leafSize;
        float distToCamera;

        if (cullLeaf(
            leaf.positionAndSize.xyz,
            leaf.positionAndSize.w,
            tree.treeModel,
            visTree.lodBlendFactor,
            culling.cameraPosition.xyz,
            culling.frustumPlanes,
            culling.maxDrawDistance,
            culling.lodTransitionStart,
            culling.lodTransitionEnd,
            culling.maxLodDropRate,
            worldPos,
            leafSize,
            distToCamera
        )) {
            continue;
        }

        // Get leaf type and distance tier
        uint leafType = min(visTree.leafTypeIndex, NUM_LEAF_TYPES - 1);
        uint tier = getDistanceTier(distToCamera);

        // Tiered budget allocation:
        // - Tier 0 (close): gets first 50% of slots
        // - Tier 1 (medium): gets next 30% of slots
        // - Tier 2 (far): gets remaining 20% of slots
        // This ensures nearby trees always have leaves even when total budget is exhausted

        uint tierIndex = leafType * NUM_DISTANCE_TIERS + tier;

        // Calculate tier capacity
        uint tierBudget = getTierBudgetLimit(leafType, tier);
        uint prevTierBudget = (tier > 0) ? getTierBudgetLimit(leafType, tier - 1) : 0;
        uint tierCapacity = tierBudget - prevTierBudget;

        // Fast path: use atomicAdd for tier tracking (for statistics)
        // and check bounds after - slight over-allocation is acceptable
        uint tierSlot = atomicAdd(tierCounts[tierIndex], 1);
        if (tierSlot >= tierCapacity) {
            continue;
        }

        // Allocate output slot with simple atomicAdd
        uint typeLocalSlot = atomicAdd(drawCmds[leafType].instanceCount, 1);
        if (typeLocalSlot >= leafP3Params.maxLeavesPerType) {
            continue;
        }

        // Calculate global output slot
        uint outputSlot = leafType * leafP3Params.maxLeavesPerType + typeLocalSlot;

        // Write world-space leaf with tree index
        outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
        outputInstances[outputSlot].worldOrientation = transformLeafOrientation(leaf.orientation, tree.treeModel);
        outputInstances[outputSlot].treeIndex = tree.treeIndex;
        outputInstances[outputSlot]._pad0 = 0;
        outputInstances[outputSlot]._pad1 = 0;
        outputInstances[outputSlot]._pad2 = 0;
    }
}

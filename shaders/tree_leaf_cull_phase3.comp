#version 450

// Phase 3: Two-Phase Leaf Culling
// This shader processes leaves only for visible trees (determined by tree_filter.comp)
// One workgroup per visible tree - much more efficient than global leaf dispatch
//
// Stability: Uses deterministic slot allocation based on leaf distance.
// Closer leaves always get priority, eliminating frame-to-frame flickering
// when the budget is exceeded.

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"
#include "tree_leaf_cull_common.glsl"

// Workgroup size: 256 threads per workgroup
// Each workgroup processes one visible tree's leaves
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// No tier-based budget system - rely on LOD distance dropping instead
// (like the grass system does). This prevents flickering caused by
// leaves being dropped when tier budgets are exhausted.

// Visible tree data (from tree_filter.comp)
struct VisibleTreeData {
    uint originalTreeIndex;        // Index into TreeCullData array
    uint leafFirstInstance;        // Offset into leaf instance buffer
    uint leafInstanceCount;        // Number of leaves for this tree
    uint leafTypeIndex;            // Leaf type (0=oak, 1=ash, 2=aspen, 3=pine)
    float lodBlendFactor;          // LOD blend factor
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Input: Visible trees (from tree_filter.comp)
layout(std430, binding = BINDING_LEAF_CULL_P3_VISIBLE_TREES) readonly buffer VisibleTreesBuffer {
    uint visibleTreeCount;
    VisibleTreeData visibleTrees[];
};

// Input: All tree cull data (for model matrix)
layout(std430, binding = BINDING_LEAF_CULL_P3_ALL_TREES) readonly buffer AllTreesBuffer {
    TreeCullData allTrees[];
};

// Input: All leaf instances (tree-local space)
layout(std430, binding = BINDING_LEAF_CULL_P3_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: Visible leaf instances (world space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_LEAF_CULL_P3_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
layout(std430, binding = BINDING_LEAF_CULL_P3_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
};

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_LEAF_CULL_P3_CULLING
#include "ubo_culling.glsl"

// Phase 3 specific parameters
layout(std140, binding = BINDING_LEAF_CULL_P3_PARAMS) uniform LeafCullP3Params {
    uint maxLeavesPerType;
    uint _pad0;
    uint _pad1;
    uint _pad2;
} leafP3Params;

void main() {
    uint localIdx = gl_LocalInvocationID.x;     // Thread index within workgroup
    uint visibleTreeIdx = gl_WorkGroupID.x;     // Which visible tree we're processing

    // NOTE: Indirect command initialization is done on CPU side via vkCmdUpdateBuffer
    // BEFORE dispatch. Shader-side init with barrier() only syncs within a workgroup,
    // causing race conditions when multiple workgroups run in parallel.

    // Early exit if beyond visible tree count
    if (visibleTreeIdx >= visibleTreeCount) {
        return;
    }

    // Get visible tree data
    VisibleTreeData visTree = visibleTrees[visibleTreeIdx];

    // Skip if fully in impostor mode
    if (visTree.lodBlendFactor >= 1.0) {
        return;
    }

    // Get original tree data for model matrix
    TreeCullData tree = allTrees[visTree.originalTreeIndex];
    uint leafType = min(visTree.leafTypeIndex, NUM_LEAF_TYPES - 1);

    // Process leaves - each thread handles multiple leaves if tree has more than 256
    for (uint i = localIdx; i < visTree.leafInstanceCount; i += 256) {
        uint globalLeafIdx = visTree.leafFirstInstance + i;
        LeafInstance leaf = inputInstances[globalLeafIdx];

        // Cull leaf
        vec4 worldPos;
        float leafSize;
        float distToCamera;

        bool culled = cullLeaf(
            leaf.positionAndSize.xyz,
            leaf.positionAndSize.w,
            tree.treeModel,
            visTree.lodBlendFactor,
            culling.cameraPosition.xyz,
            culling.frustumPlanes,
            culling.maxDrawDistance,
            i,                              // leafIndexInTree - stable integer index
            visTree.originalTreeIndex,      // treeIndex - for unique hash per tree
            worldPos,
            leafSize,
            distToCamera
        );

        if (culled) {
            continue;
        }

        // Get leaf type
        uint leafType = min(visTree.leafTypeIndex, NUM_LEAF_TYPES - 1);

        // Use hash to deterministically select which leaves get buffer slots.
        // This prevents flickering from atomic race conditions when near budget limit.
        // Leaves with hash values above the threshold are dropped consistently.
        //
        // The hash was already computed in cullLeaf for LOD dropping.
        // We reuse it here for budget priority - same hash = same priority each frame.
        float instanceHash = hashLeafIndex(visTree.originalTreeIndex, i);

        // Reserve some headroom (use 95% of budget) to avoid edge-case racing
        float budgetFraction = 0.95;
        if (instanceHash > budgetFraction) {
            continue;  // Deterministically drop ~5% of leaves to stay under budget
        }

        // Allocate output slot using atomicAdd
        uint typeLocalSlot = atomicAdd(drawCmds[leafType].instanceCount, 1);
        if (typeLocalSlot >= leafP3Params.maxLeavesPerType) {
            // Over budget - shouldn't happen often with the hash-based pre-filter
            continue;
        }

        if (typeLocalSlot < leafP3Params.maxLeavesPerType) {
            uint outputSlot = leafType * leafP3Params.maxLeavesPerType + typeLocalSlot;

            outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
            outputInstances[outputSlot].worldOrientation = transformLeafOrientation(leaf.orientation, tree.treeModel);
            outputInstances[outputSlot].treeIndex = tree.treeIndex;
            outputInstances[outputSlot]._pad0 = 0;
            outputInstances[outputSlot]._pad1 = 0;
            outputInstances[outputSlot]._pad2 = 0;
        }
    }
}

#version 450

// Phase 3: Two-Phase Leaf Culling
// This shader processes leaves only for visible trees (determined by tree_filter.comp)
// One workgroup per visible tree - much more efficient than global leaf dispatch

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"
#include "tree_leaf_cull_common.glsl"

// Workgroup size: 256 threads per workgroup
// Each workgroup processes one visible tree's leaves
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// No tier-based budget system - rely on LOD distance dropping instead
// (like the grass system does). This prevents flickering caused by
// leaves being dropped when tier budgets are exhausted.

// Visible tree data (from tree_filter.comp)
struct VisibleTreeData {
    uint originalTreeIndex;        // Index into TreeCullData array
    uint leafFirstInstance;        // Offset into leaf instance buffer
    uint leafInstanceCount;        // Number of leaves for this tree
    uint leafTypeIndex;            // Leaf type (0=oak, 1=ash, 2=aspen, 3=pine)
    float lodBlendFactor;          // LOD blend factor
    uint _pad0;
    uint _pad1;
    uint _pad2;
};

// Input: Visible trees (from tree_filter.comp)
layout(std430, binding = BINDING_LEAF_CULL_P3_VISIBLE_TREES) readonly buffer VisibleTreesBuffer {
    uint visibleTreeCount;
    VisibleTreeData visibleTrees[];
};

// Input: All tree cull data (for model matrix)
layout(std430, binding = BINDING_LEAF_CULL_P3_ALL_TREES) readonly buffer AllTreesBuffer {
    TreeCullData allTrees[];
};

// Input: All leaf instances (tree-local space)
layout(std430, binding = BINDING_LEAF_CULL_P3_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: Visible leaf instances (world space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_LEAF_CULL_P3_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
layout(std430, binding = BINDING_LEAF_CULL_P3_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
};

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_LEAF_CULL_P3_CULLING
#include "ubo_culling.glsl"

// Phase 3 specific parameters
layout(std140, binding = BINDING_LEAF_CULL_P3_PARAMS) uniform LeafCullP3Params {
    uint maxLeavesPerType;
    uint _pad0;
    uint _pad1;
    uint _pad2;
} leafP3Params;

void main() {
    uint localIdx = gl_LocalInvocationID.x;     // Leaf index within this tree
    uint visibleTreeIdx = gl_WorkGroupID.x;     // Which visible tree we're processing

    // NOTE: Indirect command initialization is done on CPU side via vkCmdUpdateBuffer
    // BEFORE dispatch. Shader-side init with barrier() only syncs within a workgroup,
    // causing race conditions when multiple workgroups run in parallel.

    // Early exit if beyond visible tree count
    if (visibleTreeIdx >= visibleTreeCount) {
        return;
    }

    // Get visible tree data
    VisibleTreeData visTree = visibleTrees[visibleTreeIdx];

    // Skip if fully in impostor mode (should be filtered by tree_filter, but double-check)
    if (visTree.lodBlendFactor >= 1.0) {
        return;
    }

    // Get original tree data for model matrix
    TreeCullData tree = allTrees[visTree.originalTreeIndex];

    // Process leaves for this tree
    // Each thread handles multiple leaves if the tree has more than 256
    for (uint i = localIdx; i < visTree.leafInstanceCount; i += 256) {
        uint globalLeafIdx = visTree.leafFirstInstance + i;

        // Get input leaf instance
        LeafInstance leaf = inputInstances[globalLeafIdx];

        // Cull leaf using shared function
        vec4 worldPos;
        float leafSize;
        float distToCamera;

        if (cullLeaf(
            leaf.positionAndSize.xyz,
            leaf.positionAndSize.w,
            tree.treeModel,
            visTree.lodBlendFactor,
            culling.cameraPosition.xyz,
            culling.frustumPlanes,
            culling.maxDrawDistance,
            i,                              // leafIndexInTree - stable integer index
            visTree.originalTreeIndex,      // treeIndex - for unique hash per tree
            worldPos,
            leafSize,
            distToCamera
        )) {
            continue;
        }

        // Get leaf type
        uint leafType = min(visTree.leafTypeIndex, NUM_LEAF_TYPES - 1);

        // Allocate output slot using atomicAdd
        // The hash-based LOD dropping already ensures deterministic selection.
        // If we exceed the buffer, we'll hit the safety check below - but with
        // proper LOD dropping parameters, this should rarely happen.
        uint typeLocalSlot = atomicAdd(drawCmds[leafType].instanceCount, 1);
        if (typeLocalSlot >= leafP3Params.maxLeavesPerType) {
            // Over budget - this leaf won't be rendered this frame
            // This is a fallback; proper LOD settings should prevent reaching here
            continue;
        }

        // Calculate global output slot
        uint outputSlot = leafType * leafP3Params.maxLeavesPerType + typeLocalSlot;

        // Write world-space leaf with tree index
        outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
        outputInstances[outputSlot].worldOrientation = transformLeafOrientation(leaf.orientation, tree.treeModel);
        outputInstances[outputSlot].treeIndex = tree.treeIndex;
        outputInstances[outputSlot]._pad0 = 0;
        outputInstances[outputSlot]._pad1 = 0;
        outputInstances[outputSlot]._pad2 = 0;
    }
}

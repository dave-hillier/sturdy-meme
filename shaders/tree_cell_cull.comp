#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "cull_compute_common.glsl"

// Workgroup size: 256 threads per workgroup
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Distance bucketing uses NUM_DISTANCE_BUCKETS from cull_compute_common.glsl

// Cell data (packed for GPU - 32 bytes per cell)
// boundsMinAndFirst: xyz = boundsMin, w = firstTreeIndex as float bits
// boundsMaxAndCount: xyz = boundsMax, w = treeCount as float bits
struct TreeCellGPU {
    vec4 boundsMinAndFirst;
    vec4 boundsMaxAndCount;
};

// Input: All cells in the spatial grid
layout(std430, binding = BINDING_TREE_CELL_CULL_CELLS) readonly buffer CellBuffer {
    TreeCellGPU cells[];
};

// Output: Visible cell indices (compacted list, sorted by distance bucket)
// Layout: [bucket0 cells][bucket1 cells]...[bucket7 cells]
// Each bucket is contiguous, bucket counts stored in IndirectDispatchBuffer
layout(std430, binding = BINDING_TREE_CELL_CULL_VISIBLE) buffer VisibleCellBuffer {
    uint visibleCellCount;
    uint visibleCellIndices[];
};

// Indirect dispatch command for tree culling pass
// x = number of workgroups, y = 1, z = 1
layout(std430, binding = BINDING_TREE_CELL_CULL_INDIRECT) buffer IndirectDispatchBuffer {
    uint dispatchX;
    uint dispatchY;
    uint dispatchZ;
    uint totalVisibleTrees;  // Running count of trees in visible cells
    // Bucket offsets for distance-sorted cell output
    uint bucketCounts[NUM_DISTANCE_BUCKETS];
    uint bucketOffsets[NUM_DISTANCE_BUCKETS];  // Prefix sum (computed after first pass)
};

// Culling uniforms
layout(binding = BINDING_TREE_CELL_CULL_UNIFORMS) uniform CellCullUniforms {
    vec4 cameraPosition;           // xyz = camera pos, w = unused
    vec4 frustumPlanes[6];         // Frustum planes for culling
    float maxDrawDistance;         // Maximum tree draw distance
    uint numCells;                 // Total number of cells in grid
    uint treesPerWorkgroup;        // How many trees to process per workgroup in tree cull
    uint _pad0;
};

// Culling functions (isAABBInFrustum, isAABBInRange, getDistanceBucket)
// are provided by cull_compute_common.glsl

// Shared memory for bucket prefix sum calculation
shared uint sharedBucketCounts[NUM_DISTANCE_BUCKETS];

void main() {
    uint cellIdx = gl_GlobalInvocationID.x;
    uint localIdx = gl_LocalInvocationID.x;

    // NOTE: Output buffer initialization is done on CPU side via vkCmdFillBuffer/vkCmdUpdateBuffer
    // BEFORE dispatch. Shader-side init with barrier() only syncs within a workgroup, causing
    // race conditions when multiple workgroups run in parallel.

    // Initialize shared memory for this workgroup
    if (localIdx < NUM_DISTANCE_BUCKETS) {
        sharedBucketCounts[localIdx] = 0;
    }

    // Sync shared memory within workgroup
    barrier();

    // Early exit if beyond cell count
    if (cellIdx >= numCells) {
        return;
    }

    // Load cell data
    TreeCellGPU cell = cells[cellIdx];
    vec3 boundsMin = cell.boundsMinAndFirst.xyz;
    vec3 boundsMax = cell.boundsMaxAndCount.xyz;
    uint firstTreeIndex = floatBitsToUint(cell.boundsMinAndFirst.w);
    uint treeCount = floatBitsToUint(cell.boundsMaxAndCount.w);

    // Skip empty cells
    if (treeCount == 0) {
        return;
    }

    // Distance culling: skip cells too far from camera
    if (!isAABBInRange(boundsMin, boundsMax, cameraPosition.xyz, maxDrawDistance)) {
        return;
    }

    // Frustum culling: skip cells completely outside frustum
    if (!isAABBInFrustum(boundsMin, boundsMax, frustumPlanes)) {
        return;
    }

    // Calculate distance to cell center for bucket assignment
    vec3 cellCenter = (boundsMin + boundsMax) * 0.5;
    float distToCamera = length(cellCenter - cameraPosition.xyz);
    uint bucket = getDistanceBucket(distToCamera);

    // Calculate workgroups needed for this cell
    uint workgroupsForCell = (treeCount + treesPerWorkgroup - 1) / treesPerWorkgroup;

    // Use subgroup operations to batch atomic updates

    // 1. Batch bucket counts per bucket (like leaf types)
    for (uint b = 0; b < NUM_DISTANCE_BUCKETS; b++) {
        uvec4 bucketMask = subgroupBallot(bucket == b);
        uint bucketCount = subgroupBallotBitCount(bucketMask);
        if (bucketCount > 0 && subgroupBallotFindLSB(bucketMask) == gl_SubgroupInvocationID) {
            atomicAdd(bucketCounts[b], bucketCount);
        }
    }

    // 2. Batch visibleCellCount (simple counter)
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    uint baseIdx = 0;
    if (subgroupElect()) {
        baseIdx = atomicAdd(visibleCellCount, activeCount);
        // 3. Sum and batch totalVisibleTrees and dispatchX
        uint totalTrees = subgroupAdd(treeCount);
        uint totalWorkgroups = subgroupAdd(workgroupsForCell);
        atomicAdd(totalVisibleTrees, totalTrees);
        atomicAdd(dispatchX, totalWorkgroups);
    }
    baseIdx = subgroupBroadcastFirst(baseIdx);
    uint visibleIdx = baseIdx + laneOffset;

    // Store cell index with bucket info encoded
    visibleCellIndices[visibleIdx] = (bucket << 29) | (cellIdx & 0x1FFFFFFF);
}

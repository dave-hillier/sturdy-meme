#version 450

// Irradiance LUT Compute Shader (Phase 4.1.9)
// Precomputes scattered Rayleigh and Mie irradiance *before* phase function multiplication
// These LUTs are used for lighting clouds and haze (Ghost of Tsushima technique)
//
// Output format:
// - Rayleigh LUT: RGB = scattered Rayleigh light (without phase function)
// - Mie LUT: RGB = scattered Mie light (without phase function)
//
// Indexed by:
// - X: cosine of sun zenith angle (cosSunZenith) mapped from [-1, 1] to [0, 1]
// - Y: normalized altitude from 0 to atmosphere height

#extension GL_GOOGLE_include_directive : require

#include "atmosphere_common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

// Output images: separate Rayleigh and Mie irradiance LUTs
layout(binding = 0, rgba16f) writeonly uniform image2D rayleighIrradianceLUT;
layout(binding = 1, rgba16f) writeonly uniform image2D mieIrradianceLUT;

// Input: transmittance LUT for sun visibility
layout(binding = 2) uniform sampler2D transmittanceLUT;

layout(binding = 3) uniform AtmosphereUniforms {
    AtmosphereParams params;
    vec4 sunDirection;
    vec4 cameraPosition;
    float padding[2];
} uAtmosphere;

// Integration settings
const int HEMISPHERE_SAMPLES = 64;  // Number of hemisphere samples for irradiance
const int MARCH_STEPS = 32;         // Steps along each ray

// Sample transmittance LUT
vec3 SampleTransmittance(float r, float mu) {
    vec2 uv = TransmittanceLUTParamsToUV(r, mu, uAtmosphere.params);
    return texture(transmittanceLUT, uv).rgb;
}

// Compute irradiance at a given altitude and sun angle
// Returns separate Rayleigh and Mie contributions without phase functions
// This allows clouds to apply their own phase function when sampling
void ComputeIrradiance(float altitude, float cosSunZenith,
                       out vec3 rayleighIrradiance, out vec3 mieIrradiance) {
    rayleighIrradiance = vec3(0.0);
    mieIrradiance = vec3(0.0);

    // Position at this altitude, looking up
    float r = uAtmosphere.params.planetRadius + altitude;
    vec3 pos = vec3(0.0, r, 0.0);
    vec3 up = vec3(0.0, 1.0, 0.0);

    // Sun direction from zenith angle
    float sinSunZenith = sqrt(max(0.0, 1.0 - cosSunZenith * cosSunZenith));
    vec3 sunDir = vec3(sinSunZenith, cosSunZenith, 0.0);

    // Sample directions over the hemisphere to integrate irradiance
    // We integrate inscattered light from all directions to get total irradiance
    for (int s = 0; s < HEMISPHERE_SAMPLES; s++) {
        vec2 xi = Hammersley(uint(s), uint(HEMISPHERE_SAMPLES));
        // Cosine-weighted hemisphere for better importance sampling
        vec3 sampleDir = CosineHemisphere(xi);

        // Orient sample direction upward (hemisphere above the point)
        // For altitude sampling, we want light from above
        if (sampleDir.y < 0.0) {
            sampleDir.y = -sampleDir.y;
        }

        // Ray march along this direction to accumulate inscattered light
        float viewZenith = dot(up, sampleDir);
        float rayLength = DistanceToAtmosphereBoundary(r, viewZenith, uAtmosphere.params.atmosphereRadius);

        // Check for planet intersection (below horizon)
        if (RayIntersectsPlanet(r, viewZenith, uAtmosphere.params.planetRadius)) {
            float toPlanet = DistanceToPlanetSurface(r, viewZenith, uAtmosphere.params.planetRadius);
            if (toPlanet > 0.0) {
                rayLength = min(rayLength, toPlanet);
            }
        }

        float stepSize = rayLength / float(MARCH_STEPS);

        vec3 rayRayleigh = vec3(0.0);
        vec3 rayMie = vec3(0.0);
        vec3 transmittance = vec3(1.0);

        for (int i = 0; i < MARCH_STEPS; i++) {
            float t = (float(i) + 0.5) * stepSize;
            vec3 samplePos = pos + sampleDir * t;
            float sampleR = length(samplePos);
            float sampleAlt = max(sampleR - uAtmosphere.params.planetRadius, 0.0);

            // Get atmospheric density at sample point
            vec3 density = GetAtmosphereDensity(sampleAlt, uAtmosphere.params);

            // Scattering coefficients
            vec3 rayleighScatter = density.x * uAtmosphere.params.rayleighScatteringBase;
            vec3 mieScatter = vec3(density.y * uAtmosphere.params.mieScatteringBase);

            // Extinction for this segment
            vec3 mieAbsorption = vec3(density.y * uAtmosphere.params.mieAbsorptionBase);
            vec3 ozoneAbsorption = density.z * uAtmosphere.params.ozoneAbsorption;
            vec3 extinction = rayleighScatter + mieScatter + mieAbsorption + ozoneAbsorption;

            // Transmittance from sample point to sun
            float muSun = dot(normalize(samplePos), sunDir);
            vec3 sunTransmittance = vec3(0.0);

            // Only accumulate if sun is visible from this point
            if (muSun > -0.2 && !RayIntersectsPlanet(sampleR, muSun, uAtmosphere.params.planetRadius)) {
                sunTransmittance = SampleTransmittance(sampleR, muSun);
            }

            // Inscattered light at this sample (without phase function)
            // The phase function will be applied when sampling the LUT for clouds
            vec3 rayleighInscatter = sunTransmittance * rayleighScatter;
            vec3 mieInscatter = sunTransmittance * mieScatter;

            // Segment transmittance
            vec3 segmentTransmittance = exp(-extinction * stepSize);

            // Energy-conserving accumulation
            // The (1 - T_segment) / extinction term handles the integral properly
            vec3 scatterIntegral = (vec3(1.0) - segmentTransmittance) / max(extinction, vec3(0.0001));

            rayRayleigh += transmittance * rayleighInscatter * scatterIntegral;
            rayMie += transmittance * mieInscatter * scatterIntegral;

            transmittance *= segmentTransmittance;
        }

        // Weight by solid angle (cosine-weighted sampling already accounts for cosine term)
        float weight = 2.0 * PI / float(HEMISPHERE_SAMPLES);
        rayleighIrradiance += rayRayleigh * weight;
        mieIrradiance += rayMie * weight;
    }

    // Apply solar irradiance
    rayleighIrradiance *= uAtmosphere.params.solarIrradiance;
    mieIrradiance *= uAtmosphere.params.solarIrradiance;
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lutSize = imageSize(rayleighIrradianceLUT);

    if (texel.x >= lutSize.x || texel.y >= lutSize.y) {
        return;
    }

    // UV coordinates [0, 1]
    vec2 uv = (vec2(texel) + 0.5) / vec2(lutSize);

    // X: cosine of sun zenith angle [-1, 1]
    // Y: normalized altitude [0, 1]
    float cosSunZenith = uv.x * 2.0 - 1.0;
    float altitude = uv.y * (uAtmosphere.params.atmosphereRadius - uAtmosphere.params.planetRadius);

    // Compute separate Rayleigh and Mie irradiance
    vec3 rayleighIrr, mieIrr;
    ComputeIrradiance(altitude, cosSunZenith, rayleighIrr, mieIrr);

    // Store in separate LUTs
    imageStore(rayleighIrradianceLUT, texel, vec4(rayleighIrr, 1.0));
    imageStore(mieIrradianceLUT, texel, vec4(mieIrr, 1.0));
}

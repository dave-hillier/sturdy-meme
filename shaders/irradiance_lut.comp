#version 450

// Irradiance LUT Compute Shader (Phase 4.1.9)
// Precomputes scattered Rayleigh and Mie irradiance *before* phase function multiplication
// These LUTs are used for lighting clouds and haze (Ghost of Tsushima technique)
//
// Output format:
// - Rayleigh LUT: RGB = scattered Rayleigh light (without phase function)
// - Mie LUT: RGB = scattered Mie light (without phase function)
//
// Indexed by:
// - X: cosine of sun zenith angle (cosSunZenith) mapped from [-1, 1] to [0, 1]
// - Y: normalized altitude from 0 to atmosphere height

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "atmosphere_common.glsl"
#include "lut_compute_common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

// Output images: separate Rayleigh and Mie irradiance LUTs
layout(binding = BINDING_IRRADIANCE_RAYLEIGH_OUT, rgba16f) writeonly uniform image2D rayleighIrradianceLUT;
layout(binding = BINDING_IRRADIANCE_MIE_OUT, rgba16f) writeonly uniform image2D mieIrradianceLUT;

// Input: transmittance LUT for sun visibility
layout(binding = BINDING_IRRADIANCE_TRANSMITTANCE) uniform sampler2D transmittanceLUT;

layout(binding = BINDING_IRRADIANCE_UNIFORMS) uniform AtmosphereUniforms {
    AtmosphereParams params;
    vec4 toSunDirection;
    vec4 cameraPosition;
    float atmoPadding0;
    float atmoPadding1;
} uAtmosphere;

// Integration settings
const int HEMISPHERE_SAMPLES = 64;  // Number of hemisphere samples for irradiance
const int MARCH_STEPS = 32;         // Steps along each ray

// Compute irradiance at a given altitude and sun angle
// Returns separate Rayleigh and Mie contributions without phase functions
// This allows clouds to apply their own phase function when sampling
void ComputeIrradiance(float altitude, float cosSunZenith,
                       out vec3 rayleighIrradiance, out vec3 mieIrradiance) {
    rayleighIrradiance = vec3(0.0);
    mieIrradiance = vec3(0.0);

    // Position at this altitude, looking up
    float r = uAtmosphere.params.planetRadius + altitude;
    vec3 pos = vec3(0.0, r, 0.0);
    vec3 up = vec3(0.0, 1.0, 0.0);

    // Sun direction from zenith angle
    vec3 sunDir = sunDirFromZenithCos(cosSunZenith);

    // Sample directions over the hemisphere to integrate irradiance
    // We integrate inscattered light from all directions to get total irradiance
    for (int s = 0; s < HEMISPHERE_SAMPLES; s++) {
        vec2 xi = Hammersley(uint(s), uint(HEMISPHERE_SAMPLES));
        // Cosine-weighted hemisphere for better importance sampling
        vec3 sampleDir = CosineHemisphere(xi);

        // Orient sample direction upward (hemisphere above the point)
        // For altitude sampling, we want light from above
        if (sampleDir.y < 0.0) {
            sampleDir.y = -sampleDir.y;
        }

        // Ray march along this direction to accumulate inscattered light
        float viewZenith = dot(up, sampleDir);
        float rayLength = DistanceToAtmosphereBoundary(r, viewZenith, uAtmosphere.params.atmosphereRadius);

        // Check for planet intersection (below horizon)
        if (RayIntersectsPlanet(r, viewZenith, uAtmosphere.params.planetRadius)) {
            float toPlanet = DistanceToPlanetSurface(r, viewZenith, uAtmosphere.params.planetRadius);
            if (toPlanet > 0.0) {
                rayLength = min(rayLength, toPlanet);
            }
        }

        float stepSize = rayLength / float(MARCH_STEPS);

        vec3 rayRayleigh = vec3(0.0);
        vec3 rayMie = vec3(0.0);
        vec3 transmittance = vec3(1.0);

        for (int i = 0; i < MARCH_STEPS; i++) {
            float t = rayMarchStepT(i, stepSize);
            vec3 samplePos = pos + sampleDir * t;
            float sampleR = length(samplePos);
            float sampleAlt = radiusToAltitude(sampleR, uAtmosphere.params.planetRadius);

            // Get atmospheric density and scattering at sample point
            vec3 density = GetAtmosphereDensity(sampleAlt, uAtmosphere.params);
            vec3 rayleighScatter, mieScatter;
            computeScattering(density, uAtmosphere.params, rayleighScatter, mieScatter);

            // Extinction for this segment
            vec3 extinction = computeExtinction(density, uAtmosphere.params);

            // Transmittance from sample point to sun
            float muSun = dot(normalize(samplePos), sunDir);
            vec3 sunTransmittance = vec3(0.0);

            // Only accumulate if sun is visible from this point
            if (muSun > -0.2 && !RayIntersectsPlanet(sampleR, muSun, uAtmosphere.params.planetRadius)) {
                sunTransmittance = sampleTransmittanceLUT(transmittanceLUT, sampleR, muSun, uAtmosphere.params);
            }

            // Inscattered light at this sample (without phase function)
            // The phase function will be applied when sampling the LUT for clouds
            vec3 rayleighInscatter = sunTransmittance * rayleighScatter;
            vec3 mieInscatter = sunTransmittance * mieScatter;

            // Segment transmittance
            vec3 segmentTransmittance = exp(-extinction * stepSize);

            // Energy-conserving accumulation
            // The (1 - T_segment) / extinction term handles the integral properly
            vec3 scatterIntegral = (vec3(1.0) - segmentTransmittance) / max(extinction, vec3(0.0001));

            rayRayleigh += transmittance * rayleighInscatter * scatterIntegral;
            rayMie += transmittance * mieInscatter * scatterIntegral;

            transmittance *= segmentTransmittance;
        }

        // Weight by solid angle (cosine-weighted sampling already accounts for cosine term)
        float weight = 2.0 * PI / float(HEMISPHERE_SAMPLES);
        rayleighIrradiance += rayRayleigh * weight;
        mieIrradiance += rayMie * weight;
    }

    // Apply solar irradiance
    rayleighIrradiance *= uAtmosphere.params.solarIrradiance;
    mieIrradiance *= uAtmosphere.params.solarIrradiance;
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lutSize = imageSize(rayleighIrradianceLUT);

    if (isOutOfBounds(texel, lutSize)) {
        return;
    }

    vec2 uv = texelToUV(texel, lutSize);

    // Decode altitude and sun angle from UV
    float altitude, cosSunZenith;
    decodeAltitudeSunAngleLUT(uv, uAtmosphere.params, altitude, cosSunZenith);

    // Compute separate Rayleigh and Mie irradiance
    vec3 rayleighIrr, mieIrr;
    ComputeIrradiance(altitude, cosSunZenith, rayleighIrr, mieIrr);

    // Store in separate LUTs
    imageStore(rayleighIrradianceLUT, texel, vec4(rayleighIrr, 1.0));
    imageStore(mieIrradianceLUT, texel, vec4(mieIrr, 1.0));
}

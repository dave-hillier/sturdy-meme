#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Leaf instance output - matches C++ struct
struct LeafInstance {
    vec4 position;      // xyz = world position, w = size
    vec4 facing;        // xy = facing direction, z = hash, w = flutter
    vec4 color;         // rgb = color tint, a = alpha (stores clumpId in unused w)
    uvec4 metadata;     // x = tree index, y = flags, z = clumpId bits, w = unused
};

struct DrawIndirectCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

// Tree definition - matches C++ struct (std430 layout)
struct TreeDefinition {
    // Trunk parameters (offset 0-15)
    float trunkHeight;
    float trunkRadius;
    float trunkTaper;
    float trunkBend;

    // Branching parameters (offset 16-39)
    uint branchLevels;
    float branchAngle;
    float branchSpread;
    float branchLengthRatio;
    float branchRadiusRatio;
    uint branchesPerLevel;

    // Padding to align vec3 to 16-byte boundary (offset 40-47)
    float _padding1[2];

    // Canopy parameters (vec3 aligned to 16 bytes)
    vec3 canopyCenter;      // offset 48
    float _padding2;        // offset 60
    vec3 canopyExtent;      // offset 64
    float leafDensity;      // offset 76
    float leafSize;         // offset 80
    float leafSizeVariance; // offset 84

    // Animation parameters (offset 88-95)
    float windInfluence;
    float branchStiffness;

    // Visual parameters (offset 96-103)
    uint leafPaletteIndex;
    uint barkTextureIndex;

    // Final padding (offset 104-111)
    float padding[2];
};

// Tree instance - matches C++ struct
struct TreeInstance {
    vec3 position;
    float rotation;
    float scale;
    float age;
    uint definitionIndex;
    float hash;
};

layout(std430, binding = 0) buffer LeafBuffer {
    LeafInstance leaves[];
};

layout(std430, binding = 1) buffer IndirectBuffer {
    DrawIndirectCommand drawCmd;
};

layout(binding = 2) uniform TreeUniforms {
    vec4 cameraPosition;
    vec4 frustumPlanes[6];
    float maxDrawDistance;
    float lodTransitionStart;
    float lodTransitionEnd;
    float terrainSize;
    float terrainHeightScale;
    float time;
    uint treeCount;
    float padding;
} uniforms;

layout(std430, binding = 3) buffer DefinitionBuffer {
    TreeDefinition definitions[];
};

layout(std430, binding = 4) buffer TreeInstanceBuffer {
    TreeInstance trees[];
};

layout(binding = 5) uniform sampler2D terrainHeightMap;

layout(push_constant) uniform PushConstants {
    float time;
    int cascadeIndex;
    float padding[2];
} push;

// ============================================================================
// Hash functions
// ============================================================================
float hash(float p) {
    return fract(sin(p * 127.1) * 43758.5453);
}

float hash2(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

vec3 hash3(float p) {
    return vec3(
        hash(p),
        hash(p + 47.0),
        hash(p + 103.0)
    );
}

vec3 hash3v(vec3 p) {
    return vec3(
        fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453),
        fract(sin(dot(p, vec3(269.5, 183.3, 246.1))) * 43758.5453),
        fract(sin(dot(p, vec3(113.5, 271.9, 124.6))) * 43758.5453)
    );
}

// ============================================================================
// 3D Voronoi for clump calculation (Milestone 5)
// ============================================================================
struct VoronoiResult {
    float clumpId;      // Unique ID for the clump (0-1)
    float clumpDist;    // Distance to clump center
    vec3 clumpCenter;   // Position of clump center
};

VoronoiResult calculateVoronoi3D(vec3 worldPos, float clumpScale) {
    vec3 scaledPos = worldPos / clumpScale;
    vec3 cellId = floor(scaledPos);

    float minDist = 10.0;
    vec3 nearestPoint = vec3(0.0);
    float nearestId = 0.0;

    // Check 3x3x3 neighborhood
    for (int z = -1; z <= 1; z++) {
        for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
                vec3 neighborCell = cellId + vec3(x, y, z);

                // Jittered point within cell
                vec3 jitter = hash3v(neighborCell) * 0.8 + 0.1;
                vec3 clumpPoint = (neighborCell + jitter) * clumpScale;

                float dist = length(worldPos - clumpPoint);
                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = clumpPoint;
                    nearestId = hash2(neighborCell.xy + neighborCell.z * 17.0);
                }
            }
        }
    }

    VoronoiResult result;
    result.clumpId = nearestId;
    result.clumpDist = minDist;
    result.clumpCenter = nearestPoint;
    return result;
}

// Multi-scale Voronoi clumping
struct MultiScaleClump {
    float largeClumpId;     // 1-2m scale - major light/dark regions
    float mediumClumpId;    // 0.3-0.5m scale - visible clusters
    float smallClumpId;     // 0.1m scale - fine variation
    float combinedId;       // Weighted combination
    vec3 nearestClumpCenter;
    float clumpDensity;     // Local density modifier
};

MultiScaleClump calculateMultiScaleClumping(vec3 worldPos, float treeScale) {
    MultiScaleClump result;

    // Large scale clumping (major canopy regions)
    VoronoiResult large = calculateVoronoi3D(worldPos, 1.5 * treeScale);
    result.largeClumpId = large.clumpId;

    // Medium scale (visible leaf clusters)
    VoronoiResult medium = calculateVoronoi3D(worldPos, 0.4 * treeScale);
    result.mediumClumpId = medium.clumpId;

    // Small scale (fine variation)
    VoronoiResult small = calculateVoronoi3D(worldPos, 0.12 * treeScale);
    result.smallClumpId = small.clumpId;

    // Combine scales with different weights
    result.combinedId = result.largeClumpId * 0.5 +
                        result.mediumClumpId * 0.3 +
                        result.smallClumpId * 0.2;

    result.nearestClumpCenter = medium.clumpCenter;

    // Density varies by clump - some clumps are denser than others
    result.clumpDensity = 0.6 + result.mediumClumpId * 0.8;

    return result;
}

// ============================================================================
// Terrain sampling
// ============================================================================
float sampleTerrainHeight(vec2 worldXZ) {
    vec2 uv = worldXZ / uniforms.terrainSize + 0.5;
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        return 0.0;
    }
    float h = texture(terrainHeightMap, uv).r;
    return (h - 0.5) * uniforms.terrainHeightScale;
}

// ============================================================================
// Frustum culling
// ============================================================================
bool isInFrustum(vec3 pos, float radius) {
    vec4 p = vec4(pos, 1.0);
    for (int i = 0; i < 6; i++) {
        if (dot(p, uniforms.frustumPlanes[i]) < -radius) {
            return false;
        }
    }
    return true;
}

// ============================================================================
// Color palette based on clump (Milestone 6 preview)
// ============================================================================
vec3 getLeafColorFromClump(MultiScaleClump clump, float depthInCanopy, float verticalPos) {
    // Base green palette
    vec3 baseGreen = vec3(0.2, 0.5, 0.15);

    // Hue variation based on large clump (yellow-green to blue-green)
    float hueShift = (clump.largeClumpId - 0.5) * 0.15;
    vec3 hueVariedColor = baseGreen + vec3(-hueShift, 0.0, hueShift);

    // Saturation variation based on medium clump
    float satMod = 0.9 + clump.mediumClumpId * 0.2;
    float luminance = dot(hueVariedColor, vec3(0.299, 0.587, 0.114));
    hueVariedColor = mix(vec3(luminance), hueVariedColor, satMod);

    // Value (brightness) based on vertical position and depth
    // Top leaves are brighter, interior leaves are darker
    float brightness = mix(0.7, 1.2, verticalPos * 0.5 + 0.5);
    brightness *= mix(1.0, 0.6, depthInCanopy);  // Darker toward center

    // Small-scale variation adds fine detail
    float fineVar = (clump.smallClumpId - 0.5) * 0.1;

    vec3 finalColor = hueVariedColor * brightness + vec3(fineVar);

    return clamp(finalColor, vec3(0.05), vec3(0.8));
}

// ============================================================================
// Main leaf generation
// ============================================================================
void generateLeavesForTree(uint treeIndex) {
    TreeInstance tree = trees[treeIndex];
    TreeDefinition def = definitions[tree.definitionIndex];

    // Get terrain height at tree position
    float terrainY = sampleTerrainHeight(tree.position.xz);
    vec3 treeBase = vec3(tree.position.x, terrainY, tree.position.z);

    // Calculate canopy center in world space
    float effectiveHeight = def.trunkHeight * tree.scale * tree.age;
    vec3 canopyCenter = treeBase + vec3(0.0, effectiveHeight * 0.8, 0.0) + def.canopyCenter * tree.scale;
    vec3 canopyExtent = def.canopyExtent * tree.scale * tree.age;

    // Distance to camera for LOD
    float distToCamera = length(canopyCenter - uniforms.cameraPosition.xyz);

    // Skip if too far
    if (distToCamera > uniforms.maxDrawDistance) return;

    // Frustum cull the whole canopy
    float canopyRadius = max(canopyExtent.x, max(canopyExtent.y, canopyExtent.z));
    if (!isInFrustum(canopyCenter, canopyRadius)) return;

    // LOD - reduce leaf count at distance (Milestone 8)
    float lodFactor = smoothstep(uniforms.lodTransitionStart, uniforms.lodTransitionEnd, distToCamera);

    // Multi-tier LOD with smooth probability transitions
    // Near (0-50m): Full density, small leaves
    // Medium (50-150m): 60% density, medium leaves
    // Far (150-300m): 30% density, large leaves
    float densityMult = 1.0;
    float sizeMult = 1.0;

    if (distToCamera > 150.0) {
        densityMult = 0.3;
        sizeMult = 2.0;
    } else if (distToCamera > 50.0) {
        float t = smoothstep(50.0, 150.0, distToCamera);
        densityMult = mix(0.6, 0.3, t);
        sizeMult = mix(1.3, 2.0, t);
    } else {
        float t = smoothstep(0.0, 50.0, distToCamera);
        densityMult = mix(1.0, 0.6, t);
        sizeMult = mix(1.0, 1.3, t);
    }

    // Screen-space size culling - approximate projected leaf size
    // Assumes ~60 degree FOV, 1080p resolution
    float screenLeafSize = (def.leafSize * tree.scale * sizeMult) / distToCamera * 1000.0;
    const float MIN_SCREEN_PIXELS = 1.5;  // Skip if less than 1.5 pixels

    // Skip entire tree if leaves would be sub-pixel
    if (screenLeafSize < MIN_SCREEN_PIXELS) return;

    // Number of leaves based on density and canopy volume
    float canopyVolume = canopyExtent.x * canopyExtent.y * canopyExtent.z * 4.19; // ~4/3 pi
    uint maxLeaves = uint(def.leafDensity * canopyVolume * densityMult);
    maxLeaves = min(maxLeaves, 500u);  // Cap per tree

    // Generate leaves using golden ratio spiral for even distribution
    for (uint i = 0; i < maxLeaves; i++) {
        // Golden ratio spiral for spherical distribution
        float phi = float(i) * 2.39996; // Golden angle in radians
        float cosTheta = 1.0 - 2.0 * (float(i) + 0.5) / float(maxLeaves);
        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

        // Position on unit sphere
        vec3 unitPos = vec3(
            sinTheta * cos(phi),
            cosTheta,
            sinTheta * sin(phi)
        );

        // Per-leaf hash for variation
        float leafHash = hash(tree.hash * 1000.0 + float(i));
        vec3 jitter = hash3(tree.hash * 2000.0 + float(i)) * 2.0 - 1.0;

        // Random radius within canopy (bias toward outer region)
        float radiusFactor = 0.3 + leafHash * 0.7;
        radiusFactor = sqrt(radiusFactor); // Bias toward surface

        // Position within canopy ellipsoid
        vec3 localPos = unitPos * canopyExtent * radiusFactor + jitter * 0.15 * tree.scale;
        vec3 worldPos = canopyCenter + localPos;

        // Calculate Voronoi clumping at this position
        MultiScaleClump clump = calculateMultiScaleClumping(worldPos, tree.scale);

        // Clump-based density culling
        float effectiveDensity = baseDensityMult * clump.clumpDensity;
        if (hash(leafHash * 100.0 + clump.mediumClumpId * 50.0) > effectiveDensity) continue;

        // Ellipsoid boundary check with soft falloff
        float ellipsoidDist = length(localPos / canopyExtent);
        if (ellipsoidDist > 1.0) continue;

        // Density falloff toward edge
        float edgeFalloff = 1.0 - smoothstep(0.7, 1.0, ellipsoidDist);
        if (hash(leafHash * 200.0) > edgeFalloff) continue;

        // Facing direction influenced by clump center
        vec3 toClumpCenter = normalize(clump.nearestClumpCenter - worldPos);
        vec3 randomFacing = normalize(hash3(leafHash * 300.0) - 0.5);
        vec3 clumpInfluencedFacing = normalize(mix(randomFacing, -toClumpCenter, 0.4));
        vec2 facingDir = normalize(clumpInfluencedFacing.xz);

        // Leaf size with clump-based variation (Milestone 8)
        float baseSize = def.leafSize * tree.scale;
        float clumpSizeMod = 0.8 + clump.mediumClumpId * 0.4;  // Clumps have similar sizes
        float individualVar = 1.0 + (leafHash - 0.5) * def.leafSizeVariance * 0.5;
        float leafSize = baseSize * clumpSizeMod * individualVar;

        // Apply LOD size multiplier to maintain screen coverage at distance
        leafSize *= sizeMult;

        // Color from clump system
        float depthInCanopy = 1.0 - radiusFactor;
        float verticalPos = localPos.y / canopyExtent.y;
        vec3 leafColor = getLeafColorFromClump(clump, depthInCanopy, verticalPos);

        // Allocate leaf slot
        uint slot = atomicAdd(drawCmd.instanceCount, 1);

        // Limit to buffer size
        if (slot >= 100000) {
            atomicAdd(drawCmd.instanceCount, 0xFFFFFFFF); // Decrement back
            return;
        }

        // Flutter amount - outer leaves and certain clumps flutter more
        float baseFlutter = (1.0 - depthInCanopy) * 0.4 + 0.1;
        float clumpFlutter = clump.smallClumpId * 0.3;  // Some clumps are flutterier
        float flutter = baseFlutter + clumpFlutter;

        // Wind phase offset based on clump (leaves in same clump move together)
        float windPhase = clump.mediumClumpId * 6.28318 + leafHash * 0.5;

        // Write leaf data
        leaves[slot].position = vec4(worldPos, leafSize);
        leaves[slot].facing = vec4(facingDir, windPhase, flutter);
        leaves[slot].color = vec4(leafColor, 1.0);
        leaves[slot].metadata = uvec4(treeIndex, 0, floatBitsToUint(clump.combinedId), 0);
    }
}

void main() {
    uint treeIndex = gl_GlobalInvocationID.x;

    // Set vertex count for triangle list (6 verts per leaf quad)
    if (treeIndex == 0) {
        atomicMax(drawCmd.vertexCount, 6);
    }

    if (treeIndex >= uniforms.treeCount) return;

    generateLeavesForTree(treeIndex);
}

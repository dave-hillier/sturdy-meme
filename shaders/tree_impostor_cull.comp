#version 450

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "instancing_common.glsl"

// Workgroup size: 256 threads per workgroup
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input: All trees in the scene (uploaded once when trees change)
struct TreeInputData {
    vec4 positionAndScale;    // xyz = world position, w = scale
    vec4 rotationAndArchetype; // x = Y-axis rotation, yzw = archetype index as uint bits
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_INPUT) readonly buffer InputBuffer {
    TreeInputData trees[];
};

// Output: Visible impostor instances (GPU-generated each frame)
struct ImpostorOutputData {
    vec4 positionAndScale;     // xyz = world position, w = scale
    vec4 rotationAndArchetype; // x = rotation, y = archetype, z = blend factor, w = reserved
    vec4 sizeAndOffset;        // x = hSize, y = vSize, z = baseOffset, w = reserved
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_OUTPUT) writeonly buffer OutputBuffer {
    ImpostorOutputData visibleImpostors[];
};

// Single indirect draw command for ALL visible impostors
layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmd;
};

// Culling uniforms
layout(binding = BINDING_TREE_IMPOSTOR_CULL_UNIFORMS) uniform ImpostorCullUniforms {
    vec4 cameraPosition;           // xyz = camera pos, w = unused
    vec4 frustumPlanes[6];         // Frustum planes for culling
    mat4 viewProjMatrix;           // View-projection matrix for Hi-Z testing
    vec4 screenParams;             // x = width, y = height, z = 1/width, w = 1/height
    float fullDetailDistance;      // Trees closer than this render as geometry
    float impostorDistance;        // Trees beyond this are culled
    float hysteresis;              // Hysteresis for LOD transitions
    float blendRange;              // Distance over which to blend LODs
    uint numTrees;                 // Total number of trees
    uint enableHiZ;                // 1 = enable Hi-Z culling, 0 = frustum only
    uint useScreenSpaceError;      // 1 = use screen-space error LOD, 0 = distance-based
    float tanHalfFOV;              // tan(fov/2) for screen-space error calculation
    float errorThresholdFull;      // Screen error threshold for full detail (pixels)
    float errorThresholdImpostor;  // Screen error threshold for impostor (pixels)
    float errorThresholdCull;      // Screen error beyond which to cull
    uint temporalUpdateMode;       // 0=full, 1=partial, 2=skip (Phase 5: Temporal Coherence)
    uint temporalUpdateOffset;     // For partial: start index of trees to update
    uint temporalUpdateCount;      // For partial: number of trees to update this frame
    uint _pad0;
};

// Hi-Z pyramid for occlusion culling
layout(binding = BINDING_TREE_IMPOSTOR_CULL_HIZ) uniform sampler2D hiZPyramid;

// Visibility cache for temporal coherence (Phase 5)
// Packed bits: 1 = was visible as impostor last frame, 0 = was culled or rendered as geometry
layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_VISIBILITY) buffer VisibilityCache {
    uint visibilityBits[];
};

// Per-archetype sizing data
struct ArchetypeData {
    vec4 sizingData;   // x = hSize, y = vSize, z = baseOffset, w = boundingSphereRadius
    vec4 lodErrorData; // x = worldErrorFull, y = worldErrorImpostor, z = unused, w = unused
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_ARCHETYPE) readonly buffer ArchetypeBuffer {
    ArchetypeData archetypes[];
};

// Compute screen-space error from world-space error
// Formula: screenError = worldError * screenHeight / (2 * distance * tan(fov/2))
float computeScreenError(float worldError, float distance) {
    if (distance <= 0.0) return 9999.0; // Infinite error at zero distance
    return worldError * screenParams.y / (2.0 * distance * tanHalfFOV);
}

// Hi-Z occlusion test
// Returns true if the object is occluded (not visible)
bool isOccludedHiZ(vec3 worldPos, float boundingRadius) {
    // Project tree center to clip space
    vec4 clipPos = viewProjMatrix * vec4(worldPos, 1.0);

    // Skip if behind camera
    if (clipPos.w <= 0.0) {
        return true;  // Behind camera, treat as occluded
    }

    // Convert to NDC
    vec3 ndc = clipPos.xyz / clipPos.w;

    // Skip if outside NDC range (should be caught by frustum culling, but double check)
    if (abs(ndc.x) > 1.0 || abs(ndc.y) > 1.0 || ndc.z < 0.0 || ndc.z > 1.0) {
        return false;  // Outside screen, let frustum culling handle it
    }

    // Convert to UV coordinates [0,1]
    vec2 screenUV = ndc.xy * 0.5 + 0.5;

    // Calculate screen-space radius for mip level selection
    // Project a point offset by boundingRadius to estimate screen coverage
    float screenRadius = boundingRadius / clipPos.w * screenParams.x * 0.5;

    // Choose mip level based on screen-space size
    // Use a conservative (higher) mip level to avoid false culling
    float mipLevel = max(0.0, log2(max(screenRadius * 2.0, 1.0)));

    // Clamp to valid mip range (assume max 12 levels for 4K)
    mipLevel = min(mipLevel, 11.0);

    // Sample Hi-Z at appropriate mip (returns MIN depth in the region)
    // Hi-Z uses reversed-Z: 0 = far, 1 = near
    // Min = farthest visible point in the region
    float occluderDepth = textureLod(hiZPyramid, screenUV, mipLevel).r;

    // Calculate conservative depth for tree (use back of bounding sphere - farthest point)
    // In reversed-Z, we want the farthest point of the tree to compare against
    // the farthest visible occluder point
    vec3 toCamera = normalize(cameraPosition.xyz - worldPos);
    vec3 farthestPoint = worldPos - toCamera * boundingRadius;  // Point away from camera
    vec4 farthestClip = viewProjMatrix * vec4(farthestPoint, 1.0);
    float treeDepth = farthestClip.z / farthestClip.w;

    // Tree is occluded if its farthest point is farther than the farthest visible occluder
    // In reversed-Z: smaller depth = farther
    // Add small margin to account for precision issues
    float depthMargin = 0.001;
    return treeDepth < occluderDepth - depthMargin;
}

// Helper functions for visibility cache bit manipulation
bool getVisibilityCached(uint treeIdx) {
    uint wordIdx = treeIdx / 32u;
    uint bitIdx = treeIdx % 32u;
    return (visibilityBits[wordIdx] & (1u << bitIdx)) != 0u;
}

void setVisibilityCached(uint treeIdx, bool visible) {
    uint wordIdx = treeIdx / 32u;
    uint bitIdx = treeIdx % 32u;
    if (visible) {
        atomicOr(visibilityBits[wordIdx], 1u << bitIdx);
    } else {
        atomicAnd(visibilityBits[wordIdx], ~(1u << bitIdx));
    }
}

void main() {
    uint treeIdx = gl_GlobalInvocationID.x;

    // First thread initializes the indirect command (constant values)
    if (treeIdx == 0) {
        drawCmd.indexCount = 6;       // Billboard quad: 6 indices
        drawCmd.firstIndex = 0;
        drawCmd.vertexOffset = 0;
        drawCmd.firstInstance = 0;
        // instanceCount is set via atomicAdd below
    }

    // Early exit if beyond tree count
    if (treeIdx >= numTrees) {
        return;
    }

    // Phase 5: Temporal Coherence
    // temporalUpdateMode: 0=full (recompute all), 1=partial (update subset), 2=skip (use cache)
    bool needsCullingUpdate = true;

    if (temporalUpdateMode == 2u) {
        // Skip mode: camera stationary, use cached visibility entirely
        needsCullingUpdate = false;
    } else if (temporalUpdateMode == 1u) {
        // Partial mode: only update trees in the specified range
        needsCullingUpdate = (treeIdx >= temporalUpdateOffset &&
                              treeIdx < temporalUpdateOffset + temporalUpdateCount);
    }
    // temporalUpdateMode == 0: full update, needsCullingUpdate stays true

    // Load tree data (always needed for output if visible)
    TreeInputData tree = trees[treeIdx];
    vec3 treePos = tree.positionAndScale.xyz;
    float treeScale = tree.positionAndScale.w;
    float rotation = tree.rotationAndArchetype.x;
    uint archetypeIndex = floatBitsToUint(tree.rotationAndArchetype.y);

    // Get archetype sizing data
    ArchetypeData arch = archetypes[archetypeIndex];
    float boundingRadius = arch.sizingData.w * treeScale;
    float vSize = arch.sizingData.y * treeScale;  // Vertical half-size

    bool isVisible = false;
    float blendFactor = 1.0;

    if (needsCullingUpdate) {
        // Full culling computation
        float distToCamera = getDistanceToCamera(treePos, cameraPosition.xyz);

        // LOD selection - either screen-space error or distance-based
        bool shouldRenderAsImpostor = false;
        bool shouldCull = false;

        if (useScreenSpaceError != 0u) {
            // Screen-space error LOD (Phase 4)
            float worldErrorFull = arch.lodErrorData.x * treeScale;
            float worldErrorImpostor = arch.lodErrorData.y * treeScale;

            float screenErrorFull = computeScreenError(worldErrorFull, distToCamera);
            float screenErrorImpostor = computeScreenError(worldErrorImpostor, distToCamera);

            if (screenErrorFull <= errorThresholdFull) {
                // Tree is close enough for full detail - skip impostor
                setVisibilityCached(treeIdx, false);
                return;
            } else if (screenErrorImpostor > errorThresholdCull) {
                shouldCull = true;
            } else {
                shouldRenderAsImpostor = true;
            }
        } else {
            // Legacy distance-based LOD
            if (distToCamera < fullDetailDistance - hysteresis) {
                setVisibilityCached(treeIdx, false);
                return;
            }
            if (distToCamera > impostorDistance) {
                shouldCull = true;
            } else {
                shouldRenderAsImpostor = true;
            }
        }

        if (shouldCull) {
            setVisibilityCached(treeIdx, false);
            return;
        }

        // Calculate tree center
        vec3 treeCenter = treePos + vec3(0.0, vSize, 0.0);

        // Frustum culling
        float margin = boundingRadius * 2.0;
        if (!isInFrustum(frustumPlanes, treeCenter, margin)) {
            setVisibilityCached(treeIdx, false);
            return;
        }

        // Hi-Z occlusion culling
        if (enableHiZ != 0u && isOccludedHiZ(treeCenter, boundingRadius)) {
            setVisibilityCached(treeIdx, false);
            return;
        }

        // Tree passed all culling tests
        isVisible = true;
        setVisibilityCached(treeIdx, true);

        // Calculate blend factor
        if (useScreenSpaceError != 0u) {
            float worldErrorFull = arch.lodErrorData.x * treeScale;
            float screenErrorFull = computeScreenError(worldErrorFull, distToCamera);

            if (screenErrorFull < errorThresholdFull) {
                blendFactor = 0.0;
            } else if (screenErrorFull > errorThresholdImpostor) {
                blendFactor = 1.0;
            } else {
                blendFactor = smoothstep(errorThresholdFull, errorThresholdImpostor, screenErrorFull);
            }
        } else {
            float distToCamera = getDistanceToCamera(treePos, cameraPosition.xyz);
            if (distToCamera < fullDetailDistance + blendRange) {
                blendFactor = smoothstep(fullDetailDistance - hysteresis,
                                          fullDetailDistance + blendRange,
                                          distToCamera);
            }
        }
    } else {
        // Use cached visibility (skip or partial mode for non-updated trees)
        // BUT always re-check frustum to catch trees that just entered the view
        vec3 treeCenter = treePos + vec3(0.0, vSize, 0.0);
        float margin = boundingRadius * 2.0;
        bool inFrustum = isInFrustum(frustumPlanes, treeCenter, margin);

        if (!inFrustum) {
            // Tree is outside frustum - not visible regardless of cache
            isVisible = false;
        } else {
            // Tree is in frustum - check cache for occlusion/LOD status
            // If it was visible before, keep it visible
            // If it was NOT visible but is now in frustum, make it visible
            // (conservative: may show trees that would be occluded, but prevents pop-in)
            bool wasCachedVisible = getVisibilityCached(treeIdx);
            isVisible = wasCachedVisible || inFrustum;  // Show if newly in frustum

            // Update cache if we're making a tree visible that wasn't before
            if (!wasCachedVisible && isVisible) {
                setVisibilityCached(treeIdx, true);
            }
        }

        if (isVisible) {
            // Recalculate blend factor (it depends on current camera position)
            float distToCamera = getDistanceToCamera(treePos, cameraPosition.xyz);

            if (useScreenSpaceError != 0u) {
                float worldErrorFull = arch.lodErrorData.x * treeScale;
                float screenErrorFull = computeScreenError(worldErrorFull, distToCamera);

                if (screenErrorFull < errorThresholdFull) {
                    blendFactor = 0.0;
                } else if (screenErrorFull > errorThresholdImpostor) {
                    blendFactor = 1.0;
                } else {
                    blendFactor = smoothstep(errorThresholdFull, errorThresholdImpostor, screenErrorFull);
                }
            } else {
                if (distToCamera < fullDetailDistance + blendRange) {
                    blendFactor = smoothstep(fullDetailDistance - hysteresis,
                                              fullDetailDistance + blendRange,
                                              distToCamera);
                }
            }
        }
    }

    if (!isVisible) {
        return;
    }

    // This impostor is visible - atomically get output slot
    uint outputSlot = atomicAdd(drawCmd.instanceCount, 1);

    // Write visible impostor data
    visibleImpostors[outputSlot].positionAndScale = vec4(treePos, treeScale);
    visibleImpostors[outputSlot].rotationAndArchetype = vec4(
        rotation,
        float(archetypeIndex),
        blendFactor,
        0.0  // reserved
    );
    visibleImpostors[outputSlot].sizeAndOffset = vec4(
        arch.sizingData.x * treeScale,  // hSize pre-scaled
        arch.sizingData.y * treeScale,  // vSize pre-scaled
        arch.sizingData.z * treeScale,  // baseOffset pre-scaled
        0.0  // reserved
    );
}

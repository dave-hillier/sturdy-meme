#version 450

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "instancing_common.glsl"

// Workgroup size: 256 threads per workgroup
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input: All trees in the scene (uploaded once when trees change)
struct TreeInputData {
    vec4 positionAndScale;    // xyz = world position, w = scale
    vec4 rotationAndArchetype; // x = Y-axis rotation, yzw = archetype index as uint bits
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_INPUT) readonly buffer InputBuffer {
    TreeInputData trees[];
};

// Output: Visible impostor instances (GPU-generated each frame)
struct ImpostorOutputData {
    vec4 positionAndScale;     // xyz = world position, w = scale
    vec4 rotationAndArchetype; // x = rotation, y = archetype, z = blend factor, w = reserved
    vec4 sizeAndOffset;        // x = hSize, y = vSize, z = baseOffset, w = reserved
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_OUTPUT) writeonly buffer OutputBuffer {
    ImpostorOutputData visibleImpostors[];
};

// Single indirect draw command for ALL visible impostors
layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmd;
};

// Culling uniforms
layout(binding = BINDING_TREE_IMPOSTOR_CULL_UNIFORMS) uniform ImpostorCullUniforms {
    vec4 cameraPosition;           // xyz = camera pos, w = unused
    vec4 frustumPlanes[6];         // Frustum planes for culling
    mat4 viewProjMatrix;           // View-projection matrix for Hi-Z testing
    vec4 screenParams;             // x = width, y = height, z = 1/width, w = 1/height
    float fullDetailDistance;      // Trees closer than this render as geometry
    float impostorDistance;        // Trees beyond this are culled
    float hysteresis;              // Hysteresis for LOD transitions
    float blendRange;              // Distance over which to blend LODs
    uint numTrees;                 // Total number of trees
    uint enableHiZ;                // 1 = enable Hi-Z culling, 0 = frustum only
    uint _pad0;
    uint _pad1;
};

// Hi-Z pyramid for occlusion culling
layout(binding = BINDING_TREE_IMPOSTOR_CULL_HIZ) uniform sampler2D hiZPyramid;

// Per-archetype sizing data
struct ArchetypeData {
    vec4 sizingData;  // x = hSize, y = vSize, z = baseOffset, w = boundingSphereRadius
};

layout(std430, binding = BINDING_TREE_IMPOSTOR_CULL_ARCHETYPE) readonly buffer ArchetypeBuffer {
    ArchetypeData archetypes[];
};

// Hi-Z occlusion test
// Returns true if the object is occluded (not visible)
bool isOccludedHiZ(vec3 worldPos, float boundingRadius) {
    // Project tree center to clip space
    vec4 clipPos = viewProjMatrix * vec4(worldPos, 1.0);

    // Skip if behind camera
    if (clipPos.w <= 0.0) {
        return true;  // Behind camera, treat as occluded
    }

    // Convert to NDC
    vec3 ndc = clipPos.xyz / clipPos.w;

    // Skip if outside NDC range (should be caught by frustum culling, but double check)
    if (abs(ndc.x) > 1.0 || abs(ndc.y) > 1.0 || ndc.z < 0.0 || ndc.z > 1.0) {
        return false;  // Outside screen, let frustum culling handle it
    }

    // Convert to UV coordinates [0,1]
    vec2 screenUV = ndc.xy * 0.5 + 0.5;

    // Calculate screen-space radius for mip level selection
    // Project a point offset by boundingRadius to estimate screen coverage
    float screenRadius = boundingRadius / clipPos.w * screenParams.x * 0.5;

    // Choose mip level based on screen-space size
    // Use a conservative (higher) mip level to avoid false culling
    float mipLevel = max(0.0, log2(max(screenRadius * 2.0, 1.0)));

    // Clamp to valid mip range (assume max 12 levels for 4K)
    mipLevel = min(mipLevel, 11.0);

    // Sample Hi-Z at appropriate mip (returns max depth in the region)
    float occluderDepth = textureLod(hiZPyramid, screenUV, mipLevel).r;

    // Calculate conservative depth for tree (use front of bounding sphere)
    // Project the closest point of the bounding sphere
    vec3 toCamera = normalize(cameraPosition.xyz - worldPos);
    vec3 closestPoint = worldPos + toCamera * boundingRadius;
    vec4 closestClip = viewProjMatrix * vec4(closestPoint, 1.0);
    float treeDepth = closestClip.z / closestClip.w;

    // Convert to [0,1] depth range (Vulkan uses [0,1] NDC depth)
    treeDepth = treeDepth * 0.5 + 0.5;

    // Tree is occluded if its closest depth is greater than the occluder's max depth
    // Add small margin to account for precision issues
    float depthMargin = 0.001;
    return treeDepth > occluderDepth + depthMargin;
}

void main() {
    uint treeIdx = gl_GlobalInvocationID.x;

    // First thread initializes the indirect command (constant values)
    if (treeIdx == 0) {
        drawCmd.indexCount = 6;       // Billboard quad: 6 indices
        drawCmd.firstIndex = 0;
        drawCmd.vertexOffset = 0;
        drawCmd.firstInstance = 0;
        // instanceCount is set via atomicAdd below
    }

    // Early exit if beyond tree count
    if (treeIdx >= numTrees) {
        return;
    }

    // Load tree data
    TreeInputData tree = trees[treeIdx];
    vec3 treePos = tree.positionAndScale.xyz;
    float treeScale = tree.positionAndScale.w;
    float rotation = tree.rotationAndArchetype.x;
    uint archetypeIndex = floatBitsToUint(tree.rotationAndArchetype.y);

    // Distance to camera
    float distToCamera = getDistanceToCamera(treePos, cameraPosition.xyz);

    // Skip trees too close (they render as full geometry)
    // Use hysteresis to prevent flickering at the boundary
    if (distToCamera < fullDetailDistance - hysteresis) {
        return;
    }

    // Skip trees too far
    if (distToCamera > impostorDistance) {
        return;
    }

    // Get archetype sizing data
    ArchetypeData arch = archetypes[archetypeIndex];
    float boundingRadius = arch.sizingData.w * treeScale;

    // Frustum culling with margin for billboard size
    float margin = boundingRadius * 2.0;
    if (!isInFrustum(frustumPlanes, treePos, margin)) {
        return;
    }

    // Hi-Z occlusion culling (Phase 2: eliminate trees behind terrain/occluders)
    if (enableHiZ != 0u && isOccludedHiZ(treePos, boundingRadius)) {
        return;
    }

    // Calculate blend factor for LOD transition
    // 0 = pure geometry, 1 = pure impostor
    float blendFactor = 1.0;
    if (distToCamera < fullDetailDistance + blendRange) {
        blendFactor = smoothstep(fullDetailDistance - hysteresis,
                                  fullDetailDistance + blendRange,
                                  distToCamera);
    }

    // This impostor is visible - atomically get output slot
    uint outputSlot = atomicAdd(drawCmd.instanceCount, 1);

    // Write visible impostor data
    visibleImpostors[outputSlot].positionAndScale = vec4(treePos, treeScale);
    visibleImpostors[outputSlot].rotationAndArchetype = vec4(
        rotation,
        float(archetypeIndex),
        blendFactor,
        0.0  // reserved
    );
    visibleImpostors[outputSlot].sizeAndOffset = vec4(
        arch.sizingData.x * treeScale,  // hSize pre-scaled
        arch.sizingData.y * treeScale,  // vSize pre-scaled
        arch.sizingData.z * treeScale,  // baseOffset pre-scaled
        0.0  // reserved
    );
}

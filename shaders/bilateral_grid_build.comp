#version 450

/*
 * Bilateral Grid Build Compute Shader
 * Ghost of Tsushima technique for local tone mapping
 *
 * Populates a 3D bilateral grid with log-luminance values.
 * The grid is indexed by (x, y, log_luminance) where x,y are downsampled
 * image coordinates and the z-axis represents luminance bins.
 *
 * Each grid cell stores:
 *   - Accumulated weighted log-luminance (for averaging)
 *   - Total weight (for normalization)
 */

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

// Input HDR image
layout(binding = BINDING_BILATERAL_HDR_INPUT) uniform sampler2D hdrInput;

// Output bilateral grid (RGBA16F: RG = weighted log lum + weight)
layout(binding = BINDING_BILATERAL_GRID, rgba16f) uniform image3D bilateralGrid;

layout(binding = BINDING_BILATERAL_UNIFORMS) uniform BilateralUniforms {
    vec2 inputSize;        // HDR input resolution
    vec2 invInputSize;     // 1.0 / inputSize
    float minLogLum;       // Minimum log luminance (e.g., -8.0)
    float maxLogLum;       // Maximum log luminance (e.g., 4.0)
    float invLogLumRange;  // 1.0 / (maxLogLum - minLogLum)
    float gridDepth;       // Number of luminance slices (e.g., 64)
    ivec2 gridSize;        // Grid XY dimensions (e.g., 64x32)
    float sigmaRange;      // Range sigma for bilateral weight
    float pad1;
};

// Standard luminance weights
float getLuminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 inputRes = ivec2(inputSize);

    if (pixelCoord.x >= inputRes.x || pixelCoord.y >= inputRes.y) {
        return;
    }

    // Sample HDR color
    vec2 uv = (vec2(pixelCoord) + 0.5) * invInputSize;
    vec3 hdrColor = texture(hdrInput, uv).rgb;

    // Compute log luminance
    float lum = getLuminance(hdrColor);
    float logLum = log2(max(lum, 0.0001));

    // Clamp to valid range
    logLum = clamp(logLum, minLogLum, maxLogLum);

    // Map to grid coordinates
    // X,Y: downsampled image position
    vec2 gridXY = vec2(pixelCoord) / inputSize * vec2(gridSize);

    // Z: luminance bin (continuous for trilinear splatting)
    float normalizedLum = (logLum - minLogLum) * invLogLumRange;
    float gridZ = normalizedLum * (gridDepth - 1.0);

    // Trilinear splatting: contribute to the 8 nearest grid cells
    ivec3 gridCoord0 = ivec3(floor(gridXY), floor(gridZ));
    ivec3 gridCoord1 = gridCoord0 + ivec3(1, 1, 1);

    // Clamp to valid grid range
    gridCoord0 = clamp(gridCoord0, ivec3(0), ivec3(gridSize - 1, int(gridDepth) - 1));
    gridCoord1 = clamp(gridCoord1, ivec3(0), ivec3(gridSize - 1, int(gridDepth) - 1));

    // Fractional weights for trilinear interpolation
    vec3 frac = fract(vec3(gridXY, gridZ));

    // Weight = 1.0 for initial splatting (can add spatial weights if needed)
    float weight = 1.0;

    // Splat to 8 neighboring cells with trilinear weights
    // Using atomic adds would be ideal but GLSL imageAtomicAdd only works on int/uint
    // Instead, we use a single write to the nearest cell (simplified approach)
    // For full GOT accuracy, use multiple passes or atomic buffer

    ivec3 nearestCoord = ivec3(round(gridXY.x), round(gridXY.y), round(gridZ));
    nearestCoord = clamp(nearestCoord, ivec3(0), ivec3(gridSize - 1, int(gridDepth) - 1));

    // Read-modify-write pattern (will cause race conditions - see note)
    vec4 existing = imageLoad(bilateralGrid, nearestCoord);
    vec4 contribution = vec4(logLum * weight, weight, 0.0, 0.0);
    imageStore(bilateralGrid, nearestCoord, existing + contribution);

    // NOTE: The read-modify-write above has race conditions.
    // For production, use one of:
    // 1. Atomic operations on a separate uint buffer, then unpack
    // 2. Multiple smaller dispatch groups with barriers
    // 3. Accept some noise in the grid (often acceptable for tone mapping)
}

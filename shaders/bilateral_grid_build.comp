#version 450

/*
 * Bilateral Grid Build Compute Shader
 * Ghost of Tsushima technique for local tone mapping
 *
 * Populates a 3D bilateral grid with log-luminance values.
 * The grid is indexed by (x, y, log_luminance) where x,y are downsampled
 * image coordinates and the z-axis represents luminance bins.
 *
 * Each grid cell stores:
 *   - Accumulated weighted log-luminance (for averaging)
 *   - Total weight (for normalization)
 */

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

// Input HDR image
layout(binding = BINDING_BILATERAL_HDR_INPUT) uniform sampler2D hdrInput;

// Output bilateral grid (RGBA16F: RG = weighted log lum + weight)
layout(binding = BINDING_BILATERAL_GRID, rgba16f) uniform image3D bilateralGrid;

// Atomic accumulation buffer (2 uints per grid cell: packed log lum sum, packed weight sum)
// Uses fixed-point representation for atomic accumulation
layout(binding = BINDING_BILATERAL_ATOMIC, r32ui) uniform uimage3D bilateralGridAtomic;

layout(binding = BINDING_BILATERAL_UNIFORMS) uniform BilateralUniforms {
    vec2 inputSize;        // HDR input resolution
    vec2 invInputSize;     // 1.0 / inputSize
    float minLogLum;       // Minimum log luminance (e.g., -8.0)
    float maxLogLum;       // Maximum log luminance (e.g., 4.0)
    float invLogLumRange;  // 1.0 / (maxLogLum - minLogLum)
    float gridDepth;       // Number of luminance slices (e.g., 64)
    ivec2 gridSize;        // Grid XY dimensions (e.g., 64x32)
    float sigmaRange;      // Range sigma for bilateral weight
    float pad1;
};

// Standard luminance weights
float getLuminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// Fixed-point conversion for atomic accumulation
// Scale factor chosen to preserve precision while avoiding overflow
// With max ~4M pixels contributing to a cell, we need headroom
const float FIXED_POINT_SCALE = 256.0;

uint floatToFixed(float val) {
    // Offset to handle negative log luminance values (minLogLum can be -8)
    // Range [-16, 16] mapped to [0, 2^24] with 8 bits fractional
    return uint(clamp((val + 16.0) * FIXED_POINT_SCALE, 0.0, 16777215.0));
}

float fixedToFloat(uint val) {
    return float(val) / FIXED_POINT_SCALE - 16.0;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 inputRes = ivec2(inputSize);

    if (pixelCoord.x >= inputRes.x || pixelCoord.y >= inputRes.y) {
        return;
    }

    // Sample HDR color
    vec2 uv = (vec2(pixelCoord) + 0.5) * invInputSize;
    vec3 hdrColor = texture(hdrInput, uv).rgb;

    // Compute log luminance
    float lum = getLuminance(hdrColor);
    float logLum = log2(max(lum, 0.0001));

    // Clamp to valid range
    logLum = clamp(logLum, minLogLum, maxLogLum);

    // Map to grid coordinates
    // X,Y: downsampled image position
    vec2 gridXY = vec2(pixelCoord) / inputSize * vec2(gridSize);

    // Z: luminance bin (continuous for trilinear splatting)
    float normalizedLum = (logLum - minLogLum) * invLogLumRange;
    float gridZ = normalizedLum * (gridDepth - 1.0);

    // Trilinear splatting: contribute to the 8 nearest grid cells
    ivec3 gridCoord0 = ivec3(floor(gridXY), floor(gridZ));
    ivec3 gridCoord1 = gridCoord0 + ivec3(1, 1, 1);

    // Clamp to valid grid range
    gridCoord0 = clamp(gridCoord0, ivec3(0), ivec3(gridSize - 1, int(gridDepth) - 1));
    gridCoord1 = clamp(gridCoord1, ivec3(0), ivec3(gridSize - 1, int(gridDepth) - 1));

    // Fractional weights for trilinear interpolation
    vec3 frac = fract(vec3(gridXY, gridZ));

    // Weight = 1.0 for initial splatting (can add spatial weights if needed)
    float weight = 1.0;

    // Splat to 8 neighboring cells with trilinear weights
    // Using atomic adds would be ideal but GLSL imageAtomicAdd only works on int/uint
    // Instead, we use a single write to the nearest cell (simplified approach)
    // For full GOT accuracy, use multiple passes or atomic buffer

    ivec3 nearestCoord = ivec3(round(gridXY.x), round(gridXY.y), round(gridZ));
    nearestCoord = clamp(nearestCoord, ivec3(0), ivec3(gridSize - 1, int(gridDepth) - 1));

    // Use atomic operations to safely accumulate contributions
    // We store weighted log luminance and weight separately using fixed-point encoding
    // The atomic buffer has 2 layers: layer 0 = weighted log lum, layer 1 = weight
    uint fixedLogLum = floatToFixed(logLum * weight);
    uint fixedWeight = floatToFixed(weight);

    // Atomic add for weighted log luminance (stored in R channel, z*2 layer)
    ivec3 lumCoord = ivec3(nearestCoord.x, nearestCoord.y, nearestCoord.z * 2);
    imageAtomicAdd(bilateralGridAtomic, lumCoord, fixedLogLum);

    // Atomic add for weight (stored in z*2+1 layer)
    ivec3 weightCoord = ivec3(nearestCoord.x, nearestCoord.y, nearestCoord.z * 2 + 1);
    imageAtomicAdd(bilateralGridAtomic, weightCoord, fixedWeight);
}

#version 450

#extension GL_GOOGLE_include_directive : require

#include "atmosphere_common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) writeonly uniform image2D skyViewLUT;
layout(binding = 1) uniform sampler2D transmittanceLUT;
layout(binding = 2) uniform sampler2D multiScatterLUT;

layout(binding = 3) uniform AtmosphereUniforms {
    AtmosphereParams params;
    vec4 sunDirection;
    vec4 cameraPosition;  // w = camera altitude
    float padding[2];
} uAtmosphere;

const int SKY_VIEW_STEPS = 30;

// Sample transmittance LUT
vec3 SampleTransmittance(float r, float mu) {
    vec2 uv = TransmittanceLUTParamsToUV(r, mu, uAtmosphere.params);
    return texture(transmittanceLUT, uv).rgb;
}

// Sample multi-scatter LUT
vec2 SampleMultiScatter(float altitude, float cosSunZenith) {
    float u = cosSunZenith * 0.5 + 0.5;
    float v = altitude / (uAtmosphere.params.atmosphereRadius - uAtmosphere.params.planetRadius);
    return texture(multiScatterLUT, vec2(u, v)).rg;
}

// Convert UV to view direction
// UV mapping: non-linear to provide more detail at horizon
vec3 SkyViewUVToDirection(vec2 uv) {
    // Azimuth angle (horizontal)
    float phi = (uv.x - 0.5) * 2.0 * PI;

    // Elevation angle (vertical) - non-linear mapping for more detail at horizon
    // Map [0, 1] to [-PI/2, PI/2] with more samples near 0 (horizon)
    float v = uv.y * 2.0 - 1.0; // [-1, 1]
    float theta = sign(v) * (PI / 2.0) * (v * v); // Non-linear: more detail at horizon

    // Convert to direction vector
    float cosTheta = cos(theta);
    float sinTheta = sin(theta);

    vec3 dir = vec3(
        cos(phi) * cosTheta,
        sinTheta,
        sin(phi) * cosTheta
    );

    return normalize(dir);
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lutSize = imageSize(skyViewLUT);

    if (texel.x >= lutSize.x || texel.y >= lutSize.y) {
        return;
    }

    // UV coordinates [0, 1]
    vec2 uv = (vec2(texel) + 0.5) / vec2(lutSize);

    // Decode view direction from UV
    vec3 viewDir = SkyViewUVToDirection(uv);

    // Camera position
    vec3 sunDir = normalize(uAtmosphere.sunDirection.xyz);
    float cameraAltitude = uAtmosphere.cameraPosition.w;
    float r = uAtmosphere.params.planetRadius + cameraAltitude;
    vec3 cameraPos = vec3(0.0, r, 0.0);

    // Find intersection with atmosphere
    float rayLength = DistanceToAtmosphereBoundary(r, viewDir.y, uAtmosphere.params.atmosphereRadius);

    // Check if ray hits planet
    if (RayIntersectsPlanet(r, viewDir.y, uAtmosphere.params.planetRadius)) {
        // Ray hits planet - return black (will be replaced by terrain/ocean)
        imageStore(skyViewLUT, texel, vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }

    // Ray march through atmosphere
    float stepSize = rayLength / float(SKY_VIEW_STEPS);
    vec3 inscatter = vec3(0.0);
    vec3 transmittance = vec3(1.0);

    for (int i = 0; i < SKY_VIEW_STEPS; i++) {
        float t = (float(i) + 0.5) * stepSize;
        vec3 pos = cameraPos + viewDir * t;
        float posR = length(pos);
        float altitude = posR - uAtmosphere.params.planetRadius;

        // Get atmospheric density at this point
        vec3 density = GetAtmosphereDensity(altitude, uAtmosphere.params);

        // Get transmittance to sun
        float muS = dot(normalize(pos), sunDir);
        vec3 sunTransmittance = SampleTransmittance(posR, muS);

        // Local scattering coefficients
        vec3 rayleighScatter = density.x * uAtmosphere.params.rayleighScatteringBase;
        float mieScatter = density.y * uAtmosphere.params.mieScatteringBase;

        // Phase functions
        float cosTheta = dot(viewDir, sunDir);
        float rayleighPhase = RayleighPhase(cosTheta);
        float miePhase = HenyeyGreensteinPhase(cosTheta, uAtmosphere.params.mieAnisotropy);

        // Single scattering
        vec3 singleScatter = sunTransmittance * (rayleighScatter * rayleighPhase + vec3(mieScatter * miePhase));

        // Multi-scattering contribution
        vec2 multiScatter = SampleMultiScatter(altitude, muS);
        vec3 multiScatterContrib = multiScatter.x * rayleighScatter + multiScatter.y * vec3(mieScatter);

        // Total in-scattering
        vec3 totalScatter = singleScatter + multiScatterContrib;

        // Extinction
        vec3 rayleighExtinction = rayleighScatter;
        float mieExtinction = mieScatter + density.y * uAtmosphere.params.mieAbsorptionBase;
        vec3 ozoneExtinction = density.z * uAtmosphere.params.ozoneAbsorption;
        vec3 extinction = rayleighExtinction + vec3(mieExtinction) + ozoneExtinction;

        // Segment transmittance
        vec3 segmentTransmittance = exp(-extinction * stepSize);

        // Energy-conserving integration
        vec3 scatterIntegral = totalScatter * (1.0 - segmentTransmittance) / max(extinction, vec3(0.0001));

        inscatter += transmittance * scatterIntegral;
        transmittance *= segmentTransmittance;

        // Early exit if transmittance is very low
        if (max(transmittance.r, max(transmittance.g, transmittance.b)) < 0.001) {
            break;
        }
    }

    // Apply solar irradiance
    inscatter *= uAtmosphere.params.solarIrradiance;

    // Store result
    imageStore(skyViewLUT, texel, vec4(inscatter, 1.0));
}

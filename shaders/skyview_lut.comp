#version 450

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "atmosphere_common.glsl"
#include "lut_compute_common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = BINDING_ATMO_OUTPUT_LUT, rgba16f) writeonly uniform image2D skyViewLUT;
layout(binding = BINDING_ATMO_TRANSMITTANCE) uniform sampler2D transmittanceLUT;
layout(binding = BINDING_ATMO_MULTISCATTER) uniform sampler2D multiScatterLUT;

layout(binding = BINDING_ATMO_UNIFORMS) uniform AtmosphereUniforms {
    AtmosphereParams params;
    vec4 toSunDirection;
    vec4 cameraPosition;  // w = camera altitude
    float padding[2];
} uAtmosphere;

const int SKY_VIEW_STEPS = 30;

// Sample multi-scatter LUT
vec2 SampleMultiScatter(float altitude, float cosSunZenith) {
    float u = cosSunZenith * 0.5 + 0.5;
    float v = altitude / (uAtmosphere.params.atmosphereRadius - uAtmosphere.params.planetRadius);
    return texture(multiScatterLUT, vec2(u, v)).rg;
}

// Convert UV to view direction
// UV mapping: non-linear to provide more detail at horizon
vec3 SkyViewUVToDirection(vec2 uv) {
    // Azimuth angle (horizontal)
    float phi = (uv.x - 0.5) * 2.0 * PI;

    // Elevation angle (vertical) - non-linear mapping for more detail at horizon
    // Map [0, 1] to [-PI/2, PI/2] with more samples near 0 (horizon)
    float v = uv.y * 2.0 - 1.0; // [-1, 1]
    float theta = sign(v) * (PI / 2.0) * (v * v); // Non-linear: more detail at horizon

    // Convert to direction vector
    float cosTheta = cos(theta);
    float sinTheta = sin(theta);

    vec3 dir = vec3(
        cos(phi) * cosTheta,
        sinTheta,
        sin(phi) * cosTheta
    );

    return normalize(dir);
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lutSize = imageSize(skyViewLUT);

    if (isOutOfBounds(texel, lutSize)) {
        return;
    }

    vec2 uv = texelToUV(texel, lutSize);

    // Decode view direction from UV
    vec3 viewDir = SkyViewUVToDirection(uv);

    // Mirror below-horizon rays to above-horizon
    // This makes the LUT symmetric and continuous at the horizon
    // sky.frag handles actual below-horizon appearance via horizonBlend
    viewDir.y = abs(viewDir.y);
    // Ensure we don't get exactly 0 which could cause issues
    viewDir.y = max(viewDir.y, 0.0001);
    viewDir = normalize(viewDir);

    // Camera position
    vec3 sunDir = normalize(uAtmosphere.toSunDirection.xyz);
    float cameraAltitude = uAtmosphere.cameraPosition.w;
    float r = uAtmosphere.params.planetRadius + cameraAltitude;
    vec3 cameraPos = vec3(0.0, r, 0.0);

    // Find intersection with atmosphere
    float rayLength = DistanceToAtmosphereBoundary(r, viewDir.y, uAtmosphere.params.atmosphereRadius);

    // Ray march through atmosphere (simplified integration matching sky.frag)
    float stepSize = rayLength / float(SKY_VIEW_STEPS);
    vec3 inscatter = vec3(0.0);
    vec3 transmittance = vec3(1.0);

    // Phase functions (constant for the ray)
    float cosTheta = dot(viewDir, sunDir);
    float rayleighPhase = RayleighPhase(cosTheta);
    float miePhase = CornetteShanksMiePhase(cosTheta, uAtmosphere.params.mieAnisotropy);

    for (int i = 0; i < SKY_VIEW_STEPS; i++) {
        float t = rayMarchStepT(i, stepSize);
        vec3 pos = cameraPos + viewDir * t;
        float posR = length(pos);
        float altitude = radiusToAltitude(posR, uAtmosphere.params.planetRadius);

        // Get atmospheric density and scattering at this point
        vec3 density = GetAtmosphereDensity(altitude, uAtmosphere.params);
        vec3 rayleighScatterBase, mieScatterBase;
        computeScattering(density, uAtmosphere.params, rayleighScatterBase, mieScatterBase);

        // Get transmittance to sun (light reaching this point)
        float muS = dot(normalize(pos), sunDir);
        vec3 sunTransmittance = sampleTransmittanceLUT(transmittanceLUT, posR, muS, uAtmosphere.params);

        // Local scattering with phase functions
        vec3 rayleighScatter = rayleighScatterBase * rayleighPhase;
        vec3 mieScatter = mieScatterBase * miePhase;

        // Total segment scattering (attenuated by sunlight reaching this point)
        vec3 segmentScatter = sunTransmittance * (rayleighScatter + mieScatter);

        // Extinction and segment transmittance
        vec3 extinction = computeExtinction(density, uAtmosphere.params);
        vec3 segmentTransmittance = exp(-extinction * stepSize);

        // Simple integration (matching sky.frag approach)
        inscatter += transmittance * segmentScatter * stepSize;
        transmittance *= segmentTransmittance;

        // Early exit if transmittance is very low
        if (max(transmittance.r, max(transmittance.g, transmittance.b)) < 0.001) {
            break;
        }
    }

    // Apply solar irradiance to match sky.frag integrateAtmosphere output
    inscatter *= uAtmosphere.params.solarIrradiance;

    // Store result
    imageStore(skyViewLUT, texel, vec4(inscatter, 1.0));
}

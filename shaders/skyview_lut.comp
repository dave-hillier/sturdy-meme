#version 450

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "atmosphere_common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = BINDING_ATMO_OUTPUT_LUT, rgba16f) writeonly uniform image2D skyViewLUT;
layout(binding = BINDING_ATMO_TRANSMITTANCE) uniform sampler2D transmittanceLUT;
layout(binding = BINDING_ATMO_MULTISCATTER) uniform sampler2D multiScatterLUT;

layout(binding = BINDING_ATMO_UNIFORMS) uniform AtmosphereUniforms {
    AtmosphereParams params;
    vec4 sunDirection;
    vec4 cameraPosition;  // w = camera altitude
    float padding[2];
} uAtmosphere;

const int SKY_VIEW_STEPS = 30;

// Sample transmittance LUT
vec3 SampleTransmittance(float r, float mu) {
    vec2 uv = TransmittanceLUTParamsToUV(r, mu, uAtmosphere.params);
    return texture(transmittanceLUT, uv).rgb;
}

// Sample multi-scatter LUT
vec2 SampleMultiScatter(float altitude, float cosSunZenith) {
    float u = cosSunZenith * 0.5 + 0.5;
    float v = altitude / (uAtmosphere.params.atmosphereRadius - uAtmosphere.params.planetRadius);
    return texture(multiScatterLUT, vec2(u, v)).rg;
}

// Convert UV to view direction
// UV mapping: non-linear to provide more detail at horizon
vec3 SkyViewUVToDirection(vec2 uv) {
    // Azimuth angle (horizontal)
    float phi = (uv.x - 0.5) * 2.0 * PI;

    // Elevation angle (vertical) - non-linear mapping for more detail at horizon
    // Map [0, 1] to [-PI/2, PI/2] with more samples near 0 (horizon)
    float v = uv.y * 2.0 - 1.0; // [-1, 1]
    float theta = sign(v) * (PI / 2.0) * (v * v); // Non-linear: more detail at horizon

    // Convert to direction vector
    float cosTheta = cos(theta);
    float sinTheta = sin(theta);

    vec3 dir = vec3(
        cos(phi) * cosTheta,
        sinTheta,
        sin(phi) * cosTheta
    );

    return normalize(dir);
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lutSize = imageSize(skyViewLUT);

    if (texel.x >= lutSize.x || texel.y >= lutSize.y) {
        return;
    }

    // UV coordinates [0, 1]
    vec2 uv = (vec2(texel) + 0.5) / vec2(lutSize);

    // Decode view direction from UV
    vec3 viewDir = SkyViewUVToDirection(uv);

    // Camera position
    vec3 sunDir = normalize(uAtmosphere.sunDirection.xyz);
    float cameraAltitude = uAtmosphere.cameraPosition.w;
    float r = uAtmosphere.params.planetRadius + cameraAltitude;
    vec3 cameraPos = vec3(0.0, r, 0.0);

    // Find intersection with atmosphere
    float rayLength = DistanceToAtmosphereBoundary(r, viewDir.y, uAtmosphere.params.atmosphereRadius);

    // Check if ray hits planet
    if (RayIntersectsPlanet(r, viewDir.y, uAtmosphere.params.planetRadius)) {
        // Ray hits planet - return black (will be replaced by terrain/ocean)
        imageStore(skyViewLUT, texel, vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }

    // Ray march through atmosphere (simplified integration matching sky.frag)
    float stepSize = rayLength / float(SKY_VIEW_STEPS);
    vec3 inscatter = vec3(0.0);
    vec3 transmittance = vec3(1.0);

    // Phase functions (constant for the ray)
    float cosTheta = dot(viewDir, sunDir);
    float rayleighPhase = RayleighPhase(cosTheta);
    float miePhase = CornetteShanksMiePhase(cosTheta, uAtmosphere.params.mieAnisotropy);

    for (int i = 0; i < SKY_VIEW_STEPS; i++) {
        float t = (float(i) + 0.5) * stepSize;
        vec3 pos = cameraPos + viewDir * t;
        float posR = length(pos);
        float altitude = max(posR - uAtmosphere.params.planetRadius, 0.0);

        // Get atmospheric density at this point
        float rayleighDensity = exp(-altitude / uAtmosphere.params.rayleighScaleHeight);
        float mieDensity = exp(-altitude / uAtmosphere.params.mieScaleHeight);

        // Get transmittance to sun (light reaching this point)
        float muS = dot(normalize(pos), sunDir);
        vec3 sunTransmittance = SampleTransmittance(posR, muS);

        // Local scattering with phase functions
        vec3 rayleighScatter = rayleighDensity * uAtmosphere.params.rayleighScatteringBase * rayleighPhase;
        vec3 mieScatter = mieDensity * vec3(uAtmosphere.params.mieScatteringBase) * miePhase;

        // Total segment scattering (attenuated by sunlight reaching this point)
        vec3 segmentScatter = sunTransmittance * (rayleighScatter + mieScatter);

        // Extinction coefficients
        vec3 rayleighExt = rayleighDensity * uAtmosphere.params.rayleighScatteringBase;
        float mieExt = mieDensity * (uAtmosphere.params.mieScatteringBase + uAtmosphere.params.mieAbsorptionBase);
        vec3 extinction = rayleighExt + vec3(mieExt);

        // Segment transmittance
        vec3 segmentTransmittance = exp(-extinction * stepSize);

        // Simple integration (matching sky.frag approach)
        inscatter += transmittance * segmentScatter * stepSize;
        transmittance *= segmentTransmittance;

        // Early exit if transmittance is very low
        if (max(transmittance.r, max(transmittance.g, transmittance.b)) < 0.001) {
            break;
        }
    }

    // Apply solar irradiance to match sky.frag integrateAtmosphere output
    inscatter *= uAtmosphere.params.solarIrradiance;

    // Store result
    imageStore(skyViewLUT, texel, vec4(inscatter, 1.0));
}

#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "terrain_height_common.glsl"
#include "instancing_common.glsl"

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_GRASS_COMPUTE_CULLING
#include "ubo_culling.glsl"

// 2D workgroup layout for better texture cache coherency - threads in the same
// workgroup sample nearby terrain/displacement texels (16x16 = 256 threads)
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct GrassInstance {
    vec4 positionAndFacing;  // xyz = position, w = facing angle
    vec4 heightHashTilt;     // x = height, y = hash, z = tilt, w = clumpId
    vec4 terrainNormal;      // xyz = terrain normal (for tangent alignment), w = unused
};

// DrawIndirectCommand is now provided by instancing_common.glsl

layout(std430, binding = BINDING_GRASS_COMPUTE_INSTANCES) buffer InstanceBuffer {
    GrassInstance instances[];
};

layout(std430, binding = BINDING_GRASS_COMPUTE_INDIRECT) buffer IndirectBuffer {
    DrawIndirectCommand drawCmd;
};

// Grass-specific parameters (terrain and displacement)
layout(std140, binding = BINDING_GRASS_COMPUTE_PARAMS) uniform GrassParams {
    vec4 displacementRegion;  // xy = world center, z = region size, w = texel size
    float terrainSize;
    float terrainHeightScale;
    float padding[2];
} grassParams;

// Terrain heightmap for grass placement on terrain
layout(binding = BINDING_GRASS_COMPUTE_HEIGHT_MAP) uniform sampler2D terrainHeightMap;

// Displacement map for player/NPC grass interaction (RG16F - XZ displacement)
layout(binding = BINDING_GRASS_COMPUTE_DISPLACEMENT) uniform sampler2D displacementMap;

// LOD tile array (high-res tiles near camera)
layout(binding = BINDING_GRASS_COMPUTE_TILE_ARRAY) uniform sampler2DArray heightMapTiles;

// Tile info buffer - world bounds for each active tile
struct TileInfo {
    vec4 worldBounds;    // xy = min corner, zw = max corner
    vec4 uvScaleOffset;  // xy = scale, zw = offset
    ivec4 layerIndex;    // x = layer index in tile array, yzw = padding
};
layout(std430, binding = BINDING_GRASS_COMPUTE_TILE_INFO) readonly buffer TileInfoBuffer {
    uint activeTileCount;
    uint padding1;
    uint padding2;
    uint padding3;
    TileInfo tiles[];
};

// Include tile cache common after defining prerequisites
#include "tile_cache_common.glsl"

layout(push_constant) uniform PushConstants {
    float time;
} push;

// Hash functions - use instancing_common.glsl versions
// Local aliases for compatibility with existing code
#define hash(p) hash2D(p)
#define hash2(p) hash2D_alt(p)
#define hash2v(p) hash2D_vec2(p)

// Calculate terrain normal from heightmap gradient with tile cache support
vec3 calculateTerrainNormal(vec2 uv, vec2 worldXZ) {
    return calculateNormalWithTileCache(terrainHeightMap, heightMapTiles, uv, worldXZ,
                                         grassParams.terrainSize, grassParams.terrainHeightScale, activeTileCount);
}

// Clumping parameters
const float CLUMP_SCALE = 2.0;          // Size of clumps in world units
const float CLUMP_HEIGHT_INFLUENCE = 0.4;  // How much clump affects height (0-1)
const float CLUMP_FACING_INFLUENCE = 0.3;  // How much blades face toward/away from clump center

// Convert world position to displacement map UV coordinates
vec2 worldPosToDispUV(vec2 worldPos) {
    vec2 regionCenter = grassParams.displacementRegion.xy;
    float regionSize = grassParams.displacementRegion.z;

    // Convert world pos to UV: center of region maps to UV(0.5, 0.5)
    vec2 offset = worldPos - regionCenter;
    vec2 uv = offset / regionSize + 0.5;

    return uv;
}

// Sample displacement from the displacement buffer texture
// Returns: xy = displacement direction in XZ plane
vec2 sampleDisplacement(vec2 worldPos) {
    vec2 uv = worldPosToDispUV(worldPos);

    // Check if within displacement region bounds
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        return vec2(0.0);
    }

    // Sample displacement (RG = XZ displacement)
    return texture(displacementMap, uv).rg;
}

// Voronoi-based clump calculation
// Returns clumpId (0-1), clumpDistance, and clumpCenter
void calculateClump(vec2 worldPos, float clumpScale,
                    out float clumpId, out float clumpDist, out vec2 clumpCenter) {
    // Scale position to clump space
    vec2 scaledPos = worldPos / clumpScale;
    vec2 cellId = floor(scaledPos);

    float minDist = 10.0;
    vec2 nearestPoint = vec2(0.0);
    float nearestId = 0.0;

    // Check 3x3 neighborhood (9 potential clump centers)
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 neighborCell = cellId + vec2(float(x), float(y));

            // Each cell's clump point is jittered based on hash
            vec2 jitter = hash2v(neighborCell) * 0.8 + 0.1;
            vec2 clumpPoint = (neighborCell + jitter) * clumpScale;

            float dist = length(worldPos - clumpPoint);
            if (dist < minDist) {
                minDist = dist;
                nearestPoint = clumpPoint;
                nearestId = hash(neighborCell);  // Unique ID per clump (0-1)
            }
        }
    }

    clumpId = nearestId;
    clumpDist = minDist;
    clumpCenter = nearestPoint;
}

void main() {
    // 2D dispatch: use xy directly instead of computing from flattened index
    // This eliminates expensive integer division/modulo and improves cache locality
    uint gridX = gl_GlobalInvocationID.x;
    uint gridZ = gl_GlobalInvocationID.y;

    // Set vertexCount (only first thread writes this constant value)
    if (gridX == 0 && gridZ == 0) {
        drawCmd.vertexCount = 15;  // 5 segments * 3 vertices per triangle
    }

    // Generate grass positions in a grid pattern
    // Grid: 1000x1000 = 1,000,000 potential blades (matching Ghost of Tsushima target)
    // With 0.2m spacing = 200m x 200m area = 25 blades per square meter
    // Culling systems (distance, frustum, LOD) will reduce to ~100k rendered
    uint gridSize = 1000;
    if (gridX >= gridSize || gridZ >= gridSize) return;

    // Map to world space (centered on origin)
    float spacing = 0.2;  // 200m x 200m coverage
    float x = (float(gridX) - float(gridSize) / 2.0) * spacing;
    float z = (float(gridZ) - float(gridSize) / 2.0) * spacing;

    // Add some randomness to position (jitter)
    vec2 cell = vec2(gridX, gridZ);
    float h1 = hash(cell);
    float h2 = hash2(cell);

    x += (h1 - 0.5) * spacing * 0.8;
    z += (hash(cell + vec2(100.0, 0.0)) - 0.5) * spacing * 0.8;

    // Sample terrain heightmap to get Y position
    // Convert world XZ to heightmap UV: terrain is centered at origin with size = terrainSize
    vec2 terrainUV = vec2(x, z) / grassParams.terrainSize + 0.5;

    // Check if grass is within terrain bounds
    if (terrainUV.x < 0.0 || terrainUV.x > 1.0 || terrainUV.y < 0.0 || terrainUV.y > 1.0) return;

    // Sample terrain height with tile cache support for ~1m resolution near camera
    float terrainY = sampleHeightWithTileCache(terrainHeightMap, heightMapTiles, terrainUV,
                                                vec2(x, z), grassParams.terrainHeightScale, activeTileCount);

    vec3 worldPos = vec3(x, terrainY, z);

    // Calculate terrain normal for tangent-aligned grass placement (with tile cache)
    vec3 terrainNormal = calculateTerrainNormal(terrainUV, vec2(x, z));

    // Distance culling (relative to camera) using shared culling UBO
    float distToCamera = getDistanceToCamera(worldPos, culling.cameraPosition.xyz);
    if (distToCamera > culling.maxDrawDistance) return;

    // Frustum culling using shared culling UBO
    // Use large margin (15.0) to handle double-buffer lag during camera rotation
    // and ensure grass behind camera can still cast shadows
    if (!isInFrustum(culling.frustumPlanes, worldPos, 15.0)) return;

    // LOD blade dropping using shared culling UBO
    // maxLodDropRate from UBO controls max drop percentage at far LOD
    float instanceHash = hash(cell + vec2(500.0, 500.0));
    if (isLodEnabled() && lodCull(distToCamera, culling.lodTransitionStart, culling.lodTransitionEnd,
                                   culling.maxLodDropRate, instanceHash)) return;

    // Use subgroup operations to batch atomic updates
    // This reduces contention by ~32x compared to per-thread atomics
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    uint baseSlot = 0;
    if (subgroupElect()) {
        baseSlot = atomicAdd(drawCmd.instanceCount, activeCount);
    }
    baseSlot = subgroupBroadcastFirst(baseSlot);
    uint slot = baseSlot + laneOffset;

    // Calculate clumping
    float clumpId, clumpDist;
    vec2 clumpCenter;
    calculateClump(vec2(x, z), CLUMP_SCALE, clumpId, clumpDist, clumpCenter);

    // Base random properties
    float randomFacing = h1 * 6.28318;     // Random facing direction
    float baseHeight = 0.3 + h2 * 0.4;     // Height between 0.3 and 0.7
    float bladeHash = h1;                  // For wind animation
    float baseTilt = (hash(cell + vec2(50.0, 50.0)) - 0.5) * 0.3;  // Slight tilt

    // Apply clump height influence
    // Blades in the same clump have similar heights
    // clumpId varies 0-1, so we map it to a height multiplier
    float clumpHeightMod = mix(1.0, 0.6 + clumpId * 0.8, CLUMP_HEIGHT_INFLUENCE);
    float height = baseHeight * clumpHeightMod;

    // Apply clump facing influence
    // Blades lean toward or away from clump center
    vec2 toClumpCenter = clumpCenter - vec2(x, z);
    float distToClump = length(toClumpCenter);
    if (distToClump > 0.01) {
        toClumpCenter = normalize(toClumpCenter);
    } else {
        toClumpCenter = vec2(0.0, 1.0);
    }

    // Calculate facing angle that points toward clump center
    float clumpFacingAngle = atan(toClumpCenter.y, toClumpCenter.x);

    // Blend between random facing and clump-oriented facing
    // Use clumpId to determine if blades face toward (clumpId < 0.5) or away (clumpId > 0.5)
    float facingTarget = clumpId < 0.5 ? clumpFacingAngle : clumpFacingAngle + 3.14159;

    // Smooth blend between random and clump-oriented facing
    float facing = mix(randomFacing, facingTarget, CLUMP_FACING_INFLUENCE);

    // Tilt also influenced by distance to clump center (blades closer lean more)
    float clumpTiltMod = (1.0 - clumpDist / CLUMP_SCALE) * 0.15;
    float tilt = baseTilt + clumpTiltMod;

    // Apply displacement from displacement buffer (player/NPC interaction)
    // Sample the displacement texture to get push direction
    vec2 displacement = sampleDisplacement(vec2(x, z));
    float dispMagnitude = length(displacement);

    if (dispMagnitude > 0.01) {
        // Normalize displacement direction
        vec2 dispDir = displacement / dispMagnitude;

        // Calculate the angle of the displacement direction
        float dispAngle = atan(dispDir.y, dispDir.x);

        // Blend facing toward displacement direction based on magnitude
        // Stronger displacement = blade faces more in push direction
        float facingBlend = clamp(dispMagnitude * 0.9, 0.0, 0.9);
        facing = mix(facing, dispAngle, facingBlend);
    }

    // Write instance data (clumpId stored in w for fragment shader color variation)
    instances[slot].positionAndFacing = vec4(worldPos, facing);
    instances[slot].heightHashTilt = vec4(height, bladeHash, tilt, clumpId);
    instances[slot].terrainNormal = vec4(terrainNormal, 0.0);
}

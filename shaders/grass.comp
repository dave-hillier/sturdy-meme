#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct GrassInstance {
    vec4 positionAndFacing;  // xyz = position, w = facing angle
    vec4 heightHashTilt;     // x = height, y = hash, z = tilt, w = unused
};

struct DrawIndirectCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

layout(std430, binding = 0) buffer InstanceBuffer {
    GrassInstance instances[];
};

layout(std430, binding = 1) buffer IndirectBuffer {
    DrawIndirectCommand drawCmd;
};

layout(binding = 2) uniform GrassUniforms {
    vec4 cameraPosition;
    vec4 frustumPlanes[6];
    vec4 playerCapsule;       // xyz = base position, w = radius
    vec4 displacementParams;  // x = strength, y = decay falloff, z = max tilt, w = unused
    float maxDrawDistance;
    float lodTransitionStart;
    float lodTransitionEnd;
    float terrainSize;
    float terrainHeightScale;
    float padding[3];
} uniforms;

// Terrain heightmap for grass placement on terrain
layout(binding = 3) uniform sampler2D terrainHeightMap;

layout(push_constant) uniform PushConstants {
    float time;
} push;

// Hash functions for procedural placement
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hash2(vec2 p) {
    return fract(sin(dot(p, vec2(269.5, 183.3))) * 43758.5453);
}

// Returns vec2 hash for a cell
vec2 hash2v(vec2 p) {
    return vec2(hash(p), hash(p + vec2(47.0, 13.0)));
}

// Clumping parameters
const float CLUMP_SCALE = 2.0;          // Size of clumps in world units
const float CLUMP_HEIGHT_INFLUENCE = 0.4;  // How much clump affects height (0-1)
const float CLUMP_FACING_INFLUENCE = 0.3;  // How much blades face toward/away from clump center

// Calculate displacement from player capsule
// Returns: xyz = push direction in XZ plane, w = displacement amount (0-1)
vec4 calculatePlayerDisplacement(vec3 bladePos) {
    vec3 capsuleBase = uniforms.playerCapsule.xyz;
    float capsuleRadius = uniforms.playerCapsule.w;
    float strength = uniforms.displacementParams.x;
    float falloff = uniforms.displacementParams.y;

    // Player capsule height (approximate - grass interacts with lower portion)
    float capsuleHeight = 1.8;

    // Find closest point on capsule axis to blade base
    // Capsule axis goes from capsuleBase to capsuleBase + (0, capsuleHeight, 0)
    float bladeY = bladePos.y;
    float clampedY = clamp(bladeY, capsuleBase.y, capsuleBase.y + capsuleHeight);

    // Closest point on capsule axis
    vec3 closestOnAxis = vec3(capsuleBase.x, clampedY, capsuleBase.z);

    // Vector from capsule axis to blade (in XZ plane primarily)
    vec3 toBladeVec = bladePos - closestOnAxis;
    vec2 toBladeXZ = vec2(toBladeVec.x, toBladeVec.z);
    float distXZ = length(toBladeXZ);

    // If blade is outside capsule influence radius, no displacement
    float influenceRadius = capsuleRadius * 2.0;  // Extend influence beyond physical capsule
    if (distXZ > influenceRadius || distXZ < 0.001) {
        return vec4(0.0, 0.0, 0.0, 0.0);
    }

    // Normalize push direction (away from capsule center in XZ plane)
    vec2 pushDir = toBladeXZ / distXZ;

    // Calculate displacement amount with smooth falloff
    // Quadratic falloff: stronger near center, smooth transition at edge
    float normalizedDist = distXZ / influenceRadius;
    float displacementAmount = (1.0 - normalizedDist * normalizedDist) * strength;

    // Blades very close to capsule get maximum displacement
    if (distXZ < capsuleRadius) {
        displacementAmount = strength;
    }

    return vec4(pushDir.x, 0.0, pushDir.y, displacementAmount);
}

// Voronoi-based clump calculation
// Returns clumpId (0-1), clumpDistance, and clumpCenter
void calculateClump(vec2 worldPos, float clumpScale,
                    out float clumpId, out float clumpDist, out vec2 clumpCenter) {
    // Scale position to clump space
    vec2 scaledPos = worldPos / clumpScale;
    vec2 cellId = floor(scaledPos);

    float minDist = 10.0;
    vec2 nearestPoint = vec2(0.0);
    float nearestId = 0.0;

    // Check 3x3 neighborhood (9 potential clump centers)
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 neighborCell = cellId + vec2(float(x), float(y));

            // Each cell's clump point is jittered based on hash
            vec2 jitter = hash2v(neighborCell) * 0.8 + 0.1;
            vec2 clumpPoint = (neighborCell + jitter) * clumpScale;

            float dist = length(worldPos - clumpPoint);
            if (dist < minDist) {
                minDist = dist;
                nearestPoint = clumpPoint;
                nearestId = hash(neighborCell);  // Unique ID per clump (0-1)
            }
        }
    }

    clumpId = nearestId;
    clumpDist = minDist;
    clumpCenter = nearestPoint;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;

    // Set vertexCount atomically (buffer is pre-cleared to 0 by CPU, so atomicMax ensures it becomes 15)
    // This is safe even with multiple workgroups since they all write the same value
    if (idx == 0) {
        atomicMax(drawCmd.vertexCount, 15);  // 5 segments * 3 vertices per triangle
    }

    // Generate grass positions in a grid pattern
    // Grid: 1000x1000 = 1,000,000 potential blades (matching Ghost of Tsushima target)
    // With 0.2m spacing = 200m x 200m area = 25 blades per square meter
    // Culling systems (distance, frustum, LOD) will reduce to ~100k rendered
    uint gridSize = 1000;
    if (idx >= gridSize * gridSize) return;

    uint gridX = idx % gridSize;
    uint gridZ = idx / gridSize;

    // Map to world space (centered on origin)
    float spacing = 0.2;  // 200m x 200m coverage
    float x = (float(gridX) - float(gridSize) / 2.0) * spacing;
    float z = (float(gridZ) - float(gridSize) / 2.0) * spacing;

    // Add some randomness to position (jitter)
    vec2 cell = vec2(gridX, gridZ);
    float h1 = hash(cell);
    float h2 = hash2(cell);

    x += (h1 - 0.5) * spacing * 0.8;
    z += (hash(cell + vec2(100.0, 0.0)) - 0.5) * spacing * 0.8;

    // Sample terrain heightmap to get Y position
    // Convert world XZ to heightmap UV: terrain is centered at origin with size = terrainSize
    vec2 terrainUV = vec2(x, z) / uniforms.terrainSize + 0.5;

    // Check if grass is within terrain bounds
    if (terrainUV.x < 0.0 || terrainUV.x > 1.0 || terrainUV.y < 0.0 || terrainUV.y > 1.0) return;

    // Sample heightmap (R32_SFLOAT format, values in [0,1])
    float heightSample = texture(terrainHeightMap, terrainUV).r;

    // Convert to world Y using same formula as terrain shader: (h - 0.5) * heightScale
    float terrainY = (heightSample - 0.5) * uniforms.terrainHeightScale;

    vec3 worldPos = vec3(x, terrainY, z);

    // Distance culling (relative to camera)
    float distToCamera = length(worldPos - uniforms.cameraPosition.xyz);
    if (distToCamera > uniforms.maxDrawDistance) return;

    // Frustum culling - check against all 6 planes
    // Use large margin (5.0) to ensure grass behind camera can still cast shadows
    vec4 posW = vec4(worldPos, 1.0);
    for (int i = 0; i < 6; i++) {
        // If position is behind any plane with margin, cull it
        if (dot(posW, uniforms.frustumPlanes[i]) < -5.0) return;
    }

    // LOD blade dropping - probabilistically drop blades at distance
    float lodFactor = smoothstep(uniforms.lodTransitionStart,
                                 uniforms.lodTransitionEnd, distToCamera);
    float dropThreshold = lodFactor * 0.75; // Drop up to 75% at max LOD distance
    if (hash(cell + vec2(500.0, 500.0)) < dropThreshold) return;

    // Atomically increment instance count and get our slot
    uint slot = atomicAdd(drawCmd.instanceCount, 1);

    // Calculate clumping
    float clumpId, clumpDist;
    vec2 clumpCenter;
    calculateClump(vec2(x, z), CLUMP_SCALE, clumpId, clumpDist, clumpCenter);

    // Base random properties
    float randomFacing = h1 * 6.28318;     // Random facing direction
    float baseHeight = 0.3 + h2 * 0.4;     // Height between 0.3 and 0.7
    float bladeHash = h1;                  // For wind animation
    float baseTilt = (hash(cell + vec2(50.0, 50.0)) - 0.5) * 0.3;  // Slight tilt

    // Apply clump height influence
    // Blades in the same clump have similar heights
    // clumpId varies 0-1, so we map it to a height multiplier
    float clumpHeightMod = mix(1.0, 0.6 + clumpId * 0.8, CLUMP_HEIGHT_INFLUENCE);
    float height = baseHeight * clumpHeightMod;

    // Apply clump facing influence
    // Blades lean toward or away from clump center
    vec2 toClumpCenter = clumpCenter - vec2(x, z);
    float distToClump = length(toClumpCenter);
    if (distToClump > 0.01) {
        toClumpCenter = normalize(toClumpCenter);
    } else {
        toClumpCenter = vec2(0.0, 1.0);
    }

    // Calculate facing angle that points toward clump center
    float clumpFacingAngle = atan(toClumpCenter.y, toClumpCenter.x);

    // Blend between random facing and clump-oriented facing
    // Use clumpId to determine if blades face toward (clumpId < 0.5) or away (clumpId > 0.5)
    float facingTarget = clumpId < 0.5 ? clumpFacingAngle : clumpFacingAngle + 3.14159;

    // Smooth blend between random and clump-oriented facing
    float facing = mix(randomFacing, facingTarget, CLUMP_FACING_INFLUENCE);

    // Tilt also influenced by distance to clump center (blades closer lean more)
    float clumpTiltMod = (1.0 - clumpDist / CLUMP_SCALE) * 0.15;
    float tilt = baseTilt + clumpTiltMod;

    // Apply player displacement - grass bends away from player capsule
    vec4 displacement = calculatePlayerDisplacement(worldPos);
    float dispAmount = displacement.w;

    if (dispAmount > 0.01) {
        // Get push direction in XZ plane
        vec2 pushDir = vec2(displacement.x, displacement.z);

        // Calculate the angle of the push direction
        float pushAngle = atan(pushDir.y, pushDir.x);

        // Blend facing toward push direction based on displacement amount
        // Strong displacement = blade faces away from player
        float maxDispInfluence = uniforms.displacementParams.z;  // max tilt
        float facingBlend = dispAmount * 0.7;  // How much to rotate toward push direction
        facing = mix(facing, pushAngle, facingBlend);

        // Increase tilt based on displacement - grass bends over when pushed
        float dispTilt = dispAmount * maxDispInfluence;
        tilt += dispTilt;
    }

    // Write instance data (clumpId stored in w for fragment shader color variation)
    instances[slot].positionAndFacing = vec4(worldPos, facing);
    instances[slot].heightHashTilt = vec4(height, bladeHash, tilt, clumpId);
}

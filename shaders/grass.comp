#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "grass_constants.glsl"
#include "terrain_height_common.glsl"
#include "instancing_common.glsl"

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_GRASS_COMPUTE_CULLING
#include "ubo_culling.glsl"

// 2D workgroup layout for better texture cache coherency - threads in the same
// workgroup sample nearby terrain/displacement texels (16x16 = 256 threads)
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct GrassInstance {
    vec4 positionAndFacing;  // xyz = position, w = facing angle
    vec4 heightHashTilt;     // x = height, y = hash, z = tilt, w = clumpId
    vec4 terrainNormal;      // xyz = terrain normal (for tangent alignment), w = unused
};

// DrawIndirectCommand is now provided by instancing_common.glsl

layout(std430, binding = BINDING_GRASS_COMPUTE_INSTANCES) buffer InstanceBuffer {
    GrassInstance instances[];
};

layout(std430, binding = BINDING_GRASS_COMPUTE_INDIRECT) buffer IndirectBuffer {
    DrawIndirectCommand drawCmd;
};

// Grass-specific parameters (terrain and displacement)
layout(std140, binding = BINDING_GRASS_COMPUTE_PARAMS) uniform GrassParams {
    vec4 displacementRegion;  // xy = world center, z = region size, w = texel size
    float terrainSize;
    float terrainHeightScale;
    float padding[2];
} grassParams;

// Terrain heightmap for grass placement on terrain
layout(binding = BINDING_GRASS_COMPUTE_HEIGHT_MAP) uniform sampler2D terrainHeightMap;

// Displacement map for player/NPC grass interaction (RG16F - XZ displacement)
layout(binding = BINDING_GRASS_COMPUTE_DISPLACEMENT) uniform sampler2D displacementMap;

// Hole mask tile array for terrain cutouts (caves, wells) - R8: 0=solid, 1=hole
layout(binding = BINDING_GRASS_COMPUTE_HOLE_MASK) uniform sampler2DArray holeMaskTiles;

// LOD tile array (high-res tiles near camera)
layout(binding = BINDING_GRASS_COMPUTE_TILE_ARRAY) uniform sampler2DArray heightMapTiles;

// Tile info buffer - world bounds for each active tile
struct TileInfo {
    vec4 worldBounds;    // xy = min corner, zw = max corner
    vec4 uvScaleOffset;  // xy = scale, zw = offset
    ivec4 layerIndex;    // x = layer index in tile array, yzw = padding
};
layout(std430, binding = BINDING_GRASS_COMPUTE_TILE_INFO) readonly buffer TileInfoBuffer {
    uint activeTileCount;
    uint padding1;
    uint padding2;
    uint padding3;
    TileInfo tiles[];
};

// Include tile cache common after defining prerequisites
#include "tile_cache_common.glsl"

layout(push_constant) uniform PushConstants {
    float time;
    float tileOriginX;   // World X origin of this tile (0 for non-tiled mode)
    float tileOriginZ;   // World Z origin of this tile (0 for non-tiled mode)
    float tileSize;      // Tile size in world units (varies by LOD: 64, 128, 256)
    float spacingMult;   // Spacing multiplier for this LOD (1.0, 2.0, 4.0)
    uint lodLevel;       // LOD level (0 = high detail, 1 = medium, 2 = low)
    float tileLoadTime;  // Time when this tile was first loaded (for fade-in)
    float padding;
} push;

// Check if we're in tiled mode (tile origin is non-zero or explicitly set)
// In tiled mode, we use GRASS_TILE_GRID_SIZE and tile-relative positioning
#ifdef GRASS_TILED_MODE
    #define EFFECTIVE_GRID_SIZE GRASS_TILE_GRID_SIZE
    #define EFFECTIVE_MAX_INSTANCES GRASS_MAX_INSTANCES_PER_TILE
#else
    #define EFFECTIVE_GRID_SIZE GRASS_GRID_SIZE
    #define EFFECTIVE_MAX_INSTANCES GRASS_MAX_INSTANCES
#endif

// Hash functions - use instancing_common.glsl versions
// Local aliases for compatibility with existing code
#define hash(p) hash2D(p)
#define hash2(p) hash2D_alt(p)
#define hash2v(p) hash2D_vec2(p)

// Calculate terrain normal from heightmap gradient with tile cache support
vec3 calculateTerrainNormal(vec2 uv, vec2 worldXZ) {
    return calculateNormalWithTileCache(terrainHeightMap, heightMapTiles, uv, worldXZ,
                                         grassParams.terrainSize, grassParams.terrainHeightScale, activeTileCount);
}

// Clumping parameters - using unified constants from grass_constants.glsl
// GRASS_CLUMP_SCALE, GRASS_CLUMP_HEIGHT_INFLUENCE, GRASS_CLUMP_FACING_INFLUENCE

// Convert world position to displacement map UV coordinates
vec2 worldPosToDispUV(vec2 worldPos) {
    vec2 regionCenter = grassParams.displacementRegion.xy;
    float regionSize = grassParams.displacementRegion.z;

    // Convert world pos to UV: center of region maps to UV(0.5, 0.5)
    vec2 offset = worldPos - regionCenter;
    vec2 uv = offset / regionSize + 0.5;

    return uv;
}

// Sample displacement from the displacement buffer texture
// Returns: xy = displacement direction in XZ plane
vec2 sampleDisplacement(vec2 worldPos) {
    vec2 uv = worldPosToDispUV(worldPos);

    // Check if within displacement region bounds
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        return vec2(0.0);
    }

    // Sample displacement (RG = XZ displacement)
    return texture(displacementMap, uv).rg;
}

// Voronoi-based clump calculation
// Returns clumpId (0-1), clumpDistance, and clumpCenter
void calculateClump(vec2 worldPos, out float clumpId, out float clumpDist, out vec2 clumpCenter) {
    // Scale position to clump space using unified constant
    vec2 scaledPos = worldPos / GRASS_CLUMP_SCALE;
    vec2 cellId = floor(scaledPos);

    float minDist = 10.0;
    vec2 nearestPoint = vec2(0.0);
    float nearestId = 0.0;

    // Check 3x3 neighborhood (9 potential clump centers)
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 neighborCell = cellId + vec2(float(x), float(y));

            // Each cell's clump point is jittered based on hash
            vec2 jitter = hash2v(neighborCell) * 0.8 + 0.1;
            vec2 clumpPoint = (neighborCell + jitter) * GRASS_CLUMP_SCALE;

            float dist = length(worldPos - clumpPoint);
            if (dist < minDist) {
                minDist = dist;
                nearestPoint = clumpPoint;
                nearestId = hash(neighborCell);  // Unique ID per clump (0-1)
            }
        }
    }

    clumpId = nearestId;
    clumpDist = minDist;
    clumpCenter = nearestPoint;
}

void main() {
    // 2D dispatch: use xy directly instead of computing from flattened index
    // This eliminates expensive integer division/modulo and improves cache locality
    uint gridX = gl_GlobalInvocationID.x;
    uint gridZ = gl_GlobalInvocationID.y;

    // Set vertexCount (only first thread writes this constant value)
    // Uses derived constant: GRASS_VERTICES_PER_BLADE = GRASS_NUM_SEGMENTS * 2 + 1 = 15
    if (gridX == 0 && gridZ == 0) {
        drawCmd.vertexCount = GRASS_VERTICES_PER_BLADE;
    }

    // Generate grass positions in a grid pattern
    // In tiled mode: GRASS_TILE_GRID_SIZE x GRASS_TILE_GRID_SIZE per tile
    // In non-tiled mode: GRASS_GRID_SIZE x GRASS_GRID_SIZE = 1,000,000 potential blades
    // Culling systems (distance, frustum, LOD) reduce to max rendered instances
    if (gridX >= EFFECTIVE_GRID_SIZE || gridZ >= EFFECTIVE_GRID_SIZE) return;

    // Map to world space
    // In tiled mode: position relative to tile origin
    // In non-tiled mode: centered on origin (backward compatible)
    float x, z;
#ifdef GRASS_TILED_MODE
    // Tiled mode: grid covers the tile, starting from tile origin
    x = push.tileOriginX + float(gridX) * GRASS_SPACING;
    z = push.tileOriginZ + float(gridZ) * GRASS_SPACING;
#else
    // Non-tiled mode: grid centered on origin (legacy behavior)
    x = (float(gridX) - float(GRASS_GRID_SIZE) / 2.0) * GRASS_SPACING;
    z = (float(gridZ) - float(GRASS_GRID_SIZE) / 2.0) * GRASS_SPACING;
#endif

    // Add some randomness to position (jitter)
    // Use world-space position for hash to ensure unique patterns per tile
#ifdef GRASS_TILED_MODE
    // In tiled mode, hash based on world position to get unique patterns per tile
    vec2 worldCell = vec2(x, z) / GRASS_SPACING;
    vec2 cell = worldCell;
#else
    vec2 cell = vec2(gridX, gridZ);
#endif
    float h1 = hash(cell);
    float h2 = hash2(cell);

    x += (h1 - 0.5) * GRASS_SPACING * GRASS_JITTER_FACTOR;
    z += (hash(cell + vec2(100.0, 0.0)) - 0.5) * GRASS_SPACING * GRASS_JITTER_FACTOR;

    // Sample terrain heightmap to get Y position
    // Convert world XZ to heightmap UV: terrain is centered at origin with size = terrainSize
    vec2 terrainUV = vec2(x, z) / grassParams.terrainSize + 0.5;

    // Check if grass is within terrain bounds
    if (terrainUV.x < 0.0 || terrainUV.x > 1.0 || terrainUV.y < 0.0 || terrainUV.y > 1.0) return;

    // Check hole mask - don't spawn grass in terrain holes (caves, wells)
    float holeMaskValue = sampleHoleMaskWithTileCache(holeMaskTiles, vec2(x, z), activeTileCount);
    if (holeMaskValue > 0.5) return;

    // Sample terrain height with tile cache support for ~1m resolution near camera
    float terrainY = sampleHeightWithTileCache(terrainHeightMap, heightMapTiles, terrainUV,
                                                vec2(x, z), grassParams.terrainHeightScale, activeTileCount);

    vec3 worldPos = vec3(x, terrainY, z);

    // Calculate terrain normal for tangent-aligned grass placement (with tile cache)
    vec3 terrainNormal = calculateTerrainNormal(terrainUV, vec2(x, z));

    // Distance culling (relative to camera) using shared culling UBO
    float distToCamera = getDistanceToCamera(worldPos, culling.cameraPosition.xyz);
    if (distToCamera > culling.maxDrawDistance) return;

    // Frustum culling using shared culling UBO
    // Use GRASS_FRUSTUM_MARGIN to handle double-buffer lag during camera rotation
    // and ensure grass behind camera can still cast shadows
    if (!isInFrustum(culling.frustumPlanes, worldPos, GRASS_FRUSTUM_MARGIN)) return;

    // LOD blade dropping using shared culling UBO with hysteresis
    // maxLodDropRate from UBO controls max drop percentage at far LOD
    // hysteresisHash staggers transition points to prevent synchronized flickering
    float instanceHash = hash(cell + vec2(500.0, 500.0));
    float hysteresisHash = hash(cell + vec2(1234.0, 5678.0));
    if (isLodEnabled() && lodCullWithHysteresis(distToCamera, culling.lodTransitionStart, culling.lodTransitionEnd,
                                                 culling.maxLodDropRate, instanceHash, hysteresisHash)) return;

    // Use subgroup operations to batch atomic updates
    // This reduces contention by ~32x compared to per-thread atomics
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    uint baseSlot = 0;
    if (subgroupElect()) {
        baseSlot = atomicAdd(drawCmd.instanceCount, activeCount);
    }
    baseSlot = subgroupBroadcastFirst(baseSlot);
    uint slot = baseSlot + laneOffset;

    // Clamp to max instances - prevent buffer overflow
    if (slot >= EFFECTIVE_MAX_INSTANCES) {
        // Cap the instance count to prevent draw from reading garbage
        if (subgroupElect()) {
            atomicMin(drawCmd.instanceCount, EFFECTIVE_MAX_INSTANCES);
        }
        return;
    }

    // Calculate clumping using unified constants
    float clumpId, clumpDist;
    vec2 clumpCenter;
    calculateClump(vec2(x, z), clumpId, clumpDist, clumpCenter);

    // Base random properties using unified constants
    float randomFacing = h1 * GRASS_TWO_PI;  // Random facing direction (full rotation)
    float baseHeight = GRASS_HEIGHT_MIN + h2 * GRASS_HEIGHT_RANGE;  // Height between min and max
    float bladeHash = h1;                    // For wind animation
    float baseTilt = (hash(cell + vec2(50.0, 50.0)) - 0.5) * GRASS_TILT_RANGE;  // Slight tilt

    // Apply clump height influence using unified constant
    // Blades in the same clump have similar heights
    // clumpId varies 0-1, so we map it to a height multiplier
    float clumpHeightMod = mix(1.0, 0.6 + clumpId * 0.8, GRASS_CLUMP_HEIGHT_INFLUENCE);
    float height = baseHeight * clumpHeightMod;

    // Apply clump facing influence
    // Blades lean toward or away from clump center
    vec2 toClumpCenter = clumpCenter - vec2(x, z);
    float distToClump = length(toClumpCenter);
    if (distToClump > 0.01) {
        toClumpCenter = normalize(toClumpCenter);
    } else {
        toClumpCenter = vec2(0.0, 1.0);
    }

    // Calculate facing angle that points toward clump center
    float clumpFacingAngle = atan(toClumpCenter.y, toClumpCenter.x);

    // Blend between random facing and clump-oriented facing
    // Use clumpId to determine if blades face toward (clumpId < 0.5) or away (clumpId > 0.5)
    float facingTarget = clumpId < 0.5 ? clumpFacingAngle : clumpFacingAngle + 3.14159;

    // Smooth blend between random and clump-oriented facing
    float facing = mix(randomFacing, facingTarget, GRASS_CLUMP_FACING_INFLUENCE);

    // Tilt also influenced by distance to clump center (blades closer lean more)
    float clumpTiltMod = (1.0 - clumpDist / GRASS_CLUMP_SCALE) * GRASS_CLUMP_TILT_MODIFIER;
    float tilt = baseTilt + clumpTiltMod;

    // Apply displacement from displacement buffer (player/NPC interaction)
    // Sample the displacement texture to get push direction
    vec2 displacement = sampleDisplacement(vec2(x, z));
    float dispMagnitude = length(displacement);

    if (dispMagnitude > GRASS_DISPLACEMENT_THRESHOLD) {
        // Normalize displacement direction
        vec2 dispDir = displacement / dispMagnitude;

        // Calculate the angle of the displacement direction
        float dispAngle = atan(dispDir.y, dispDir.x);

        // Blend facing toward displacement direction based on magnitude
        // Stronger displacement = blade faces more in push direction
        float facingBlend = clamp(dispMagnitude * GRASS_DISPLACEMENT_BLEND_MAX, 0.0, GRASS_DISPLACEMENT_BLEND_MAX);
        facing = mix(facing, dispAngle, facingBlend);
    }

    // Write instance data (clumpId stored in w for fragment shader color variation)
    instances[slot].positionAndFacing = vec4(worldPos, facing);
    instances[slot].heightHashTilt = vec4(height, bladeHash, tilt, clumpId);
    instances[slot].terrainNormal = vec4(terrainNormal, 0.0);
}

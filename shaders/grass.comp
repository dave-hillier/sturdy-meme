#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct GrassInstance {
    vec4 positionAndFacing;  // xyz = position, w = facing angle
    vec4 heightHashTilt;     // x = height, y = hash, z = tilt, w = unused
};

struct DrawIndirectCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

layout(std430, binding = 0) buffer InstanceBuffer {
    GrassInstance instances[];
};

layout(std430, binding = 1) buffer IndirectBuffer {
    DrawIndirectCommand drawCmd;
};

layout(binding = 2) uniform GrassUniforms {
    vec4 cameraPosition;
    vec4 frustumPlanes[6];
    float maxDrawDistance;
    float lodTransitionStart;
    float lodTransitionEnd;
    float padding;
} uniforms;

layout(push_constant) uniform PushConstants {
    float time;
} push;

// Hash functions for procedural placement
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hash2(vec2 p) {
    return fract(sin(dot(p, vec2(269.5, 183.3))) * 43758.5453);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;

    // Set vertexCount atomically (buffer is pre-cleared to 0 by CPU, so atomicMax ensures it becomes 15)
    // This is safe even with multiple workgroups since they all write the same value
    if (idx == 0) {
        atomicMax(drawCmd.vertexCount, 15);  // 5 segments * 3 vertices per triangle
    }

    // Generate grass positions in a grid pattern
    // Grid: 100x100 = 10000 potential blades
    uint gridSize = 100;
    if (idx >= gridSize * gridSize) return;

    uint gridX = idx % gridSize;
    uint gridZ = idx / gridSize;

    // Map to world space (-25 to +25, centered on origin)
    float spacing = 0.5;
    float x = (float(gridX) - float(gridSize) / 2.0) * spacing;
    float z = (float(gridZ) - float(gridSize) / 2.0) * spacing;

    // Add some randomness to position (jitter)
    vec2 cell = vec2(gridX, gridZ);
    float h1 = hash(cell);
    float h2 = hash2(cell);

    x += (h1 - 0.5) * spacing * 0.8;
    z += (hash(cell + vec2(100.0, 0.0)) - 0.5) * spacing * 0.8;

    vec3 worldPos = vec3(x, 0.0, z);

    // Distance culling (relative to camera)
    float distToCamera = length(worldPos - uniforms.cameraPosition.xyz);
    if (distToCamera > uniforms.maxDrawDistance) return;

    // Frustum culling - check against all 6 planes
    vec4 posW = vec4(worldPos, 1.0);
    for (int i = 0; i < 6; i++) {
        // If position is behind any plane (with small margin for blade height), cull it
        if (dot(posW, uniforms.frustumPlanes[i]) < -1.0) return;
    }

    // LOD blade dropping - probabilistically drop blades at distance
    float lodFactor = smoothstep(uniforms.lodTransitionStart,
                                 uniforms.lodTransitionEnd, distToCamera);
    float dropThreshold = lodFactor * 0.75; // Drop up to 75% at max LOD distance
    if (hash(cell + vec2(500.0, 500.0)) < dropThreshold) return;

    // Atomically increment instance count and get our slot
    uint slot = atomicAdd(drawCmd.instanceCount, 1);

    // Generate varied instance properties
    float facing = h1 * 6.28318;           // Random facing direction
    float height = 0.3 + h2 * 0.4;         // Height between 0.3 and 0.7
    float bladeHash = h1;                  // For wind animation
    float tilt = (hash(cell + vec2(50.0, 50.0)) - 0.5) * 0.3;  // Slight tilt

    // Write instance data
    instances[slot].positionAndFacing = vec4(worldPos, facing);
    instances[slot].heightHashTilt = vec4(height, bladeHash, tilt, 0.0);
}

#version 450

// Enable tiled grass mode - this shader variant uses per-tile grid size
// and positions grass relative to tile origin instead of centered on world origin
#define GRASS_TILED_MODE 1

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "grass_constants.glsl"
#include "terrain_height_common.glsl"
#include "instancing_common.glsl"

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_GRASS_COMPUTE_CULLING
#include "ubo_culling.glsl"

// 2D workgroup layout for better texture cache coherency - threads in the same
// workgroup sample nearby terrain/displacement texels (16x16 = 256 threads)
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct GrassInstance {
    vec4 positionAndFacing;  // xyz = position, w = facing angle
    vec4 heightHashTilt;     // x = height, y = hash, z = tilt, w = clumpId
    vec4 terrainNormal;      // xyz = terrain normal (for tangent alignment), w = unused
};

// DrawIndirectCommand is now provided by instancing_common.glsl

layout(std430, binding = BINDING_GRASS_COMPUTE_INSTANCES) buffer InstanceBuffer {
    GrassInstance instances[];
};

layout(std430, binding = BINDING_GRASS_COMPUTE_INDIRECT) buffer IndirectBuffer {
    DrawIndirectCommand drawCmd;
};

// Grass-specific parameters (terrain and displacement)
layout(std140, binding = BINDING_GRASS_COMPUTE_PARAMS) uniform GrassParams {
    vec4 displacementRegion;  // xy = world center, z = region size, w = texel size
    float terrainSize;
    float terrainHeightScale;
    float padding[2];
} grassParams;

// Terrain heightmap for grass placement on terrain
layout(binding = BINDING_GRASS_COMPUTE_HEIGHT_MAP) uniform sampler2D terrainHeightMap;

// Displacement map for player/NPC grass interaction (RG16F - XZ displacement)
layout(binding = BINDING_GRASS_COMPUTE_DISPLACEMENT) uniform sampler2D displacementMap;

// LOD tile array (high-res tiles near camera)
layout(binding = BINDING_GRASS_COMPUTE_TILE_ARRAY) uniform sampler2DArray heightMapTiles;

// Tile info buffer - world bounds for each active tile
struct TileInfo {
    vec4 worldBounds;    // xy = min corner, zw = max corner
    vec4 uvScaleOffset;  // xy = scale, zw = offset
    ivec4 layerIndex;    // x = layer index in tile array, yzw = padding
};
layout(std430, binding = BINDING_GRASS_COMPUTE_TILE_INFO) readonly buffer TileInfoBuffer {
    uint activeTileCount;
    uint padding1;
    uint padding2;
    uint padding3;
    TileInfo tiles[];
};

// Include tile cache common after defining prerequisites
#include "tile_cache_common.glsl"

layout(push_constant) uniform PushConstants {
    float time;
    float tileOriginX;   // World X origin of this tile
    float tileOriginZ;   // World Z origin of this tile
    float tileSize;      // Tile size in world units (varies by LOD: 64, 128, 256)
    float spacingMult;   // Spacing multiplier for this LOD (1.0, 2.0, 4.0)
    uint lodLevel;       // LOD level (0 = high detail, 1 = medium, 2 = low)
    float padding[2];
} push;

// Tiled mode uses per-tile grid size but shared global instance buffer
#define EFFECTIVE_GRID_SIZE GRASS_TILE_GRID_SIZE
// All tiles share one instance buffer, so use global limit (not per-tile)
#define EFFECTIVE_MAX_INSTANCES GRASS_MAX_INSTANCES

// LOD transition blade dropping
// Ghost of Tsushima: "high LOD tiles drop 3 out of every 4 grass blades
// before they transition to the low LOD tiles"
//
// This function implements deterministic blade dropping where we drop exactly
// the blades that won't exist at the next LOD level:
// - LOD 0→1: Drop 3/4 of blades (keep only those at even X AND even Z grid positions)
// - LOD 1→2: Drop 3/4 of remaining (keep only those at positions divisible by 4)
//
// worldCell: base-spacing-aligned grid cell (used for subset selection)
// distToCamera: distance to camera for transition zone calculation
// lodLevel: current tile's LOD level
bool shouldDropForLodTransition(vec2 worldCell, float distToCamera, uint lodLevel) {
    // For LOD 0: progressively drop blades that won't exist at LOD 1
    if (lodLevel == 0) {
        // Transition zone starts at LOD0_DISTANCE_END - TRANSITION_ZONE
        float transitionStart = GRASS_LOD0_DISTANCE_END - GRASS_LOD_TRANSITION_ZONE;

        if (distToCamera > transitionStart) {
            // Calculate how far into transition zone we are (0 at start, 1 at end)
            float t = (distToCamera - transitionStart) / GRASS_LOD_TRANSITION_ZONE;
            t = clamp(t, 0.0, 1.0);

            // Check if this blade will exist at LOD 1
            // LOD 1 has 2x spacing, so only blades at even grid positions survive
            ivec2 iCell = ivec2(worldCell);
            bool survivesAtLod1 = ((iCell.x & 1) == 0) && ((iCell.y & 1) == 0);

            // If blade won't survive at LOD 1, progressively drop it
            if (!survivesAtLod1) {
                // Use position-based hash for smooth staggered dropping
                float dropHash = hash2D(worldCell + vec2(850.0, 850.0));
                return dropHash < t;
            }
        }
    }
    // For LOD 1: progressively drop blades that won't exist at LOD 2
    else if (lodLevel == 1) {
        float transitionStart = GRASS_LOD1_DISTANCE_END - GRASS_LOD_TRANSITION_ZONE;

        if (distToCamera > transitionStart) {
            float t = (distToCamera - transitionStart) / GRASS_LOD_TRANSITION_ZONE;
            t = clamp(t, 0.0, 1.0);

            // Check if this blade will exist at LOD 2
            // LOD 2 has 4x spacing, so only blades at positions divisible by 4 survive
            ivec2 iCell = ivec2(worldCell);
            bool survivesAtLod2 = ((iCell.x & 3) == 0) && ((iCell.y & 3) == 0);

            if (!survivesAtLod2) {
                float dropHash = hash2D(worldCell + vec2(850.0, 850.0));
                return dropHash < t;
            }
        }
    }
    // LOD 2 is the furthest, no transition dropping needed

    return false;
}

// Hash functions - use instancing_common.glsl versions
// Local aliases for compatibility with existing code
#define hash(p) hash2D(p)
#define hash2(p) hash2D_alt(p)
#define hash2v(p) hash2D_vec2(p)

// Calculate terrain normal from heightmap gradient with tile cache support
vec3 calculateTerrainNormal(vec2 uv, vec2 worldXZ) {
    return calculateNormalWithTileCache(terrainHeightMap, heightMapTiles, uv, worldXZ,
                                         grassParams.terrainSize, grassParams.terrainHeightScale, activeTileCount);
}

// Convert world position to displacement map UV coordinates
vec2 worldPosToDispUV(vec2 worldPos) {
    vec2 regionCenter = grassParams.displacementRegion.xy;
    float regionSize = grassParams.displacementRegion.z;

    // Convert world pos to UV: center of region maps to UV(0.5, 0.5)
    vec2 offset = worldPos - regionCenter;
    vec2 uv = offset / regionSize + 0.5;

    return uv;
}

// Sample displacement from the displacement buffer texture
// Returns: xy = displacement direction in XZ plane
vec2 sampleDisplacement(vec2 worldPos) {
    vec2 uv = worldPosToDispUV(worldPos);

    // Check if within displacement region bounds
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        return vec2(0.0);
    }

    // Sample displacement (RG = XZ displacement)
    return texture(displacementMap, uv).rg;
}

// Voronoi-based clump calculation
// Returns clumpId (0-1), clumpDistance, and clumpCenter
void calculateClump(vec2 worldPos, out float clumpId, out float clumpDist, out vec2 clumpCenter) {
    // Scale position to clump space using unified constant
    vec2 scaledPos = worldPos / GRASS_CLUMP_SCALE;
    vec2 cellId = floor(scaledPos);

    float minDist = 10.0;
    vec2 nearestPoint = vec2(0.0);
    float nearestId = 0.0;

    // Check 3x3 neighborhood (9 potential clump centers)
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 neighborCell = cellId + vec2(float(x), float(y));

            // Each cell's clump point is jittered according to hash
            vec2 jitter = hash2v(neighborCell) * 0.8 + 0.1;
            vec2 clumpPoint = (neighborCell + jitter) * GRASS_CLUMP_SCALE;

            float dist = length(worldPos - clumpPoint);
            if (dist < minDist) {
                minDist = dist;
                nearestPoint = clumpPoint;
                nearestId = hash(neighborCell);  // Unique ID per clump (0-1)
            }
        }
    }

    clumpId = nearestId;
    clumpDist = minDist;
    clumpCenter = nearestPoint;
}

void main() {
    // 2D dispatch: use xy directly instead of computing from flattened index
    uint gridX = gl_GlobalInvocationID.x;
    uint gridZ = gl_GlobalInvocationID.y;

    // Set vertexCount (only first thread writes this constant value)
    if (gridX == 0 && gridZ == 0) {
        drawCmd.vertexCount = GRASS_VERTICES_PER_BLADE;
    }

    // Generate grass positions in a grid pattern per tile
    if (gridX >= EFFECTIVE_GRID_SIZE || gridZ >= EFFECTIVE_GRID_SIZE) return;

    // Calculate effective spacing based on LOD level
    // Higher LOD levels have larger spacing -> lower grass density
    float effectiveSpacing = GRASS_SPACING * push.spacingMult;

    // Map to world space - position relative to tile origin
    float x = push.tileOriginX + float(gridX) * effectiveSpacing;
    float z = push.tileOriginZ + float(gridZ) * effectiveSpacing;

    // Add some randomness to position (jitter)
    // IMPORTANT: Use BASE spacing for cell calculation to ensure consistent hashing
    // across LOD levels. This way, a blade at world position (64, 0) gets the same
    // hash whether generated by a LOD 0 or LOD 1 tile.
    // Round to nearest base grid cell to avoid floating point instability
    vec2 worldCell = round(vec2(x, z) / GRASS_SPACING);
    vec2 cell = worldCell;
    float h1 = hash(cell);
    float h2 = hash2(cell);

    // Scale jitter with effective spacing to maintain visual randomness at all LOD levels
    // At LOD 0: jitter = 0.16m (80% of 0.2m spacing)
    // At LOD 1: jitter = 0.32m (80% of 0.4m spacing)
    // At LOD 2: jitter = 0.64m (80% of 0.8m spacing)
    // This prevents lower LODs from appearing too uniform/grid-like
    // The position difference at transition distances (43m+, 86m+) is imperceptible
    x += (h1 - 0.5) * effectiveSpacing * GRASS_JITTER_FACTOR;
    z += (hash(cell + vec2(100.0, 0.0)) - 0.5) * effectiveSpacing * GRASS_JITTER_FACTOR;

    // Sample terrain heightmap to get Y position
    vec2 terrainUV = vec2(x, z) / grassParams.terrainSize + 0.5;

    // Check if grass is within terrain bounds
    if (terrainUV.x < 0.0 || terrainUV.x > 1.0 || terrainUV.y < 0.0 || terrainUV.y > 1.0) return;

    // Sample terrain height with tile cache support
    float terrainY = sampleHeightWithTileCache(terrainHeightMap, heightMapTiles, terrainUV,
                                                vec2(x, z), grassParams.terrainHeightScale, activeTileCount);

    vec3 worldPos = vec3(x, terrainY, z);

    // Calculate terrain normal for tangent-aligned grass placement
    vec3 terrainNormal = calculateTerrainNormal(terrainUV, vec2(x, z));

    // Distance culling
    float distToCamera = getDistanceToCamera(worldPos, culling.cameraPosition.xyz);
    if (distToCamera > culling.maxDrawDistance) return;

    // Frustum culling
    if (!isInFrustum(culling.frustumPlanes, worldPos, GRASS_FRUSTUM_MARGIN)) return;

    // LOD transition blade dropping (Ghost of Tsushima style)
    // Drop blades at LOD level boundaries for smooth transitions
    // Uses worldCell to determine if blade survives at next LOD level
    if (shouldDropForLodTransition(cell, distToCamera, push.lodLevel)) return;

    // Use subgroup operations to batch atomic updates
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    uint baseSlot = 0;
    if (subgroupElect()) {
        baseSlot = atomicAdd(drawCmd.instanceCount, activeCount);
    }
    baseSlot = subgroupBroadcastFirst(baseSlot);
    uint slot = baseSlot + laneOffset;

    // Clamp to max instances - prevent buffer overflow
    if (slot >= EFFECTIVE_MAX_INSTANCES) {
        // Cap the instance count to prevent draw from reading garbage
        // This is a race but worst case we draw slightly fewer instances
        if (subgroupElect()) {
            atomicMin(drawCmd.instanceCount, EFFECTIVE_MAX_INSTANCES);
        }
        return;
    }

    // Calculate clumping
    float clumpId, clumpDist;
    vec2 clumpCenter;
    calculateClump(vec2(x, z), clumpId, clumpDist, clumpCenter);

    // Base random properties
    float randomFacing = h1 * GRASS_TWO_PI;
    float baseHeight = GRASS_HEIGHT_MIN + h2 * GRASS_HEIGHT_RANGE;
    float bladeHash = h1;
    float baseTilt = (hash(cell + vec2(50.0, 50.0)) - 0.5) * GRASS_TILT_RANGE;

    // Apply clump height influence
    float clumpHeightMod = mix(1.0, 0.6 + clumpId * 0.8, GRASS_CLUMP_HEIGHT_INFLUENCE);
    float height = baseHeight * clumpHeightMod;

    // Apply clump facing influence
    vec2 toClumpCenter = clumpCenter - vec2(x, z);
    float distToClump = length(toClumpCenter);
    if (distToClump > 0.01) {
        toClumpCenter = normalize(toClumpCenter);
    } else {
        toClumpCenter = vec2(0.0, 1.0);
    }

    float clumpFacingAngle = atan(toClumpCenter.y, toClumpCenter.x);
    float facingTarget = clumpId < 0.5 ? clumpFacingAngle : clumpFacingAngle + 3.14159;
    float facing = mix(randomFacing, facingTarget, GRASS_CLUMP_FACING_INFLUENCE);

    // Tilt influenced by distance to clump center
    float clumpTiltMod = (1.0 - clumpDist / GRASS_CLUMP_SCALE) * GRASS_CLUMP_TILT_MODIFIER;
    float tilt = baseTilt + clumpTiltMod;

    // Apply displacement from player/NPC interaction
    vec2 displacement = sampleDisplacement(vec2(x, z));
    float dispMagnitude = length(displacement);

    if (dispMagnitude > GRASS_DISPLACEMENT_THRESHOLD) {
        vec2 dispDir = displacement / dispMagnitude;
        float dispAngle = atan(dispDir.y, dispDir.x);
        float facingBlend = clamp(dispMagnitude * GRASS_DISPLACEMENT_BLEND_MAX, 0.0, GRASS_DISPLACEMENT_BLEND_MAX);
        facing = mix(facing, dispAngle, facingBlend);
    }

    // Write instance data
    instances[slot].positionAndFacing = vec4(worldPos, facing);
    instances[slot].heightHashTilt = vec4(height, bladeHash, tilt, clumpId);
    instances[slot].terrainNormal = vec4(terrainNormal, 0.0);
}

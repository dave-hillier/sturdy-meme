#version 450

// Simplified grass compute shader with continuous stochastic culling
// No discrete LOD levels - just distance-based probability culling

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "grass_constants.glsl"
#include "terrain_height_common.glsl"
#include "instancing_common.glsl"

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_GRASS_COMPUTE_CULLING
#include "ubo_culling.glsl"

// 2D workgroup layout for better texture cache coherency
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct GrassInstance {
    vec4 positionAndFacing;  // xyz = position, w = facing angle
    vec4 heightHashTilt;     // x = height, y = hash, z = tilt, w = clumpId
    vec4 terrainNormal;      // xyz = terrain normal (for tangent alignment), w = unused
};

layout(std430, binding = BINDING_GRASS_COMPUTE_INSTANCES) buffer InstanceBuffer {
    GrassInstance instances[];
};

layout(std430, binding = BINDING_GRASS_COMPUTE_INDIRECT) buffer IndirectBuffer {
    DrawIndirectCommand drawCmd;
};

// Grass-specific parameters (terrain and displacement)
layout(std140, binding = BINDING_GRASS_COMPUTE_PARAMS) uniform GrassParams {
    vec4 displacementRegion;  // xy = world center, z = region size, w = texel size
    float terrainSize;
    float terrainHeightScale;
    float padding[2];
} grassParams;

// Terrain heightmap for grass placement on terrain
layout(binding = BINDING_GRASS_COMPUTE_HEIGHT_MAP) uniform sampler2D terrainHeightMap;

// Displacement map for player/NPC grass interaction (RG16F - XZ displacement)
layout(binding = BINDING_GRASS_COMPUTE_DISPLACEMENT) uniform sampler2D displacementMap;

// Hole mask tile array for terrain cutouts (caves, wells) - R8: 0=solid, 1=hole
layout(binding = BINDING_GRASS_COMPUTE_HOLE_MASK) uniform sampler2DArray holeMaskTiles;

// LOD tile array (high-res tiles near camera)
layout(binding = BINDING_GRASS_COMPUTE_TILE_ARRAY) uniform sampler2DArray heightMapTiles;

// Tile info buffer - world bounds for each active tile
struct TileInfo {
    vec4 worldBounds;    // xy = min corner, zw = max corner
    vec4 uvScaleOffset;  // xy = scale, zw = offset
    ivec4 layerIndex;    // x = layer index in tile array, yzw = padding
};
layout(std430, binding = BINDING_GRASS_COMPUTE_TILE_INFO) readonly buffer TileInfoBuffer {
    uint activeTileCount;
    uint padding1;
    uint padding2;
    uint padding3;
    TileInfo tiles[];
};

// Include tile cache common after defining prerequisites
#include "tile_cache_common.glsl"

layout(push_constant) uniform PushConstants {
    float time;
    float tileOriginX;   // World X origin of this tile
    float tileOriginZ;   // World Z origin of this tile
    float tileSize;      // Tile size in world units
    float spacing;       // Blade spacing (always base spacing, no LOD multiplier)
    uint tileIndex;      // Tile index for debugging
    float unused1;       // Padding
    float unused2;       // Padding
} push;

// Hash functions - use instancing_common.glsl versions
#define hash(p) hash2D(p)
#define hash2(p) hash2D_alt(p)
#define hash2v(p) hash2D_vec2(p)

// Continuous stochastic culling based on distance
// Returns true if blade should be dropped (culled)
// Uses smooth probability falloff with power curve for natural density transition
bool shouldCullByDistance(vec2 worldPos, float distToCamera) {
    // Full density within start distance
    if (distToCamera <= GRASS_CULL_START_DISTANCE) {
        return false;
    }

    // No grass beyond end distance (hard cutoff for performance)
    if (distToCamera >= GRASS_CULL_END_DISTANCE) {
        return true;
    }

    // Calculate cull probability with power curve
    // t goes from 0 at start to 1 at end
    float t = (distToCamera - GRASS_CULL_START_DISTANCE) /
              (GRASS_CULL_END_DISTANCE - GRASS_CULL_START_DISTANCE);

    // Apply power curve - pow(t, POWER) gives slow initial falloff, fast at end
    // POWER=2: quadratic, POWER=3: cubic (denser near camera)
    float cullProbability = pow(t, GRASS_CULL_POWER);

    // Use position-based hash for temporally stable culling
    // The hash ensures the same blade is consistently shown/hidden
    float bladeHash = hash(worldPos + vec2(7919.0, 7927.0));

    // Cull if blade's hash falls in the cull probability range
    return bladeHash < cullProbability;
}

// Calculate terrain normal from heightmap gradient with tile cache support
vec3 calculateTerrainNormal(vec2 uv, vec2 worldXZ) {
    return calculateNormalWithTileCache(terrainHeightMap, heightMapTiles, uv, worldXZ,
                                         grassParams.terrainSize, grassParams.terrainHeightScale, activeTileCount);
}

// Convert world position to displacement map UV coordinates
vec2 worldPosToDispUV(vec2 worldPos) {
    vec2 regionCenter = grassParams.displacementRegion.xy;
    float regionSize = grassParams.displacementRegion.z;

    // Convert world pos to UV: center of region maps to UV(0.5, 0.5)
    vec2 offset = worldPos - regionCenter;
    vec2 uv = offset / regionSize + 0.5;

    return uv;
}

// Sample displacement from the displacement buffer texture
vec2 sampleDisplacement(vec2 worldPos) {
    vec2 uv = worldPosToDispUV(worldPos);

    // Check if within displacement region bounds
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        return vec2(0.0);
    }

    // Sample displacement (RG = XZ displacement)
    return texture(displacementMap, uv).rg;
}

// Voronoi-based clump calculation
void calculateClump(vec2 worldPos, out float clumpId, out float clumpDist, out vec2 clumpCenter) {
    vec2 scaledPos = worldPos / GRASS_CLUMP_SCALE;
    vec2 cellId = floor(scaledPos);

    float minDist = 10.0;
    vec2 nearestPoint = vec2(0.0);
    float nearestId = 0.0;

    // Check 3x3 neighborhood
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 neighborCell = cellId + vec2(float(x), float(y));
            vec2 jitter = hash2v(neighborCell) * 0.8 + 0.1;
            vec2 clumpPoint = (neighborCell + jitter) * GRASS_CLUMP_SCALE;

            float dist = length(worldPos - clumpPoint);
            if (dist < minDist) {
                minDist = dist;
                nearestPoint = clumpPoint;
                nearestId = hash(neighborCell);
            }
        }
    }

    clumpId = nearestId;
    clumpDist = minDist;
    clumpCenter = nearestPoint;
}

void main() {
    uint gridX = gl_GlobalInvocationID.x;
    uint gridZ = gl_GlobalInvocationID.y;

    // Set vertexCount (only first thread writes this constant value)
    if (gridX == 0 && gridZ == 0) {
        drawCmd.vertexCount = GRASS_VERTICES_PER_BLADE;
    }

    // Bounds check - extend by 1 to cover tile edge (prevents gaps between tiles)
    if (gridX > GRASS_TILE_GRID_SIZE || gridZ > GRASS_TILE_GRID_SIZE) return;

    // Calculate world position relative to tile origin
    float x = push.tileOriginX + float(gridX) * push.spacing;
    float z = push.tileOriginZ + float(gridZ) * push.spacing;

    // Calculate cell for consistent hashing
    vec2 worldCell = round(vec2(x, z) / GRASS_SPACING);
    vec2 cell = worldCell;

    // Add jitter for natural distribution
    vec2 jitterHash = hash2v(cell);
    x += (jitterHash.x - 0.5) * push.spacing * GRASS_JITTER_FACTOR;
    z += (jitterHash.y - 0.5) * push.spacing * GRASS_JITTER_FACTOR;

    // Sample terrain heightmap
    vec2 terrainUV = vec2(x, z) / grassParams.terrainSize + 0.5;

    // Check if grass is within terrain bounds
    if (terrainUV.x < 0.0 || terrainUV.x > 1.0 || terrainUV.y < 0.0 || terrainUV.y > 1.0) return;

    // Check hole mask - don't spawn grass in terrain holes (caves, wells)
    float holeMaskValue = sampleHoleMaskWithTileCache(holeMaskTiles, vec2(x, z), activeTileCount);
    if (holeMaskValue > 0.5) return;

    // Sample terrain height with tile cache support
    float terrainY = sampleHeightWithTileCache(terrainHeightMap, heightMapTiles, terrainUV,
                                                vec2(x, z), grassParams.terrainHeightScale, activeTileCount);

    vec3 worldPos = vec3(x, terrainY, z);

    // Calculate terrain normal for tangent-aligned grass placement
    vec3 terrainNormal = calculateTerrainNormal(terrainUV, vec2(x, z));

    // Distance culling (hard cutoff)
    float distToCamera = getDistanceToCamera(worldPos, culling.cameraPosition.xyz);
    if (distToCamera > culling.maxDrawDistance) return;

    // Frustum culling
    if (!isInFrustum(culling.frustumPlanes, worldPos, GRASS_FRUSTUM_MARGIN)) return;

    // Continuous stochastic distance-based culling
    // This provides smooth density falloff instead of discrete LOD popping
    if (shouldCullByDistance(vec2(x, z), distToCamera)) return;

    // Use subgroup operations to batch atomic updates
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    uint baseSlot = 0;
    if (subgroupElect()) {
        baseSlot = atomicAdd(drawCmd.instanceCount, activeCount);
    }
    baseSlot = subgroupBroadcastFirst(baseSlot);
    uint slot = baseSlot + laneOffset;

    // Clamp to max instances
    if (slot >= GRASS_MAX_INSTANCES) {
        if (subgroupElect()) {
            atomicMin(drawCmd.instanceCount, GRASS_MAX_INSTANCES);
        }
        return;
    }

    // Calculate clumping
    float clumpId, clumpDist;
    vec2 clumpCenter;
    calculateClump(vec2(x, z), clumpId, clumpDist, clumpCenter);

    // Generate blade properties using final world position
    vec2 bladePos = vec2(x, z);
    vec2 bladeProps1 = hash2v(bladePos);
    vec2 bladeProps2 = hash2v(bladePos + vec2(73.0, 91.0));

    float randomFacing = bladeProps1.x * GRASS_TWO_PI;
    float baseHeight = GRASS_HEIGHT_MIN + bladeProps1.y * GRASS_HEIGHT_RANGE;
    float bladeHash = bladeProps2.x;
    float baseTilt = (bladeProps2.y - 0.5) * GRASS_TILT_RANGE;

    // Apply clump height influence
    float clumpHeightMod = mix(1.0, 0.6 + clumpId * 0.8, GRASS_CLUMP_HEIGHT_INFLUENCE);
    float height = baseHeight * clumpHeightMod;

    // Apply clump facing influence
    vec2 toClumpCenter = clumpCenter - vec2(x, z);
    float distToClump = length(toClumpCenter);
    if (distToClump > 0.01) {
        toClumpCenter = normalize(toClumpCenter);
    } else {
        toClumpCenter = vec2(0.0, 1.0);
    }

    float clumpFacingAngle = atan(toClumpCenter.y, toClumpCenter.x);
    float facingTarget = clumpId < 0.5 ? clumpFacingAngle : clumpFacingAngle + 3.14159;
    float facing = mix(randomFacing, facingTarget, GRASS_CLUMP_FACING_INFLUENCE);

    // Tilt influenced by distance to clump center
    float clumpTiltMod = (1.0 - clumpDist / GRASS_CLUMP_SCALE) * GRASS_CLUMP_TILT_MODIFIER;
    float tilt = baseTilt + clumpTiltMod;

    // Apply displacement from player/NPC interaction
    vec2 displacement = sampleDisplacement(vec2(x, z));
    float dispMagnitude = length(displacement);

    if (dispMagnitude > GRASS_DISPLACEMENT_THRESHOLD) {
        vec2 dispDir = displacement / dispMagnitude;
        float dispAngle = atan(dispDir.y, dispDir.x);
        float facingBlend = clamp(dispMagnitude * GRASS_DISPLACEMENT_BLEND_MAX, 0.0, GRASS_DISPLACEMENT_BLEND_MAX);
        facing = mix(facing, dispAngle, facingBlend);
    }

    // Write instance data
    instances[slot].positionAndFacing = vec4(worldPos, facing);
    instances[slot].heightHashTilt = vec4(height, bladeHash, tilt, clumpId);
    instances[slot].terrainNormal = vec4(terrainNormal, 0.0);
}

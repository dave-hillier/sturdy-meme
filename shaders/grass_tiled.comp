#version 450

// Enable tiled grass mode - this shader variant uses per-tile grid size
// and positions grass relative to tile origin instead of centered on world origin
#define GRASS_TILED_MODE 1

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "grass_constants.glsl"
#include "terrain_height_common.glsl"
#include "instancing_common.glsl"

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_GRASS_COMPUTE_CULLING
#include "ubo_culling.glsl"

// 2D workgroup layout for better texture cache coherency - threads in the same
// workgroup sample nearby terrain/displacement texels (16x16 = 256 threads)
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct GrassInstance {
    vec4 positionAndFacing;  // xyz = position, w = facing angle
    vec4 heightHashTilt;     // x = height, y = hash, z = tilt, w = clumpId
    vec4 terrainNormal;      // xyz = terrain normal (for tangent alignment), w = unused
};

// DrawIndirectCommand is now provided by instancing_common.glsl

layout(std430, binding = BINDING_GRASS_COMPUTE_INSTANCES) buffer InstanceBuffer {
    GrassInstance instances[];
};

layout(std430, binding = BINDING_GRASS_COMPUTE_INDIRECT) buffer IndirectBuffer {
    DrawIndirectCommand drawCmd;
};

// Grass-specific parameters (terrain and displacement)
layout(std140, binding = BINDING_GRASS_COMPUTE_PARAMS) uniform GrassParams {
    vec4 displacementRegion;  // xy = world center, z = region size, w = texel size
    float terrainSize;
    float terrainHeightScale;
    float padding[2];
} grassParams;

// Terrain heightmap for grass placement on terrain
layout(binding = BINDING_GRASS_COMPUTE_HEIGHT_MAP) uniform sampler2D terrainHeightMap;

// Displacement map for player/NPC grass interaction (RG16F - XZ displacement)
layout(binding = BINDING_GRASS_COMPUTE_DISPLACEMENT) uniform sampler2D displacementMap;

// LOD tile array (high-res tiles near camera)
layout(binding = BINDING_GRASS_COMPUTE_TILE_ARRAY) uniform sampler2DArray heightMapTiles;

// Tile info buffer - world bounds for each active tile
struct TileInfo {
    vec4 worldBounds;    // xy = min corner, zw = max corner
    vec4 uvScaleOffset;  // xy = scale, zw = offset
    ivec4 layerIndex;    // x = layer index in tile array, yzw = padding
};
layout(std430, binding = BINDING_GRASS_COMPUTE_TILE_INFO) readonly buffer TileInfoBuffer {
    uint activeTileCount;
    uint padding1;
    uint padding2;
    uint padding3;
    TileInfo tiles[];
};

// Include tile cache common after defining prerequisites
#include "tile_cache_common.glsl"

layout(push_constant) uniform PushConstants {
    float time;
    float tileOriginX;  // World X origin of this tile
    float tileOriginZ;  // World Z origin of this tile
    float padding;
} push;

// Tiled mode uses per-tile grid size and instance limits
#define EFFECTIVE_GRID_SIZE GRASS_TILE_GRID_SIZE
#define EFFECTIVE_MAX_INSTANCES GRASS_MAX_INSTANCES_PER_TILE

// Hash functions - use instancing_common.glsl versions
// Local aliases for compatibility with existing code
#define hash(p) hash2D(p)
#define hash2(p) hash2D_alt(p)
#define hash2v(p) hash2D_vec2(p)

// Calculate terrain normal from heightmap gradient with tile cache support
vec3 calculateTerrainNormal(vec2 uv, vec2 worldXZ) {
    return calculateNormalWithTileCache(terrainHeightMap, heightMapTiles, uv, worldXZ,
                                         grassParams.terrainSize, grassParams.terrainHeightScale, activeTileCount);
}

// Convert world position to displacement map UV coordinates
vec2 worldPosToDispUV(vec2 worldPos) {
    vec2 regionCenter = grassParams.displacementRegion.xy;
    float regionSize = grassParams.displacementRegion.z;

    // Convert world pos to UV: center of region maps to UV(0.5, 0.5)
    vec2 offset = worldPos - regionCenter;
    vec2 uv = offset / regionSize + 0.5;

    return uv;
}

// Sample displacement from the displacement buffer texture
// Returns: xy = displacement direction in XZ plane
vec2 sampleDisplacement(vec2 worldPos) {
    vec2 uv = worldPosToDispUV(worldPos);

    // Check if within displacement region bounds
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        return vec2(0.0);
    }

    // Sample displacement (RG = XZ displacement)
    return texture(displacementMap, uv).rg;
}

// Voronoi-based clump calculation
// Returns clumpId (0-1), clumpDistance, and clumpCenter
void calculateClump(vec2 worldPos, out float clumpId, out float clumpDist, out vec2 clumpCenter) {
    // Scale position to clump space using unified constant
    vec2 scaledPos = worldPos / GRASS_CLUMP_SCALE;
    vec2 cellId = floor(scaledPos);

    float minDist = 10.0;
    vec2 nearestPoint = vec2(0.0);
    float nearestId = 0.0;

    // Check 3x3 neighborhood (9 potential clump centers)
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 neighborCell = cellId + vec2(float(x), float(y));

            // Each cell's clump point is jittered according to hash
            vec2 jitter = hash2v(neighborCell) * 0.8 + 0.1;
            vec2 clumpPoint = (neighborCell + jitter) * GRASS_CLUMP_SCALE;

            float dist = length(worldPos - clumpPoint);
            if (dist < minDist) {
                minDist = dist;
                nearestPoint = clumpPoint;
                nearestId = hash(neighborCell);  // Unique ID per clump (0-1)
            }
        }
    }

    clumpId = nearestId;
    clumpDist = minDist;
    clumpCenter = nearestPoint;
}

void main() {
    // 2D dispatch: use xy directly instead of computing from flattened index
    uint gridX = gl_GlobalInvocationID.x;
    uint gridZ = gl_GlobalInvocationID.y;

    // Set vertexCount (only first thread writes this constant value)
    if (gridX == 0 && gridZ == 0) {
        drawCmd.vertexCount = GRASS_VERTICES_PER_BLADE;
    }

    // Generate grass positions in a grid pattern per tile
    if (gridX >= EFFECTIVE_GRID_SIZE || gridZ >= EFFECTIVE_GRID_SIZE) return;

    // Map to world space - position relative to tile origin
    float x = push.tileOriginX + float(gridX) * GRASS_SPACING;
    float z = push.tileOriginZ + float(gridZ) * GRASS_SPACING;

    // Add some randomness to position (jitter)
    // Use world-space position for hash to ensure unique patterns per tile
    vec2 worldCell = vec2(x, z) / GRASS_SPACING;
    vec2 cell = worldCell;
    float h1 = hash(cell);
    float h2 = hash2(cell);

    x += (h1 - 0.5) * GRASS_SPACING * GRASS_JITTER_FACTOR;
    z += (hash(cell + vec2(100.0, 0.0)) - 0.5) * GRASS_SPACING * GRASS_JITTER_FACTOR;

    // Sample terrain heightmap to get Y position
    vec2 terrainUV = vec2(x, z) / grassParams.terrainSize + 0.5;

    // Check if grass is within terrain bounds
    if (terrainUV.x < 0.0 || terrainUV.x > 1.0 || terrainUV.y < 0.0 || terrainUV.y > 1.0) return;

    // Sample terrain height with tile cache support
    float terrainY = sampleHeightWithTileCache(terrainHeightMap, heightMapTiles, terrainUV,
                                                vec2(x, z), grassParams.terrainHeightScale, activeTileCount);

    vec3 worldPos = vec3(x, terrainY, z);

    // Calculate terrain normal for tangent-aligned grass placement
    vec3 terrainNormal = calculateTerrainNormal(terrainUV, vec2(x, z));

    // Distance culling
    float distToCamera = getDistanceToCamera(worldPos, culling.cameraPosition.xyz);
    if (distToCamera > culling.maxDrawDistance) return;

    // Frustum culling
    if (!isInFrustum(culling.frustumPlanes, worldPos, GRASS_FRUSTUM_MARGIN)) return;

    // LOD blade dropping
    float instanceHash = hash(cell + vec2(500.0, 500.0));
    if (isLodEnabled() && lodCull(distToCamera, culling.lodTransitionStart, culling.lodTransitionEnd,
                                   culling.maxLodDropRate, instanceHash)) return;

    // Use subgroup operations to batch atomic updates
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    uint baseSlot = 0;
    if (subgroupElect()) {
        baseSlot = atomicAdd(drawCmd.instanceCount, activeCount);
    }
    baseSlot = subgroupBroadcastFirst(baseSlot);
    uint slot = baseSlot + laneOffset;

    // Clamp to max instances per tile
    if (slot >= EFFECTIVE_MAX_INSTANCES) return;

    // Calculate clumping
    float clumpId, clumpDist;
    vec2 clumpCenter;
    calculateClump(vec2(x, z), clumpId, clumpDist, clumpCenter);

    // Base random properties
    float randomFacing = h1 * GRASS_TWO_PI;
    float baseHeight = GRASS_HEIGHT_MIN + h2 * GRASS_HEIGHT_RANGE;
    float bladeHash = h1;
    float baseTilt = (hash(cell + vec2(50.0, 50.0)) - 0.5) * GRASS_TILT_RANGE;

    // Apply clump height influence
    float clumpHeightMod = mix(1.0, 0.6 + clumpId * 0.8, GRASS_CLUMP_HEIGHT_INFLUENCE);
    float height = baseHeight * clumpHeightMod;

    // Apply clump facing influence
    vec2 toClumpCenter = clumpCenter - vec2(x, z);
    float distToClump = length(toClumpCenter);
    if (distToClump > 0.01) {
        toClumpCenter = normalize(toClumpCenter);
    } else {
        toClumpCenter = vec2(0.0, 1.0);
    }

    float clumpFacingAngle = atan(toClumpCenter.y, toClumpCenter.x);
    float facingTarget = clumpId < 0.5 ? clumpFacingAngle : clumpFacingAngle + 3.14159;
    float facing = mix(randomFacing, facingTarget, GRASS_CLUMP_FACING_INFLUENCE);

    // Tilt influenced by distance to clump center
    float clumpTiltMod = (1.0 - clumpDist / GRASS_CLUMP_SCALE) * GRASS_CLUMP_TILT_MODIFIER;
    float tilt = baseTilt + clumpTiltMod;

    // Apply displacement from player/NPC interaction
    vec2 displacement = sampleDisplacement(vec2(x, z));
    float dispMagnitude = length(displacement);

    if (dispMagnitude > GRASS_DISPLACEMENT_THRESHOLD) {
        vec2 dispDir = displacement / dispMagnitude;
        float dispAngle = atan(dispDir.y, dispDir.x);
        float facingBlend = clamp(dispMagnitude * GRASS_DISPLACEMENT_BLEND_MAX, 0.0, GRASS_DISPLACEMENT_BLEND_MAX);
        facing = mix(facing, dispAngle, facingBlend);
    }

    // Write instance data
    instances[slot].positionAndFacing = vec4(worldPos, facing);
    instances[slot].heightHashTilt = vec4(height, bladeHash, tilt, clumpId);
    instances[slot].terrainNormal = vec4(terrainNormal, 0.0);
}

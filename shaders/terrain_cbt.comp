#version 450

// CBT/LEB Terrain Subdivision Compute Shader
// Implements the core subdivision update pass for Concurrent Binary Trees
// Based on the HPG 2020 paper by Jonathan Dupuy (Unity Labs)

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// CBT Data buffer layout:
// [0]: maxDepth (uint32)
// [1]: reserved
// [2..N]: sum reduction tree + bitfield
layout(std430, binding = 0) buffer CBTBuffer {
    uint cbtData[];
};

layout(std430, binding = 1) buffer IndirectDispatch {
    uint dispatchX;
    uint dispatchY;
    uint dispatchZ;
};

layout(std430, binding = 2) buffer IndirectDraw {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

layout(binding = 3) uniform sampler2D heightMap;

layout(push_constant) uniform PushConstants {
    mat4 viewProj;
    vec4 cameraPos;
    vec4 terrainParams;  // x = terrainSize, y = heightScale, z = splitThreshold, w = mergeThreshold
    vec4 screenParams;   // x = width, y = height, z = maxDepth, w = unused
} pc;

// ============== CBT Library Functions ==============

uint cbt_maxDepth() {
    return uint(pc.screenParams.z);
}

// Get the number of bits required to store values at a given level
uint cbt_bitsPerNode(uint depth) {
    // At depth d, each node stores values 0 to 2^(maxDepth-d)
    // Level 0 (root): stores total leaf count
    // Level maxDepth-1: stores 0 or 1 (is leaf or not)
    return cbt_maxDepth() - depth + 1;
}

// Calculate the bit index for a heap index's leaf status in the bitfield
uint cbt_heapIndexToBitIndex(uint heapIndex) {
    // The bitfield stores leaf status for all possible nodes
    // Heap indices start at 1, so we subtract 1 for 0-based indexing
    return heapIndex - 1;
}

// Get the word and bit offset for a given bit index
void cbt_bitIndexToWordAndBit(uint bitIndex, out uint wordIndex, out uint bitOffset) {
    wordIndex = bitIndex / 32u;
    bitOffset = bitIndex % 32u;
}

// Get the start offset of the bitfield in the cbtData buffer
uint cbt_bitfieldOffset() {
    // The bitfield starts after the sum reduction tree
    // For simplicity, we'll place the bitfield starting at index 16
    // (leaving room for sum reduction levels 0-3, each taking ~1-8 uints)
    return 16u;
}

// Check if a node is a leaf by reading the bitfield
bool cbt_isLeaf(uint heapIndex) {
    uint maxD = cbt_maxDepth();
    uint depth = findMSB(heapIndex);

    if (depth >= maxD) return true;  // At max depth, always a leaf

    // A node is a leaf if its bit is set in the bitfield AND
    // neither of its children have their bits set
    uint leftChild = heapIndex * 2u;
    uint rightChild = heapIndex * 2u + 1u;

    // For simplicity in this initial version:
    // Check if this node's descendants exist in the tree
    // Read from sum reduction - a node is a leaf if it contributes 1 to the count

    // Alternative: Check both children bits
    uint bitOffset = cbt_bitfieldOffset();
    uint wordIdx, bitPos;

    // Check if left child bit is set
    cbt_bitIndexToWordAndBit(cbt_heapIndexToBitIndex(leftChild), wordIdx, bitPos);
    bool leftExists = (cbtData[bitOffset + wordIdx] & (1u << bitPos)) != 0u;

    cbt_bitIndexToWordAndBit(cbt_heapIndexToBitIndex(rightChild), wordIdx, bitPos);
    bool rightExists = (cbtData[bitOffset + wordIdx] & (1u << bitPos)) != 0u;

    return !leftExists && !rightExists;
}

// Set a node as existing (has been split)
void cbt_setBit(uint heapIndex, bool value) {
    uint bitOffset = cbt_bitfieldOffset();
    uint wordIdx, bitPos;
    cbt_bitIndexToWordAndBit(cbt_heapIndexToBitIndex(heapIndex), wordIdx, bitPos);

    if (value) {
        atomicOr(cbtData[bitOffset + wordIdx], 1u << bitPos);
    } else {
        atomicAnd(cbtData[bitOffset + wordIdx], ~(1u << bitPos));
    }
}

bool cbt_getBit(uint heapIndex) {
    uint bitOffset = cbt_bitfieldOffset();
    uint wordIdx, bitPos;
    cbt_bitIndexToWordAndBit(cbt_heapIndexToBitIndex(heapIndex), wordIdx, bitPos);
    return (cbtData[bitOffset + wordIdx] & (1u << bitPos)) != 0u;
}

// Get leaf count from root of sum reduction tree
uint cbt_leafCount() {
    return cbtData[0];
}

// Tree navigation
uint cbt_parent(uint heapIndex) {
    return heapIndex / 2u;
}

uint cbt_sibling(uint heapIndex) {
    return heapIndex ^ 1u;
}

uint cbt_leftChild(uint heapIndex) {
    return heapIndex * 2u;
}

uint cbt_rightChild(uint heapIndex) {
    return heapIndex * 2u + 1u;
}

uint cbt_depth(uint heapIndex) {
    return findMSB(heapIndex);
}

// Map leaf index (0 to leafCount-1) to heap index
uint cbt_leafIndexToHeapIndex(uint leafIndex) {
    uint maxD = cbt_maxDepth();
    uint count = 0u;

    // Linear scan starting at heap index 2 (heap index 1 is virtual root)
    for (uint h = 2u; h < (1u << (maxD + 1u)); h++) {
        if (cbt_getBit(h) && cbt_isLeaf(h)) {
            if (count == leafIndex) {
                return h;
            }
            count++;
        }
    }

    // Fallback to base triangles
    return (leafIndex == 0u) ? 2u : 3u;
}

// ============== LEB Library Functions ==============

struct LEBTriangle {
    vec2 v0, v1, v2;
};

// Decode a triangle from its heap index
// CBT structure:
// - Heap index 1: virtual root (not used for rendering)
// - Heap index 2: base triangle 1 (bottom-left of unit square)
// - Heap index 3: base triangle 2 (top-right of unit square)
// - Heap index 4+: subdivided triangles
LEBTriangle leb_decodeTriangle(uint heapIndex) {
    vec2 v0, v1, v2;

    // Handle invalid/edge cases
    if (heapIndex < 2u) {
        heapIndex = 2u;
    }

    // Find which base triangle this node descends from
    // by walking up the tree until we hit node 2 or 3
    uint ancestor = heapIndex;
    while (ancestor > 3u) {
        ancestor = ancestor / 2u;  // parent
    }
    bool isBase2 = (ancestor == 3u);

    // Set up base triangle vertices
    // Both triangles share the diagonal edge. For LEB to work correctly,
    // the shared edge (v1-v2) must be oriented consistently.
    // Triangle 1: v1=(1,0), v2=(0,1) - diagonal goes bottom-right to top-left
    // Triangle 2: v1=(0,1), v2=(1,0) - diagonal goes top-left to bottom-right (OPPOSITE)
    // This is correct for LEB - neighbors have opposite edge orientation
    if (!isBase2) {
        // Base triangle 1: bottom-left half
        v0 = vec2(0.0, 0.0);
        v1 = vec2(1.0, 0.0);
        v2 = vec2(0.0, 1.0);
    } else {
        // Base triangle 2: top-right half (same winding direction)
        v0 = vec2(1.0, 1.0);
        v1 = vec2(0.0, 1.0);
        v2 = vec2(1.0, 0.0);
    }

    // If this is a base triangle (heap index 2 or 3), we're done
    if (heapIndex <= 3u) {
        return LEBTriangle(v0, v1, v2);
    }

    // Apply subdivision by following the path from the base triangle to this node
    uint depth = cbt_depth(heapIndex);

    // Apply subdivision for each level after the base (depth 1)
    // LEB subdivision: bisect the edge opposite to v0 (edge v1-v2)
    for (uint d = 2u; d <= depth; d++) {
        uint bitPos = depth - d;
        uint bit = (heapIndex >> bitPos) & 1u;

        // Bisect: midpoint of edge v1-v2 (the edge opposite to v0)
        vec2 midpoint = (v1 + v2) * 0.5;

        if (bit == 0u) {
            // Left child: new triangle is (midpoint, v0, v1)
            v2 = v0;
            v0 = midpoint;
        } else {
            // Right child: new triangle is (midpoint, v2, v0)
            v1 = v0;
            v0 = midpoint;
        }
    }

    return LEBTriangle(v0, v1, v2);
}

// Find the edge neighbor across the longest edge (v1-v2)
// For LEB, neighbors share the edge that gets bisected during subdivision
uint leb_edgeNeighbor(uint heapIndex) {
    uint depth = cbt_depth(heapIndex);

    // Base triangles (heap indices 2 and 3) are neighbors across the diagonal
    if (depth == 1u) {
        return cbt_sibling(heapIndex);  // 2 <-> 3
    }

    // For subdivided triangles, the neighbor algorithm is more complex
    // We need to find the triangle that shares our longest edge
    // This is the "opposite" child of our parent's sibling
    uint parent = cbt_parent(heapIndex);
    uint parentSibling = cbt_sibling(parent);

    // Check if parent's sibling exists in the tree
    if (!cbt_getBit(parentSibling)) {
        return 0u;  // No neighbor at this level
    }

    // The neighbor is the opposite child of parent's sibling
    uint childBit = heapIndex & 1u;
    return cbt_leftChild(parentSibling) + (1u - childBit);
}

// ============== LOD Functions ==============

float computeLongestEdgeScreenLength(vec3 p0, vec3 p1, vec3 p2) {
    mat4 viewProj = pc.viewProj;
    vec2 screenSize = pc.screenParams.xy;

    vec4 c0 = viewProj * vec4(p0, 1.0);
    vec4 c1 = viewProj * vec4(p1, 1.0);
    vec4 c2 = viewProj * vec4(p2, 1.0);

    // Handle behind-camera cases
    if (c0.w <= 0.0 || c1.w <= 0.0 || c2.w <= 0.0) {
        return 10000.0;  // Large value to trigger split
    }

    vec2 ndc0 = c0.xy / c0.w;
    vec2 ndc1 = c1.xy / c1.w;
    vec2 ndc2 = c2.xy / c2.w;

    vec2 s0 = (ndc0 * 0.5 + 0.5) * screenSize;
    vec2 s1 = (ndc1 * 0.5 + 0.5) * screenSize;
    vec2 s2 = (ndc2 * 0.5 + 0.5) * screenSize;

    float e01 = length(s1 - s0);
    float e12 = length(s2 - s1);
    float e20 = length(s0 - s2);

    return max(max(e01, e12), e20);
}

float sampleHeight(vec2 uv) {
    return texture(heightMap, uv).r * pc.terrainParams.y;
}

vec3 uvToWorldPos(vec2 uv) {
    float terrainSize = pc.terrainParams.x;
    float height = sampleHeight(uv);
    // Center terrain on origin
    return vec3((uv.x - 0.5) * terrainSize, height, (uv.y - 0.5) * terrainSize);
}

// ============== Main ==============

void main() {
    uint leafIndex = gl_GlobalInvocationID.x;
    uint totalLeaves = cbt_leafCount();

    if (leafIndex >= totalLeaves) return;

    // Map leaf index to heap index
    uint heapIndex = cbt_leafIndexToHeapIndex(leafIndex);

    // Decode triangle
    LEBTriangle tri = leb_decodeTriangle(heapIndex);

    // Get world positions
    vec3 p0 = uvToWorldPos(tri.v0);
    vec3 p1 = uvToWorldPos(tri.v1);
    vec3 p2 = uvToWorldPos(tri.v2);

    // Compute screen-space edge length
    float edgeLength = computeLongestEdgeScreenLength(p0, p1, p2);

    // LOD thresholds
    float splitThreshold = pc.terrainParams.z;
    float mergeThreshold = pc.terrainParams.w;
    uint maxDepth = uint(pc.screenParams.z);
    uint depth = cbt_depth(heapIndex);

    // LOD decision
    if (edgeLength > splitThreshold && depth < maxDepth) {
        // Split: create children
        uint leftChild = cbt_leftChild(heapIndex);
        uint rightChild = cbt_rightChild(heapIndex);
        cbt_setBit(leftChild, true);
        cbt_setBit(rightChild, true);

        // Also split edge neighbor to maintain conforming mesh
        uint neighbor = leb_edgeNeighbor(heapIndex);
        if (neighbor != 0u && cbt_getBit(neighbor)) {
            uint nLeft = cbt_leftChild(neighbor);
            uint nRight = cbt_rightChild(neighbor);
            cbt_setBit(nLeft, true);
            cbt_setBit(nRight, true);
        }
    } else if (edgeLength < mergeThreshold && depth > 1u) {
        // Merge: check if we can merge (both siblings must be leaves)
        uint sibling = cbt_sibling(heapIndex);
        if (cbt_getBit(sibling) && cbt_isLeaf(sibling)) {
            // Remove both children bits (current node and sibling)
            cbt_setBit(heapIndex, false);
            cbt_setBit(sibling, false);
        }
    }
}

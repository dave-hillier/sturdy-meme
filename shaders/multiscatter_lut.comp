#version 450

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"
#include "atmosphere_common.glsl"
#include "lut_compute_common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = BINDING_ATMO_OUTPUT_LUT, rg16f) writeonly uniform image2D multiScatterLUT;
layout(binding = BINDING_ATMO_TRANSMITTANCE) uniform sampler2D transmittanceLUT;

layout(binding = BINDING_ATMO_MULTISCATTER) uniform AtmosphereUniforms {
    AtmosphereParams params;
    vec4 toSunDirection;
    vec4 cameraPosition;
    float padding[2];
} uAtmosphere;

const int SAMPLE_COUNT = 64;
const int MARCH_STEPS = 20;

// Compute single scattering contribution
vec3 ComputeSingleScattering(float altitude, vec3 viewDir, float cosSunZenith) {
    float r = uAtmosphere.params.planetRadius + altitude;
    vec3 pos = vec3(0.0, r, 0.0);
    vec3 sunDir = sunDirFromZenithCos(cosSunZenith);

    // Ray march to accumulate single scattering
    float rayLength = DistanceToAtmosphereBoundary(r, dot(viewDir, normalize(pos)), uAtmosphere.params.atmosphereRadius);
    float stepSize = rayLength / float(MARCH_STEPS);

    vec3 scattering = vec3(0.0);

    // Phase functions (constant for the ray)
    float cosTheta = dot(viewDir, sunDir);
    float rayleighPhase = RayleighPhase(cosTheta);
    float miePhase = HenyeyGreensteinPhase(cosTheta, uAtmosphere.params.mieAnisotropy);

    for (int i = 0; i < MARCH_STEPS; i++) {
        float t = rayMarchStepT(i, stepSize);
        vec3 samplePos = pos + viewDir * t;
        float sampleR = length(samplePos);
        float sampleAlt = radiusToAltitude(sampleR, uAtmosphere.params.planetRadius);

        // Get density and scattering coefficients
        vec3 density = GetAtmosphereDensity(sampleAlt, uAtmosphere.params);
        vec3 rayleighScatter, mieScatter;
        computeScattering(density, uAtmosphere.params, rayleighScatter, mieScatter);

        // Get transmittance to sun
        float muS = dot(normalize(samplePos), sunDir);
        vec3 transmittanceToSun = sampleTransmittanceLUT(transmittanceLUT, sampleR, muS, uAtmosphere.params);

        // Accumulate with phase functions
        vec3 localScatter = transmittanceToSun * (rayleighScatter * rayleighPhase + mieScatter * miePhase);

        // Get transmittance from camera to sample
        float muView = dot(normalize(pos), viewDir);
        vec3 transmittanceToView = sampleTransmittanceLUT(transmittanceLUT, r, muView, uAtmosphere.params);

        scattering += localScatter * transmittanceToView * stepSize;
    }

    return scattering;
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lutSize = imageSize(multiScatterLUT);

    if (isOutOfBounds(texel, lutSize)) {
        return;
    }

    vec2 uv = texelToUV(texel, lutSize);

    // Decode altitude and sun angle from UV
    float altitude, cosSunZenith;
    decodeAltitudeSunAngleLUT(uv, uAtmosphere.params, altitude, cosSunZenith);

    // Integrate over hemisphere to get average multi-scatter contribution
    vec3 totalLuminance = vec3(0.0);

    for (int i = 0; i < SAMPLE_COUNT; i++) {
        vec2 xi = Hammersley(uint(i), uint(SAMPLE_COUNT));
        vec3 dir = UniformHemisphere(xi);

        // Compute single scattering in this direction
        vec3 singleScatter = ComputeSingleScattering(altitude, dir, cosSunZenith);

        // Weight by solid angle (uniform hemisphere)
        float weight = 2.0 * PI / float(SAMPLE_COUNT);
        totalLuminance += singleScatter * weight;
    }

    // Average over hemisphere
    totalLuminance /= PI; // Normalize by hemisphere solid angle

    // Store Rayleigh and Mie separately in RG channels
    // For simplicity, store average of RGB in R, and a separate Mie estimate in G
    float rayleighAvg = (totalLuminance.r + totalLuminance.g + totalLuminance.b) / 3.0;
    float mieEstimate = rayleighAvg * 0.8; // Approximate Mie contribution

    imageStore(multiScatterLUT, texel, vec4(rayleighAvg, mieEstimate, 0.0, 1.0));
}

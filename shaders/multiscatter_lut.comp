#version 450

#extension GL_GOOGLE_include_directive : require

#include "atmosphere_common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, rg16f) writeonly uniform image2D multiScatterLUT;
layout(binding = 1) uniform sampler2D transmittanceLUT;

layout(binding = 2) uniform AtmosphereUniforms {
    AtmosphereParams params;
    vec4 sunDirection;
    vec4 cameraPosition;
    float padding[2];
} uAtmosphere;

const int SAMPLE_COUNT = 64;
const int MARCH_STEPS = 20;

// Sample transmittance LUT
vec3 SampleTransmittance(float r, float mu) {
    vec2 uv = TransmittanceLUTParamsToUV(r, mu, uAtmosphere.params);
    return texture(transmittanceLUT, uv).rgb;
}

// Compute single scattering contribution
vec3 ComputeSingleScattering(float altitude, vec3 viewDir, float cosSunZenith) {
    float r = uAtmosphere.params.planetRadius + altitude;
    vec3 pos = vec3(0.0, r, 0.0);
    vec3 sunDir = vec3(sqrt(1.0 - cosSunZenith * cosSunZenith), cosSunZenith, 0.0);

    // Ray march to accumulate single scattering
    float rayLength = DistanceToAtmosphereBoundary(r, dot(viewDir, normalize(pos)), uAtmosphere.params.atmosphereRadius);
    float stepSize = rayLength / float(MARCH_STEPS);

    vec3 scattering = vec3(0.0);

    for (int i = 0; i < MARCH_STEPS; i++) {
        float t = (float(i) + 0.5) * stepSize;
        vec3 samplePos = pos + viewDir * t;
        float sampleR = length(samplePos);
        float sampleAlt = sampleR - uAtmosphere.params.planetRadius;

        // Get density
        vec3 density = GetAtmosphereDensity(sampleAlt, uAtmosphere.params);

        // Get transmittance to sun
        vec3 toSun = sunDir;
        float muS = dot(normalize(samplePos), toSun);
        vec3 transmittanceToSun = SampleTransmittance(sampleR, muS);

        // Rayleigh and Mie scattering
        vec3 rayleighScatter = density.x * uAtmosphere.params.rayleighScatteringBase;
        float mieScatter = density.y * uAtmosphere.params.mieScatteringBase;

        // Phase functions
        float cosTheta = dot(viewDir, sunDir);
        float rayleighPhase = RayleighPhase(cosTheta);
        float miePhase = HenyeyGreensteinPhase(cosTheta, uAtmosphere.params.mieAnisotropy);

        // Accumulate
        vec3 localScatter = transmittanceToSun * (rayleighScatter * rayleighPhase + vec3(mieScatter * miePhase));

        // Get transmittance from camera to sample
        float muView = dot(normalize(pos), viewDir);
        vec3 transmittanceToView = SampleTransmittance(r, muView);

        scattering += localScatter * transmittanceToView * stepSize;
    }

    return scattering;
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lutSize = imageSize(multiScatterLUT);

    if (texel.x >= lutSize.x || texel.y >= lutSize.y) {
        return;
    }

    // UV coordinates [0, 1]
    vec2 uv = (vec2(texel) + 0.5) / vec2(lutSize);

    // X: cosine of sun zenith angle [-1, 1]
    // Y: normalized altitude [0, 1]
    float cosSunZenith = uv.x * 2.0 - 1.0;
    float altitude = uv.y * (uAtmosphere.params.atmosphereRadius - uAtmosphere.params.planetRadius);

    // Integrate over hemisphere to get average multi-scatter contribution
    vec3 totalLuminance = vec3(0.0);

    for (int i = 0; i < SAMPLE_COUNT; i++) {
        vec2 xi = Hammersley(uint(i), uint(SAMPLE_COUNT));
        vec3 dir = UniformHemisphere(xi);

        // Compute single scattering in this direction
        vec3 singleScatter = ComputeSingleScattering(altitude, dir, cosSunZenith);

        // Weight by solid angle (uniform hemisphere)
        float weight = 2.0 * PI / float(SAMPLE_COUNT);
        totalLuminance += singleScatter * weight;
    }

    // Average over hemisphere
    totalLuminance /= PI; // Normalize by hemisphere solid angle

    // Store Rayleigh and Mie separately in RG channels
    // For simplicity, store average of RGB in R, and a separate Mie estimate in G
    float rayleighAvg = (totalLuminance.r + totalLuminance.g + totalLuminance.b) / 3.0;
    float mieEstimate = rayleighAvg * 0.8; // Approximate Mie contribution

    imageStore(multiScatterLUT, texel, vec4(rayleighAvg, mieEstimate, 0.0, 1.0));
}

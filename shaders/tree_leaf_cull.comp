#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"
#include "tree_leaf_cull_common.glsl"

// Workgroup size: 256 threads per workgroup
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input: all leaf instances from TreeSystem (tree-local space)
layout(std430, binding = BINDING_TREE_LEAF_CULL_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: visible leaf instances after culling (WORLD space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_TREE_LEAF_CULL_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
layout(std430, binding = BINDING_TREE_LEAF_CULL_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
};

layout(std430, binding = BINDING_TREE_LEAF_CULL_TREES) readonly buffer TreeDataBuffer {
    TreeCullData treeData[];
};

// Global culling uniforms
layout(binding = BINDING_TREE_LEAF_CULL_UNIFORMS) uniform TreeLeafCullUniforms {
    vec4 cameraPosition;
    vec4 frustumPlanes[6];
    float maxDrawDistance;
    float lodTransitionStart;
    float lodTransitionEnd;
    float maxLodDropRate;
    uint numTrees;
    uint totalLeafInstances;
    uint maxLeavesPerType;
    uint _pad1;
};

void main() {
    uint globalIdx = gl_GlobalInvocationID.x;

    // First thread initializes all indirect commands
    if (globalIdx == 0) {
        for (uint i = 0; i < NUM_LEAF_TYPES; i++) {
            drawCmds[i].indexCount = 6;
            drawCmds[i].instanceCount = 0;
            drawCmds[i].firstIndex = 0;
            drawCmds[i].vertexOffset = 0;
            drawCmds[i].firstInstance = i * maxLeavesPerType;
        }
    }

    // Ensure initialization is complete before any thread proceeds
    barrier();
    memoryBarrierBuffer();

    // Early exit if beyond total leaf count
    if (globalIdx >= totalLeafInstances) {
        return;
    }

    // Find which tree this leaf belongs to using binary search
    uint treeIdx = 0;
    uint low = 0;
    uint high = numTrees;

    while (low < high) {
        uint mid = (low + high) / 2;
        uint treeStart = treeData[mid].inputFirstInstance;
        uint treeEnd = treeStart + treeData[mid].inputInstanceCount;

        if (globalIdx < treeStart) {
            high = mid;
        } else if (globalIdx >= treeEnd) {
            low = mid + 1;
        } else {
            treeIdx = mid;
            break;
        }
    }

    // Get tree data
    TreeCullData tree = treeData[treeIdx];

    // Skip trees fully in impostor mode
    if (tree.lodBlendFactor >= 1.0) {
        return;
    }

    // Sanity check local index
    uint localIdx = globalIdx - tree.inputFirstInstance;
    if (localIdx >= tree.inputInstanceCount) {
        return;
    }

    // Get input instance and cull
    LeafInstance leaf = inputInstances[globalIdx];
    vec4 worldPos;
    float leafSize;
    float distToCamera;

    if (cullLeaf(
        leaf.positionAndSize.xyz,
        leaf.positionAndSize.w,
        tree.treeModel,
        tree.lodBlendFactor,
        cameraPosition.xyz,
        frustumPlanes,
        maxDrawDistance,
        lodTransitionStart,
        lodTransitionEnd,
        maxLodDropRate,
        worldPos,
        leafSize,
        distToCamera
    )) {
        return;
    }

    // Get leaf type for this tree (0=oak, 1=ash, 2=aspen, 3=pine)
    uint leafType = min(tree.leafTypeIndex, NUM_LEAF_TYPES - 1);

    // Use subgroup operations to batch atomic updates per leaf type
    // This reduces contention by ~32x compared to per-thread atomics
    uint typeLocalSlot = ~0u;

    for (uint type = 0; type < NUM_LEAF_TYPES; type++) {
        // Find all threads in this subgroup that want this leaf type
        uvec4 typeMask = subgroupBallot(leafType == type);
        uint typeCount = subgroupBallotBitCount(typeMask);

        if (typeCount > 0) {
            // Elect first matching thread to do the atomic for the whole subgroup
            uint electedLane = subgroupBallotFindLSB(typeMask);
            uint baseSlot = 0;

            if (gl_SubgroupInvocationID == electedLane) {
                baseSlot = atomicAdd(drawCmds[type].instanceCount, typeCount);
            }

            // Broadcast base slot to all threads
            baseSlot = subgroupBroadcast(baseSlot, electedLane);

            // Each thread computes its offset within the batch
            if (leafType == type) {
                uint laneOffset = subgroupBallotExclusiveBitCount(typeMask);
                typeLocalSlot = baseSlot + laneOffset;
            }
        }
    }

    // Check if our slot is within budget
    if (typeLocalSlot >= maxLeavesPerType) {
        return;
    }

    // Calculate global output slot: type's base offset + local slot
    uint outputSlot = leafType * maxLeavesPerType + typeLocalSlot;

    // Write world-space leaf with tree index
    outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
    outputInstances[outputSlot].worldOrientation = transformLeafOrientation(leaf.orientation, tree.treeModel);
    outputInstances[outputSlot].treeIndex = tree.treeIndex;
    outputInstances[outputSlot]._pad0 = 0;
    outputInstances[outputSlot]._pad1 = 0;
    outputInstances[outputSlot]._pad2 = 0;
}

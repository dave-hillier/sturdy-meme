#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "tree_leaf_instance.glsl"
#include "tree_leaf_world.glsl"
#include "tree_leaf_cull_common.glsl"

// Include shared culling uniforms
#define CULLING_UBO_BINDING BINDING_TREE_LEAF_CULL_CULLING
#include "ubo_culling.glsl"

// Workgroup size: 256 threads per workgroup
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Input: all leaf instances from TreeSystem (tree-local space)
layout(std430, binding = BINDING_TREE_LEAF_CULL_INPUT) readonly buffer InputBuffer {
    LeafInstance inputInstances[];
};

// Output: visible leaf instances after culling (WORLD space with tree index)
// Buffer is partitioned: [type0 leaves][type1 leaves][type2 leaves][type3 leaves]
layout(std430, binding = BINDING_TREE_LEAF_CULL_OUTPUT) writeonly buffer OutputBuffer {
    WorldLeafInstance outputInstances[];
};

// One indirect draw command per leaf type
layout(std430, binding = BINDING_TREE_LEAF_CULL_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[NUM_LEAF_TYPES];
};

layout(std430, binding = BINDING_TREE_LEAF_CULL_TREES) readonly buffer TreeDataBuffer {
    TreeCullData treeData[];
};

// Leaf cull specific parameters
layout(std140, binding = BINDING_TREE_LEAF_CULL_PARAMS) uniform LeafCullParams {
    uint numTrees;
    uint totalLeafInstances;
    uint maxLeavesPerType;
    uint _pad1;
} leafCullParams;

void main() {
    uint globalIdx = gl_GlobalInvocationID.x;

    // NOTE: Indirect command initialization is done on CPU side via vkCmdUpdateBuffer
    // BEFORE dispatch. Shader-side init with barrier() only syncs within a workgroup,
    // causing race conditions when multiple workgroups run in parallel.

    // Early exit if beyond total leaf count
    if (globalIdx >= leafCullParams.totalLeafInstances) {
        return;
    }

    // Find which tree this leaf belongs to using binary search
    uint treeIdx = 0;
    uint low = 0;
    uint high = leafCullParams.numTrees;

    while (low < high) {
        uint mid = (low + high) / 2;
        uint treeStart = treeData[mid].inputFirstInstance;
        uint treeEnd = treeStart + treeData[mid].inputInstanceCount;

        if (globalIdx < treeStart) {
            high = mid;
        } else if (globalIdx >= treeEnd) {
            low = mid + 1;
        } else {
            treeIdx = mid;
            break;
        }
    }

    // Get tree data
    TreeCullData tree = treeData[treeIdx];

    // Skip trees fully in impostor mode
    if (tree.lodBlendFactor >= 1.0) {
        return;
    }

    // Sanity check local index
    uint localIdx = globalIdx - tree.inputFirstInstance;
    if (localIdx >= tree.inputInstanceCount) {
        return;
    }

    // Get input instance and cull
    LeafInstance leaf = inputInstances[globalIdx];
    vec4 worldPos;
    float leafSize;
    float distToCamera;

    if (cullLeaf(
        leaf.positionAndSize.xyz,
        leaf.positionAndSize.w,
        tree.treeModel,
        tree.lodBlendFactor,
        culling.cameraPosition.xyz,
        culling.frustumPlanes,
        culling.maxDrawDistance,
        localIdx,       // leafIndexInTree - stable integer index
        treeIdx,        // treeIndex - for unique hash per tree
        worldPos,
        leafSize,
        distToCamera
    )) {
        return;
    }

    // Get leaf type for this tree (0=oak, 1=ash, 2=aspen, 3=pine)
    uint leafType = min(tree.leafTypeIndex, NUM_LEAF_TYPES - 1);

    // Use subgroup operations to batch atomic updates per leaf type
    // This reduces contention by ~32x compared to per-thread atomics
    uint typeLocalSlot = ~0u;

    for (uint type = 0; type < NUM_LEAF_TYPES; type++) {
        // Find all threads in this subgroup that want this leaf type
        uvec4 typeMask = subgroupBallot(leafType == type);
        uint typeCount = subgroupBallotBitCount(typeMask);

        if (typeCount > 0) {
            // Elect first matching thread to do the atomic for the whole subgroup
            uint electedLane = subgroupBallotFindLSB(typeMask);
            uint baseSlot = 0;
            uint slotsAllocated = 0;

            if (gl_SubgroupInvocationID == electedLane) {
                // Use compare-and-swap to only allocate slots that will fit
                // This prevents instanceCount from exceeding maxLeavesPerType
                uint expected = drawCmds[type].instanceCount;
                while (true) {
                    uint available = (expected >= leafCullParams.maxLeavesPerType)
                        ? 0
                        : leafCullParams.maxLeavesPerType - expected;
                    slotsAllocated = min(typeCount, available);
                    if (slotsAllocated == 0) {
                        baseSlot = expected; // Will exceed limit, no slots allocated
                        break;
                    }
                    uint desired = expected + slotsAllocated;
                    uint actual = atomicCompSwap(drawCmds[type].instanceCount, expected, desired);
                    if (actual == expected) {
                        baseSlot = expected; // Successfully allocated slots
                        break;
                    }
                    expected = actual; // Retry with updated value
                }
            }

            // Broadcast base slot and allocated count to all threads
            baseSlot = subgroupBroadcast(baseSlot, electedLane);
            slotsAllocated = subgroupBroadcast(slotsAllocated, electedLane);

            // Each thread computes its offset within the batch
            if (leafType == type) {
                uint laneOffset = subgroupBallotExclusiveBitCount(typeMask);
                // Only threads with laneOffset < slotsAllocated get a valid slot
                if (laneOffset < slotsAllocated) {
                    typeLocalSlot = baseSlot + laneOffset;
                }
                // else typeLocalSlot remains ~0u (will fail the bounds check)
            }
        }
    }

    // Check if our slot is within budget
    if (typeLocalSlot >= leafCullParams.maxLeavesPerType) {
        return;
    }

    // Calculate global output slot: type's base offset + local slot
    uint outputSlot = leafType * leafCullParams.maxLeavesPerType + typeLocalSlot;

    // Write world-space leaf with tree index
    outputInstances[outputSlot].worldPosition = vec4(worldPos.xyz, leafSize);
    outputInstances[outputSlot].worldOrientation = transformLeafOrientation(leaf.orientation, tree.treeModel);
    outputInstances[outputSlot].treeIndex = tree.treeIndex;
    outputInstances[outputSlot]._pad0 = 0;
    outputInstances[outputSlot]._pad1 = 0;
    outputInstances[outputSlot]._pad2 = 0;
}

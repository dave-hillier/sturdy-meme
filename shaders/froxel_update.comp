#version 450

// Froxel Update Compute Shader (Phase 4.3)
// Calculates fog density and in-scattered light for each froxel
// Now with proper cascade shadow map sampling

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(binding = 0, rgba16f) writeonly uniform image3D scatteringVolume;
layout(binding = 1, rgba16f) uniform image3D integratedVolume;  // Previous frame for temporal

const int NUM_CASCADES = 4;

layout(binding = 2) uniform FroxelUniforms {
    mat4 invViewProj;
    mat4 prevViewProj;
    mat4 cascadeViewProj[NUM_CASCADES];  // Light-space matrices for shadow cascades
    vec4 cascadeSplits;                   // View-space split depths
    vec4 cameraPosition;
    vec4 sunDirection;      // xyz = direction, w = intensity
    vec4 sunColor;
    vec4 fogParams;         // x = base height, y = scale height, z = density, w = absorption
    vec4 layerParams;       // x = layer height, y = layer thickness, z = layer density
    vec4 gridParams;        // x = volumetric far, y = depth distribution, z = frame index
    vec4 shadowParams;      // x = shadow map size, y = shadow bias, z = pcf radius
} ubo;

layout(binding = 3) uniform sampler2DArrayShadow shadowMap;

// Froxel grid constants
const uint FROXEL_WIDTH = 128;
const uint FROXEL_HEIGHT = 64;
const uint FROXEL_DEPTH = 64;

const float PI = 3.14159265359;

// Convert slice index to linear depth using exponential distribution
float sliceToDepth(float slice) {
    float depthDist = ubo.gridParams.y;  // Depth distribution factor
    float volumetricFar = ubo.gridParams.x;
    return volumetricFar * (pow(depthDist, slice) - 1.0) / (pow(depthDist, float(FROXEL_DEPTH)) - 1.0);
}

// Exponential height density (general atmospheric haze)
float exponentialHeightDensity(float height) {
    float baseHeight = ubo.fogParams.x;
    float scaleHeight = ubo.fogParams.y;
    float density = ubo.fogParams.z;
    float relHeight = height - baseHeight;
    return density * exp(-max(relHeight, 0.0) / scaleHeight);
}

// Sigmoidal layer density (ground fog layer)
float sigmoidalLayerDensity(float height) {
    float layerHeight = ubo.layerParams.x;
    float layerThickness = ubo.layerParams.y;
    float layerDensity = ubo.layerParams.z;
    float t = (height - layerHeight) / max(layerThickness, 0.001);
    return layerDensity / (1.0 + exp(t * 2.0));
}

// Combined fog density at height
float getHazeDensity(vec3 worldPos) {
    float height = worldPos.y;
    return exponentialHeightDensity(height) + sigmoidalLayerDensity(height);
}

// Henyey-Greenstein phase function
float henyeyGreenstein(float cosTheta, float g) {
    float g2 = g * g;
    float denom = 1.0 + g2 - 2.0 * g * cosTheta;
    return (1.0 - g2) / (4.0 * PI * pow(denom, 1.5));
}

// Simple hash for temporal jittering
float hash(vec3 p) {
    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
}

// Blue noise approximation for jittering
vec2 blueNoise2D(ivec2 texel, float frame) {
    vec2 r = vec2(hash(vec3(texel, frame)),
                  hash(vec3(texel + ivec2(100, 200), frame + 0.5)));
    return r;
}

// ============================================================================
// Cascade Shadow Map Sampling
// ============================================================================

// Select which cascade to use based on view-space depth
int selectCascade(float viewSpaceDepth) {
    for (int i = 0; i < NUM_CASCADES; i++) {
        if (viewSpaceDepth < ubo.cascadeSplits[i]) {
            return i;
        }
    }
    return NUM_CASCADES - 1;
}

// Sample shadow map with PCF (Percentage Closer Filtering)
float sampleShadowPCF(vec3 worldPos, int cascade) {
    // Transform world position to light space
    vec4 lightSpacePos = ubo.cascadeViewProj[cascade] * vec4(worldPos, 1.0);
    vec3 projCoords = lightSpacePos.xyz / lightSpacePos.w;

    // Convert from [-1,1] to [0,1] for UV coordinates (Vulkan NDC)
    vec2 shadowUV = projCoords.xy * 0.5 + 0.5;

    // Check if position is outside shadow map bounds
    if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {
        return 1.0;  // Outside shadow map = lit
    }

    // Shadow bias to prevent acne (smaller for volumetrics)
    float bias = ubo.shadowParams.y;
    float compareDepth = projCoords.z - bias;

    // Simple PCF with 4 samples for volumetrics (lighter weight than scene shadows)
    float shadow = 0.0;
    float texelSize = 1.0 / ubo.shadowParams.x;
    float pcfRadius = ubo.shadowParams.z;

    // 2x2 PCF kernel
    for (int x = -1; x <= 0; x++) {
        for (int y = -1; y <= 0; y++) {
            vec2 offset = vec2(float(x) + 0.5, float(y) + 0.5) * texelSize * pcfRadius;
            // texture() with sampler2DArrayShadow returns comparison result
            shadow += texture(shadowMap, vec4(shadowUV + offset, float(cascade), compareDepth));
        }
    }

    return shadow / 4.0;
}

// Sample shadow for a world position (full cascade selection + PCF)
float sampleCascadeShadow(vec3 worldPos, float viewSpaceDepth) {
    // Select appropriate cascade
    int cascade = selectCascade(viewSpaceDepth);

    // Sample shadow with PCF
    return sampleShadowPCF(worldPos, cascade);
}

void main() {
    ivec3 texel = ivec3(gl_GlobalInvocationID);

    // Bounds check
    if (texel.x >= FROXEL_WIDTH || texel.y >= FROXEL_HEIGHT || texel.z >= FROXEL_DEPTH) {
        return;
    }

    // Convert froxel coordinates to UVW
    vec3 uvw = (vec3(texel) + 0.5) / vec3(FROXEL_WIDTH, FROXEL_HEIGHT, FROXEL_DEPTH);

    // Get linear depth for this slice
    float linearDepth = sliceToDepth(uvw.z * float(FROXEL_DEPTH));

    // Convert to NDC (note: Vulkan NDC has Y down, Z 0-1)
    vec2 ndc = uvw.xy * 2.0 - 1.0;

    // Reconstruct world position using inverse view-proj
    // First convert linear depth to NDC depth
    // Approximate: assume near=0.1, far=volumetricFar
    float ndcDepth = linearDepth / ubo.gridParams.x;  // Simplified

    vec4 clipPos = vec4(ndc.x, ndc.y, ndcDepth, 1.0);
    vec4 worldPos4 = ubo.invViewProj * clipPos;
    vec3 worldPos = worldPos4.xyz / worldPos4.w;

    // Sample fog density
    float density = getHazeDensity(worldPos);

    // Early out if no density
    if (density < 0.0001) {
        imageStore(scatteringVolume, texel, vec4(0.0));
        return;
    }

    // Jitter for temporal stability
    vec2 jitter = blueNoise2D(texel.xy, ubo.gridParams.z) * 0.5 - 0.25;

    // Sun direction and lighting
    vec3 sunDir = normalize(ubo.sunDirection.xyz);
    float sunIntensity = ubo.sunDirection.w;
    vec3 sunLight = ubo.sunColor.rgb * sunIntensity;

    // View direction (from camera to froxel)
    vec3 viewDir = normalize(worldPos - ubo.cameraPosition.xyz);

    // Phase function for forward/back scattering
    float cosTheta = dot(viewDir, sunDir);
    float phase = henyeyGreenstein(cosTheta, 0.7);  // Slightly forward scattering for haze

    // Sun visibility based on sun angle (day/night)
    float sunVisibility = smoothstep(-0.1, 0.2, sunDir.y);

    // Sample cascade shadow map for this froxel position
    // Use linear depth as view-space depth approximation for cascade selection
    float shadow = 1.0;
    if (sunVisibility > 0.01) {
        shadow = sampleCascadeShadow(worldPos, linearDepth);
    }

    // Combine sun visibility with shadow
    float totalShadow = sunVisibility * shadow;

    // In-scattering from sun (attenuated by shadow)
    vec3 sunInScatter = sunLight * phase * totalShadow * density;

    // Ambient sky contribution (isotropic)
    float night = 1.0 - smoothstep(-0.05, 0.08, sunDir.y);
    vec3 skyColor = mix(vec3(0.4, 0.5, 0.7), vec3(0.02, 0.03, 0.05), night);
    vec3 skyInScatter = skyColor * density * 0.15;  // Ambient scatter

    // Total in-scattering
    vec3 totalInScatter = sunInScatter + skyInScatter;

    // Store L / alpha for anti-aliased compositing (Ghost of Tsushima technique)
    // Alpha will be computed during integration
    imageStore(scatteringVolume, texel, vec4(totalInScatter, density));
}

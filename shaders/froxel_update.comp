#version 450

// Froxel Update Compute Shader (Phase 4.3)
// Calculates fog density and in-scattered light for each froxel
// Features: cascade shadow map sampling, temporal reprojection

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(binding = BINDING_FROXEL_SCATTERING, rgba16f) uniform image3D scatteringVolume;  // Current frame output (write only)
layout(binding = BINDING_FROXEL_INTEGRATED, rgba16f) uniform image3D integratedVolume;  // Integrated volume (used by integration pass)
layout(binding = BINDING_FROXEL_HISTORY, rgba16f) uniform readonly image3D historyVolume;  // Previous frame for temporal reprojection

const int NUM_CASCADES = 4;

layout(binding = BINDING_FROXEL_UNIFORMS) uniform FroxelUniforms {
    mat4 invViewProj;
    mat4 prevViewProj;
    mat4 cascadeViewProj[NUM_CASCADES];  // Light-space matrices for shadow cascades
    vec4 cascadeSplits;                   // View-space split depths
    vec4 cameraPosition;
    vec4 sunDirection;      // xyz = direction, w = intensity
    vec4 sunColor;
    vec4 fogParams;         // x = base height, y = scale height, z = density, w = absorption
    vec4 layerParams;       // x = layer height, y = layer thickness, z = layer density
    vec4 gridParams;        // x = volumetric far, y = depth distribution, z = frame index, w = temporal blend
    vec4 shadowParams;      // x = shadow map size, y = shadow bias, z = pcf radius
} ubo;

// Temporal reprojection blend factor
const float TEMPORAL_BLEND_MIN = 0.85;  // Minimum history weight (fast adaptation)
const float TEMPORAL_BLEND_MAX = 0.97;  // Maximum history weight (high stability)

layout(binding = BINDING_FROXEL_SHADOW) uniform sampler2DArrayShadow shadowMap;

// Light types (must match Light.h)
const uint LIGHT_TYPE_POINT = 0;
const uint LIGHT_TYPE_SPOT = 1;
const uint MAX_LIGHTS = 16;

// GPU light structure (must match Light.h)
struct GPULight {
    vec4 positionAndType;    // xyz = position, w = type (0=point, 1=spot)
    vec4 directionAndCone;   // xyz = direction (for spot), w = outer cone angle (cos)
    vec4 colorAndIntensity;  // rgb = color, a = intensity
    vec4 radiusAndInnerCone; // x = radius, y = inner cone angle (cos), z = shadow map index, w = padding
};

// Light buffer SSBO
layout(std430, binding = BINDING_FROXEL_LIGHTS) readonly buffer LightBuffer {
    uvec4 lightCount;        // x = active light count
    GPULight lights[MAX_LIGHTS];
} lightBuffer;

// Froxel grid constants
const uint FROXEL_WIDTH = 128;
const uint FROXEL_HEIGHT = 64;
const uint FROXEL_DEPTH = 64;

const float PI = 3.14159265359;

// Convert slice index to linear depth using exponential distribution
float sliceToDepth(float slice) {
    float depthDist = ubo.gridParams.y;  // Depth distribution factor
    float volumetricFar = ubo.gridParams.x;
    return volumetricFar * (pow(depthDist, slice) - 1.0) / (pow(depthDist, float(FROXEL_DEPTH)) - 1.0);
}

// Exponential height density (general atmospheric haze)
float exponentialHeightDensity(float height) {
    float baseHeight = ubo.fogParams.x;
    float scaleHeight = ubo.fogParams.y;
    float density = ubo.fogParams.z * 5.0;  // Moderate amplification
    float relHeight = height - baseHeight;
    return density * exp(-max(relHeight, 0.0) / scaleHeight);
}

// 3D value noise for fog volume variation
float noise3D(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);  // Smoothstep

    // Hash corners of the cell
    float n000 = fract(sin(dot(i + vec3(0,0,0), vec3(127.1, 311.7, 74.7))) * 43758.5453);
    float n001 = fract(sin(dot(i + vec3(0,0,1), vec3(127.1, 311.7, 74.7))) * 43758.5453);
    float n010 = fract(sin(dot(i + vec3(0,1,0), vec3(127.1, 311.7, 74.7))) * 43758.5453);
    float n011 = fract(sin(dot(i + vec3(0,1,1), vec3(127.1, 311.7, 74.7))) * 43758.5453);
    float n100 = fract(sin(dot(i + vec3(1,0,0), vec3(127.1, 311.7, 74.7))) * 43758.5453);
    float n101 = fract(sin(dot(i + vec3(1,0,1), vec3(127.1, 311.7, 74.7))) * 43758.5453);
    float n110 = fract(sin(dot(i + vec3(1,1,0), vec3(127.1, 311.7, 74.7))) * 43758.5453);
    float n111 = fract(sin(dot(i + vec3(1,1,1), vec3(127.1, 311.7, 74.7))) * 43758.5453);

    // Trilinear interpolation
    float n00 = mix(n000, n100, f.x);
    float n01 = mix(n001, n101, f.x);
    float n10 = mix(n010, n110, f.x);
    float n11 = mix(n011, n111, f.x);
    float n0 = mix(n00, n10, f.y);
    float n1 = mix(n01, n11, f.y);
    return mix(n0, n1, f.z);
}

// Fractal Brownian Motion for more natural fog shapes
float fbm(vec3 p, int octaves) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    for (int i = 0; i < octaves; i++) {
        value += amplitude * noise3D(p * frequency);
        amplitude *= 0.5;
        frequency *= 2.0;
    }
    return value;
}

// Volumetric ground fog layer with 3D noise for fog patches/wisps
float volumetricGroundFog(vec3 worldPos) {
    float layerHeight = ubo.layerParams.x;
    float layerThickness = ubo.layerParams.y;
    float layerDensity = ubo.layerParams.z * 5.0;  // Moderate amplification

    // Height-based falloff - fog exists at and BELOW layerHeight
    // layerHeight is the TOP of the fog layer
    float heightAboveLayer = worldPos.y - layerHeight;

    // Hard cutoff above the layer
    if (heightAboveLayer > layerThickness) {
        return 0.0;
    }

    // Fog is full density below layerHeight, fades out above
    float heightFalloff;
    if (heightAboveLayer <= 0.0) {
        heightFalloff = 1.0;
    } else {
        heightFalloff = 1.0 - (heightAboveLayer / layerThickness);
    }

    // DEBUG: Use simple grid pattern to verify patches work
    // Creates 25m x 25m fog cells with gaps between
    float cellSize = 25.0;
    vec2 cell = floor(worldPos.xz / cellSize);
    float checker = mod(cell.x + cell.y, 2.0);  // Alternating cells

    // Only fog in "on" cells
    float fogShape = checker;

    // Combine: only fog in checker cells AND below layer height
    return layerDensity * heightFalloff * fogShape;
}

// Combined fog density at world position
float getHazeDensity(vec3 worldPos) {
    float height = worldPos.y;
    float generalHaze = exponentialHeightDensity(height);
    float groundFog = volumetricGroundFog(worldPos);
    return generalHaze + groundFog;
}

// Henyey-Greenstein phase function
float henyeyGreenstein(float cosTheta, float g) {
    float g2 = g * g;
    float denom = 1.0 + g2 - 2.0 * g * cosTheta;
    return (1.0 - g2) / (4.0 * PI * pow(denom, 1.5));
}

// Simple hash for temporal jittering
float hash(vec3 p) {
    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
}

// Blue noise approximation for jittering
vec2 blueNoise2D(ivec2 texel, float frame) {
    vec2 r = vec2(hash(vec3(texel, frame)),
                  hash(vec3(texel + ivec2(100, 200), frame + 0.5)));
    return r;
}

// ============================================================================
// Temporal Reprojection
// ============================================================================

// Convert depth slice to linear depth
float sliceToLinearDepth(float slice) {
    float depthDist = ubo.gridParams.y;
    float volumetricFar = ubo.gridParams.x;
    return volumetricFar * (pow(depthDist, slice) - 1.0) / (pow(depthDist, float(FROXEL_DEPTH)) - 1.0);
}

// Convert linear depth to slice index
float linearDepthToSlice(float linearDepth) {
    float volumetricFar = ubo.gridParams.x;
    float depthDist = ubo.gridParams.y;
    float normalized = clamp(linearDepth / volumetricFar, 0.0, 1.0);
    return log(1.0 + normalized * (pow(depthDist, float(FROXEL_DEPTH)) - 1.0)) / log(depthDist);
}

// Reproject current world position to previous frame's froxel UVW
vec3 reprojectToPrevFrame(vec3 worldPos) {
    // Transform to previous frame's clip space
    vec4 prevClip = ubo.prevViewProj * vec4(worldPos, 1.0);
    vec3 prevNDC = prevClip.xyz / prevClip.w;

    // Convert NDC to UV (Vulkan: Y is already correct, Z is 0-1)
    vec2 prevUV = prevNDC.xy * 0.5 + 0.5;

    // Estimate previous depth (approximate - assume static fog)
    // For moving fog particles, this would need velocity vectors
    float prevLinearDepth = abs(prevClip.w);  // View-space depth
    float prevSlice = linearDepthToSlice(prevLinearDepth);
    float prevW = prevSlice / float(FROXEL_DEPTH);

    return vec3(prevUV, prevW);
}

// Check if reprojected coordinates are valid
bool isReprojectionValid(vec3 prevUVW) {
    // Check bounds
    if (prevUVW.x < 0.0 || prevUVW.x > 1.0 ||
        prevUVW.y < 0.0 || prevUVW.y > 1.0 ||
        prevUVW.z < 0.0 || prevUVW.z > 1.0) {
        return false;
    }
    return true;
}

// Sample history with bilinear interpolation from the history volume (previous frame)
vec4 sampleHistory(vec3 uvw) {
    // Convert UVW to texel coordinates
    vec3 texelCoord = uvw * vec3(float(FROXEL_WIDTH), float(FROXEL_HEIGHT), float(FROXEL_DEPTH)) - 0.5;
    ivec3 texel0 = ivec3(floor(texelCoord));
    vec3 frac = fract(texelCoord);

    // Clamp to valid range
    texel0 = clamp(texel0, ivec3(0), ivec3(FROXEL_WIDTH - 1, FROXEL_HEIGHT - 1, FROXEL_DEPTH - 1));
    ivec3 texel1 = min(texel0 + 1, ivec3(FROXEL_WIDTH - 1, FROXEL_HEIGHT - 1, FROXEL_DEPTH - 1));

    // 8-tap trilinear sampling from history volume (double-buffered previous frame)
    vec4 c000 = imageLoad(historyVolume, ivec3(texel0.x, texel0.y, texel0.z));
    vec4 c100 = imageLoad(historyVolume, ivec3(texel1.x, texel0.y, texel0.z));
    vec4 c010 = imageLoad(historyVolume, ivec3(texel0.x, texel1.y, texel0.z));
    vec4 c110 = imageLoad(historyVolume, ivec3(texel1.x, texel1.y, texel0.z));
    vec4 c001 = imageLoad(historyVolume, ivec3(texel0.x, texel0.y, texel1.z));
    vec4 c101 = imageLoad(historyVolume, ivec3(texel1.x, texel0.y, texel1.z));
    vec4 c011 = imageLoad(historyVolume, ivec3(texel0.x, texel1.y, texel1.z));
    vec4 c111 = imageLoad(historyVolume, ivec3(texel1.x, texel1.y, texel1.z));

    // Trilinear interpolation
    vec4 c00 = mix(c000, c100, frac.x);
    vec4 c10 = mix(c010, c110, frac.x);
    vec4 c01 = mix(c001, c101, frac.x);
    vec4 c11 = mix(c011, c111, frac.x);

    vec4 c0 = mix(c00, c10, frac.y);
    vec4 c1 = mix(c01, c11, frac.y);

    return mix(c0, c1, frac.z);
}

// ============================================================================
// Cascade Shadow Map Sampling
// ============================================================================

// Select which cascade to use based on view-space depth
int selectCascade(float viewSpaceDepth) {
    for (int i = 0; i < NUM_CASCADES; i++) {
        if (viewSpaceDepth < ubo.cascadeSplits[i]) {
            return i;
        }
    }
    return NUM_CASCADES - 1;
}

// Sample shadow map with PCF (Percentage Closer Filtering)
float sampleShadowPCF(vec3 worldPos, int cascade) {
    // Transform world position to light space
    vec4 lightSpacePos = ubo.cascadeViewProj[cascade] * vec4(worldPos, 1.0);
    vec3 projCoords = lightSpacePos.xyz / lightSpacePos.w;

    // Convert from [-1,1] to [0,1] for UV coordinates (Vulkan NDC)
    vec2 shadowUV = projCoords.xy * 0.5 + 0.5;

    // Check if position is outside shadow map bounds
    if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {
        return 1.0;  // Outside shadow map = lit
    }

    // Shadow bias to prevent acne (smaller for volumetrics)
    float bias = ubo.shadowParams.y;
    float compareDepth = projCoords.z - bias;

    // Simple PCF with 4 samples for volumetrics (lighter weight than scene shadows)
    float shadow = 0.0;
    float texelSize = 1.0 / ubo.shadowParams.x;
    float pcfRadius = ubo.shadowParams.z;

    // 2x2 PCF kernel
    for (int x = -1; x <= 0; x++) {
        for (int y = -1; y <= 0; y++) {
            vec2 offset = vec2(float(x) + 0.5, float(y) + 0.5) * texelSize * pcfRadius;
            // texture() with sampler2DArrayShadow returns comparison result
            shadow += texture(shadowMap, vec4(shadowUV + offset, float(cascade), compareDepth));
        }
    }

    return shadow / 4.0;
}

// Sample shadow for a world position (full cascade selection + PCF)
float sampleCascadeShadow(vec3 worldPos, float viewSpaceDepth) {
    // Select appropriate cascade
    int cascade = selectCascade(viewSpaceDepth);

    // Sample shadow with PCF
    return sampleShadowPCF(worldPos, cascade);
}

// ============================================================================
// Local Light Contribution (Phase 4.3.8)
// Point and spot lights contribute to volumetric scattering
// ============================================================================

// Calculate point light attenuation (smooth falloff)
float pointLightAttenuation(float distance, float radius) {
    // Smooth attenuation with quadratic falloff
    float att = 1.0 / (1.0 + distance * distance / (radius * radius * 0.25));
    // Smooth fade at edge of radius
    float fadeOut = 1.0 - smoothstep(radius * 0.5, radius, distance);
    return att * fadeOut;
}

// Calculate spot light cone attenuation
float spotLightAttenuation(vec3 lightDir, vec3 spotDir, float innerCos, float outerCos) {
    float theta = dot(-lightDir, spotDir);
    // Smooth falloff between inner and outer cone
    return smoothstep(outerCos, innerCos, theta);
}

// Compute in-scattering from local lights at a world position
vec3 computeLocalLightScatter(vec3 worldPos, vec3 viewDir, float density) {
    vec3 totalScatter = vec3(0.0);

    uint numLights = lightBuffer.lightCount.x;
    numLights = min(numLights, MAX_LIGHTS);

    for (uint i = 0; i < numLights; i++) {
        GPULight light = lightBuffer.lights[i];

        vec3 lightPos = light.positionAndType.xyz;
        uint lightType = uint(light.positionAndType.w);
        vec3 lightColor = light.colorAndIntensity.rgb;
        float intensity = light.colorAndIntensity.a;
        float radius = light.radiusAndInnerCone.x;

        // Vector from froxel to light
        vec3 toLight = lightPos - worldPos;
        float dist = length(toLight);

        // Skip if outside light radius
        if (dist > radius) continue;

        vec3 lightDir = toLight / dist;

        // Calculate attenuation based on light type
        float attenuation = pointLightAttenuation(dist, radius);

        if (lightType == LIGHT_TYPE_SPOT) {
            vec3 spotDir = normalize(light.directionAndCone.xyz);
            float outerCos = light.directionAndCone.w;
            float innerCos = light.radiusAndInnerCone.y;
            attenuation *= spotLightAttenuation(lightDir, spotDir, innerCos, outerCos);
        }

        // Skip if attenuation is negligible
        if (attenuation < 0.001) continue;

        // Phase function (Henyey-Greenstein) for light direction
        float cosTheta = dot(viewDir, lightDir);
        float phase = henyeyGreenstein(cosTheta, 0.6);  // Moderate forward scattering

        // Accumulate in-scattering
        totalScatter += lightColor * intensity * attenuation * phase * density;
    }

    return totalScatter;
}

void main() {
    ivec3 texel = ivec3(gl_GlobalInvocationID);

    // Bounds check
    if (texel.x >= FROXEL_WIDTH || texel.y >= FROXEL_HEIGHT || texel.z >= FROXEL_DEPTH) {
        return;
    }

    // Convert froxel coordinates to UVW
    vec3 uvw = (vec3(texel) + 0.5) / vec3(FROXEL_WIDTH, FROXEL_HEIGHT, FROXEL_DEPTH);

    // Get linear depth for this slice
    float linearDepth = sliceToDepth(uvw.z * float(FROXEL_DEPTH));

    // Convert to NDC (note: Vulkan NDC has Y down, Z 0-1)
    vec2 ndc = uvw.xy * 2.0 - 1.0;

    // Reconstruct world position by shooting a ray from camera through this pixel
    vec3 cameraPos = ubo.cameraPosition.xyz;

    // Get world position at far plane for this pixel's ray direction
    vec4 farWorld4 = ubo.invViewProj * vec4(ndc, 1.0, 1.0);
    vec3 farWorld = farWorld4.xyz / farWorld4.w;
    vec3 rayDir = normalize(farWorld - cameraPos);

    // Get view forward direction (ray through screen center)
    vec4 centerFar4 = ubo.invViewProj * vec4(0.0, 0.0, 1.0, 1.0);
    vec3 centerFar = centerFar4.xyz / centerFar4.w;
    vec3 viewForward = normalize(centerFar - cameraPos);

    // linearDepth is view-space Z (distance along view forward direction)
    // The ray goes at angle θ to view forward, so ray distance = linearDepth / cos(θ)
    float cosAngle = dot(rayDir, viewForward);
    float rayDist = linearDepth / max(cosAngle, 0.0001);

    vec3 worldPos = cameraPos + rayDir * rayDist;

    // Sample fog density
    float density = getHazeDensity(worldPos);

    // Early out if no density
    if (density < 0.0001) {
        imageStore(scatteringVolume, texel, vec4(0.0));
        return;
    }

    // Jitter for temporal stability
    vec2 jitter = blueNoise2D(texel.xy, ubo.gridParams.z) * 0.5 - 0.25;

    // Sun direction and lighting
    vec3 sunDir = normalize(ubo.sunDirection.xyz);
    float sunIntensity = ubo.sunDirection.w;
    vec3 sunLight = ubo.sunColor.rgb * sunIntensity;

    // View direction (from camera to froxel)
    vec3 viewDir = normalize(worldPos - ubo.cameraPosition.xyz);

    // Phase function for forward/back scattering
    float cosTheta = dot(viewDir, sunDir);
    float phase = henyeyGreenstein(cosTheta, 0.7);  // Slightly forward scattering for haze

    // Sun visibility based on sun angle (day/night)
    float sunVisibility = smoothstep(-0.1, 0.2, sunDir.y);

    // Sample cascade shadow map for this froxel position
    // Use linear depth as view-space depth approximation for cascade selection
    float shadow = 1.0;
    if (sunVisibility > 0.01) {
        shadow = sampleCascadeShadow(worldPos, linearDepth);
    }

    // Combine sun visibility with shadow
    float totalShadow = sunVisibility * shadow;

    // In-scattering from sun (attenuated by shadow)
    vec3 sunInScatter = sunLight * phase * totalShadow * density * 2.0;

    // Ambient sky/fog contribution - this makes fog VISIBLE as bright fog, not just opacity
    // Without this, fog only absorbs light and appears as dark occlusion
    float night = 1.0 - smoothstep(-0.05, 0.08, sunDir.y);
    vec3 fogBaseColor = mix(vec3(0.7, 0.75, 0.85), vec3(0.1, 0.12, 0.15), night);

    // Strong ambient scatter ensures fog is always bright, not just dark
    vec3 ambientScatter = fogBaseColor * density * 3.0;

    // Local light contribution (point and spot lights)
    vec3 localLightScatter = computeLocalLightScatter(worldPos, viewDir, density) * 3.0;

    // Total in-scattering - fog should be BRIGHT where it exists
    vec3 totalInScatter = sunInScatter + ambientScatter + localLightScatter;

    // =========================================================================
    // Temporal Reprojection
    // =========================================================================
    vec4 currentData = vec4(totalInScatter, density);

    // Get temporal blend factor from gridParams.w (0 = no temporal, higher = more stable)
    float temporalBlend = ubo.gridParams.w;

    // Only apply temporal filtering if enabled (temporalBlend > 0)
    if (temporalBlend > 0.01) {
        // Reproject current position to previous frame
        vec3 prevUVW = reprojectToPrevFrame(worldPos);

        if (isReprojectionValid(prevUVW)) {
            // Sample history from previous frame
            vec4 historyData = sampleHistory(prevUVW);

            // Neighborhood clamping to prevent ghosting
            // Simple approach: clamp history to reasonable range around current value
            float densityDiff = abs(historyData.a - currentData.a);
            float colorDiff = length(historyData.rgb - currentData.rgb);

            // Adaptive blend factor: reduce history weight when data changes significantly
            // This prevents ghosting when fog conditions change rapidly
            float adaptiveBlend = temporalBlend;
            adaptiveBlend *= smoothstep(0.5, 0.0, densityDiff);  // Reject on large density change
            adaptiveBlend *= smoothstep(2.0, 0.0, colorDiff);     // Reject on large color change

            // Clamp blend factor to reasonable range
            adaptiveBlend = clamp(adaptiveBlend, 1.0 - TEMPORAL_BLEND_MAX, 1.0 - TEMPORAL_BLEND_MIN);

            // Blend current with history
            currentData = mix(currentData, historyData, 1.0 - adaptiveBlend);
        }
    }

    // Store L / alpha for anti-aliased compositing (Ghost of Tsushima technique)
    // Alpha will be computed during integration
    imageStore(scatteringVolume, texel, currentData);
}

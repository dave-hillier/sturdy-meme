#version 450

// Froxel Update Compute Shader (Phase 4.3)
// Calculates fog density and in-scattered light for each froxel
// Features: cascade shadow map sampling, temporal reprojection

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(binding = 0, rgba16f) uniform image3D scatteringVolume;  // Current frame (read/write for temporal)
layout(binding = 1, rgba16f) uniform image3D integratedVolume;  // Previous frame for temporal

const int NUM_CASCADES = 4;

layout(binding = 2) uniform FroxelUniforms {
    mat4 invViewProj;
    mat4 prevViewProj;
    mat4 cascadeViewProj[NUM_CASCADES];  // Light-space matrices for shadow cascades
    vec4 cascadeSplits;                   // View-space split depths
    vec4 cameraPosition;
    vec4 sunDirection;      // xyz = direction, w = intensity
    vec4 sunColor;
    vec4 fogParams;         // x = base height, y = scale height, z = density, w = absorption
    vec4 layerParams;       // x = layer height, y = layer thickness, z = layer density
    vec4 gridParams;        // x = volumetric far, y = depth distribution, z = frame index, w = temporal blend
    vec4 shadowParams;      // x = shadow map size, y = shadow bias, z = pcf radius
} ubo;

// Temporal reprojection blend factor
const float TEMPORAL_BLEND_MIN = 0.85;  // Minimum history weight (fast adaptation)
const float TEMPORAL_BLEND_MAX = 0.97;  // Maximum history weight (high stability)

layout(binding = 3) uniform sampler2DArrayShadow shadowMap;

// Froxel grid constants
const uint FROXEL_WIDTH = 128;
const uint FROXEL_HEIGHT = 64;
const uint FROXEL_DEPTH = 64;

const float PI = 3.14159265359;

// Convert slice index to linear depth using exponential distribution
float sliceToDepth(float slice) {
    float depthDist = ubo.gridParams.y;  // Depth distribution factor
    float volumetricFar = ubo.gridParams.x;
    return volumetricFar * (pow(depthDist, slice) - 1.0) / (pow(depthDist, float(FROXEL_DEPTH)) - 1.0);
}

// Exponential height density (general atmospheric haze)
float exponentialHeightDensity(float height) {
    float baseHeight = ubo.fogParams.x;
    float scaleHeight = ubo.fogParams.y;
    float density = ubo.fogParams.z;
    float relHeight = height - baseHeight;
    return density * exp(-max(relHeight, 0.0) / scaleHeight);
}

// Sigmoidal layer density (ground fog layer)
float sigmoidalLayerDensity(float height) {
    float layerHeight = ubo.layerParams.x;
    float layerThickness = ubo.layerParams.y;
    float layerDensity = ubo.layerParams.z;
    float t = (height - layerHeight) / max(layerThickness, 0.001);
    return layerDensity / (1.0 + exp(t * 2.0));
}

// Combined fog density at height
float getHazeDensity(vec3 worldPos) {
    float height = worldPos.y;
    return exponentialHeightDensity(height) + sigmoidalLayerDensity(height);
}

// Henyey-Greenstein phase function
float henyeyGreenstein(float cosTheta, float g) {
    float g2 = g * g;
    float denom = 1.0 + g2 - 2.0 * g * cosTheta;
    return (1.0 - g2) / (4.0 * PI * pow(denom, 1.5));
}

// Simple hash for temporal jittering
float hash(vec3 p) {
    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
}

// Blue noise approximation for jittering
vec2 blueNoise2D(ivec2 texel, float frame) {
    vec2 r = vec2(hash(vec3(texel, frame)),
                  hash(vec3(texel + ivec2(100, 200), frame + 0.5)));
    return r;
}

// ============================================================================
// Temporal Reprojection
// ============================================================================

// Convert depth slice to linear depth
float sliceToLinearDepth(float slice) {
    float depthDist = ubo.gridParams.y;
    float volumetricFar = ubo.gridParams.x;
    return volumetricFar * (pow(depthDist, slice) - 1.0) / (pow(depthDist, float(FROXEL_DEPTH)) - 1.0);
}

// Convert linear depth to slice index
float linearDepthToSlice(float linearDepth) {
    float volumetricFar = ubo.gridParams.x;
    float depthDist = ubo.gridParams.y;
    float normalized = clamp(linearDepth / volumetricFar, 0.0, 1.0);
    return log(1.0 + normalized * (pow(depthDist, float(FROXEL_DEPTH)) - 1.0)) / log(depthDist);
}

// Reproject current world position to previous frame's froxel UVW
vec3 reprojectToPrevFrame(vec3 worldPos) {
    // Transform to previous frame's clip space
    vec4 prevClip = ubo.prevViewProj * vec4(worldPos, 1.0);
    vec3 prevNDC = prevClip.xyz / prevClip.w;

    // Convert NDC to UV (Vulkan: Y is already correct, Z is 0-1)
    vec2 prevUV = prevNDC.xy * 0.5 + 0.5;

    // Estimate previous depth (approximate - assume static fog)
    // For moving fog particles, this would need velocity vectors
    float prevLinearDepth = abs(prevClip.w);  // View-space depth
    float prevSlice = linearDepthToSlice(prevLinearDepth);
    float prevW = prevSlice / float(FROXEL_DEPTH);

    return vec3(prevUV, prevW);
}

// Check if reprojected coordinates are valid
bool isReprojectionValid(vec3 prevUVW) {
    // Check bounds
    if (prevUVW.x < 0.0 || prevUVW.x > 1.0 ||
        prevUVW.y < 0.0 || prevUVW.y > 1.0 ||
        prevUVW.z < 0.0 || prevUVW.z > 1.0) {
        return false;
    }
    return true;
}

// Sample history with bilinear interpolation
vec4 sampleHistory(vec3 uvw) {
    // Convert UVW to texel coordinates
    vec3 texelCoord = uvw * vec3(float(FROXEL_WIDTH), float(FROXEL_HEIGHT), float(FROXEL_DEPTH)) - 0.5;
    ivec3 texel0 = ivec3(floor(texelCoord));
    vec3 frac = fract(texelCoord);

    // Clamp to valid range
    texel0 = clamp(texel0, ivec3(0), ivec3(FROXEL_WIDTH - 1, FROXEL_HEIGHT - 1, FROXEL_DEPTH - 1));
    ivec3 texel1 = min(texel0 + 1, ivec3(FROXEL_WIDTH - 1, FROXEL_HEIGHT - 1, FROXEL_DEPTH - 1));

    // 8-tap trilinear sampling from scattering volume (which holds previous frame's data)
    vec4 c000 = imageLoad(scatteringVolume, ivec3(texel0.x, texel0.y, texel0.z));
    vec4 c100 = imageLoad(scatteringVolume, ivec3(texel1.x, texel0.y, texel0.z));
    vec4 c010 = imageLoad(scatteringVolume, ivec3(texel0.x, texel1.y, texel0.z));
    vec4 c110 = imageLoad(scatteringVolume, ivec3(texel1.x, texel1.y, texel0.z));
    vec4 c001 = imageLoad(scatteringVolume, ivec3(texel0.x, texel0.y, texel1.z));
    vec4 c101 = imageLoad(scatteringVolume, ivec3(texel1.x, texel0.y, texel1.z));
    vec4 c011 = imageLoad(scatteringVolume, ivec3(texel0.x, texel1.y, texel1.z));
    vec4 c111 = imageLoad(scatteringVolume, ivec3(texel1.x, texel1.y, texel1.z));

    // Trilinear interpolation
    vec4 c00 = mix(c000, c100, frac.x);
    vec4 c10 = mix(c010, c110, frac.x);
    vec4 c01 = mix(c001, c101, frac.x);
    vec4 c11 = mix(c011, c111, frac.x);

    vec4 c0 = mix(c00, c10, frac.y);
    vec4 c1 = mix(c01, c11, frac.y);

    return mix(c0, c1, frac.z);
}

// ============================================================================
// Cascade Shadow Map Sampling
// ============================================================================

// Select which cascade to use based on view-space depth
int selectCascade(float viewSpaceDepth) {
    for (int i = 0; i < NUM_CASCADES; i++) {
        if (viewSpaceDepth < ubo.cascadeSplits[i]) {
            return i;
        }
    }
    return NUM_CASCADES - 1;
}

// Sample shadow map with PCF (Percentage Closer Filtering)
float sampleShadowPCF(vec3 worldPos, int cascade) {
    // Transform world position to light space
    vec4 lightSpacePos = ubo.cascadeViewProj[cascade] * vec4(worldPos, 1.0);
    vec3 projCoords = lightSpacePos.xyz / lightSpacePos.w;

    // Convert from [-1,1] to [0,1] for UV coordinates (Vulkan NDC)
    vec2 shadowUV = projCoords.xy * 0.5 + 0.5;

    // Check if position is outside shadow map bounds
    if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {
        return 1.0;  // Outside shadow map = lit
    }

    // Shadow bias to prevent acne (smaller for volumetrics)
    float bias = ubo.shadowParams.y;
    float compareDepth = projCoords.z - bias;

    // Simple PCF with 4 samples for volumetrics (lighter weight than scene shadows)
    float shadow = 0.0;
    float texelSize = 1.0 / ubo.shadowParams.x;
    float pcfRadius = ubo.shadowParams.z;

    // 2x2 PCF kernel
    for (int x = -1; x <= 0; x++) {
        for (int y = -1; y <= 0; y++) {
            vec2 offset = vec2(float(x) + 0.5, float(y) + 0.5) * texelSize * pcfRadius;
            // texture() with sampler2DArrayShadow returns comparison result
            shadow += texture(shadowMap, vec4(shadowUV + offset, float(cascade), compareDepth));
        }
    }

    return shadow / 4.0;
}

// Sample shadow for a world position (full cascade selection + PCF)
float sampleCascadeShadow(vec3 worldPos, float viewSpaceDepth) {
    // Select appropriate cascade
    int cascade = selectCascade(viewSpaceDepth);

    // Sample shadow with PCF
    return sampleShadowPCF(worldPos, cascade);
}

void main() {
    ivec3 texel = ivec3(gl_GlobalInvocationID);

    // Bounds check
    if (texel.x >= FROXEL_WIDTH || texel.y >= FROXEL_HEIGHT || texel.z >= FROXEL_DEPTH) {
        return;
    }

    // Convert froxel coordinates to UVW
    vec3 uvw = (vec3(texel) + 0.5) / vec3(FROXEL_WIDTH, FROXEL_HEIGHT, FROXEL_DEPTH);

    // Get linear depth for this slice
    float linearDepth = sliceToDepth(uvw.z * float(FROXEL_DEPTH));

    // Convert to NDC (note: Vulkan NDC has Y down, Z 0-1)
    vec2 ndc = uvw.xy * 2.0 - 1.0;

    // Reconstruct world position using inverse view-proj
    // First convert linear depth to NDC depth
    // Approximate: assume near=0.1, far=volumetricFar
    float ndcDepth = linearDepth / ubo.gridParams.x;  // Simplified

    vec4 clipPos = vec4(ndc.x, ndc.y, ndcDepth, 1.0);
    vec4 worldPos4 = ubo.invViewProj * clipPos;
    vec3 worldPos = worldPos4.xyz / worldPos4.w;

    // Sample fog density
    float density = getHazeDensity(worldPos);

    // Early out if no density
    if (density < 0.0001) {
        imageStore(scatteringVolume, texel, vec4(0.0));
        return;
    }

    // Jitter for temporal stability
    vec2 jitter = blueNoise2D(texel.xy, ubo.gridParams.z) * 0.5 - 0.25;

    // Sun direction and lighting
    vec3 sunDir = normalize(ubo.sunDirection.xyz);
    float sunIntensity = ubo.sunDirection.w;
    vec3 sunLight = ubo.sunColor.rgb * sunIntensity;

    // View direction (from camera to froxel)
    vec3 viewDir = normalize(worldPos - ubo.cameraPosition.xyz);

    // Phase function for forward/back scattering
    float cosTheta = dot(viewDir, sunDir);
    float phase = henyeyGreenstein(cosTheta, 0.7);  // Slightly forward scattering for haze

    // Sun visibility based on sun angle (day/night)
    float sunVisibility = smoothstep(-0.1, 0.2, sunDir.y);

    // Sample cascade shadow map for this froxel position
    // Use linear depth as view-space depth approximation for cascade selection
    float shadow = 1.0;
    if (sunVisibility > 0.01) {
        shadow = sampleCascadeShadow(worldPos, linearDepth);
    }

    // Combine sun visibility with shadow
    float totalShadow = sunVisibility * shadow;

    // In-scattering from sun (attenuated by shadow)
    vec3 sunInScatter = sunLight * phase * totalShadow * density;

    // Ambient sky contribution (isotropic)
    float night = 1.0 - smoothstep(-0.05, 0.08, sunDir.y);
    vec3 skyColor = mix(vec3(0.4, 0.5, 0.7), vec3(0.02, 0.03, 0.05), night);
    vec3 skyInScatter = skyColor * density * 0.15;  // Ambient scatter

    // Total in-scattering
    vec3 totalInScatter = sunInScatter + skyInScatter;

    // =========================================================================
    // Temporal Reprojection
    // =========================================================================
    vec4 currentData = vec4(totalInScatter, density);

    // Get temporal blend factor from gridParams.w (0 = no temporal, higher = more stable)
    float temporalBlend = ubo.gridParams.w;

    // Only apply temporal filtering if enabled (temporalBlend > 0)
    if (temporalBlend > 0.01) {
        // Reproject current position to previous frame
        vec3 prevUVW = reprojectToPrevFrame(worldPos);

        if (isReprojectionValid(prevUVW)) {
            // Sample history from previous frame
            vec4 historyData = sampleHistory(prevUVW);

            // Neighborhood clamping to prevent ghosting
            // Simple approach: clamp history to reasonable range around current value
            float densityDiff = abs(historyData.a - currentData.a);
            float colorDiff = length(historyData.rgb - currentData.rgb);

            // Adaptive blend factor: reduce history weight when data changes significantly
            // This prevents ghosting when fog conditions change rapidly
            float adaptiveBlend = temporalBlend;
            adaptiveBlend *= smoothstep(0.5, 0.0, densityDiff);  // Reject on large density change
            adaptiveBlend *= smoothstep(2.0, 0.0, colorDiff);     // Reject on large color change

            // Clamp blend factor to reasonable range
            adaptiveBlend = clamp(adaptiveBlend, 1.0 - TEMPORAL_BLEND_MAX, 1.0 - TEMPORAL_BLEND_MIN);

            // Blend current with history
            currentData = mix(currentData, historyData, 1.0 - adaptiveBlend);
        }
    }

    // Store L / alpha for anti-aliased compositing (Ghost of Tsushima technique)
    // Alpha will be computed during integration
    imageStore(scatteringVolume, texel, currentData);
}

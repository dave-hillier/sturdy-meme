#version 450

#extension GL_GOOGLE_include_directive : require

/*
 * terrain_dispatcher.comp - Sets up indirect dispatch and draw arguments
 * This shader reads the leaf count from the CBT and configures:
 *  - Indirect dispatch args for subdivision compute shader
 *  - Indirect draw args for terrain rendering
 *  - Resets visible count for stream compaction (optimization: avoids CPU fillBuffer)
 */

#include "../bindings.glsl"

#define CBT_BUFFER_BINDING BINDING_TERRAIN_CBT_BUFFER
#include "cbt.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Indirect dispatch arguments for subdivision compute shader
layout(std430, binding = BINDING_TERRAIN_DISPATCH) buffer DispatchIndirect {
    uint dispatchX;
    uint dispatchY;
    uint dispatchZ;
};

// Indirect draw arguments for terrain rendering (indexed draw when using meshlets)
layout(std430, binding = BINDING_TERRAIN_DRAW) buffer DrawIndirect {
    uint indexCount;       // For indexed: index count; for non-indexed: vertex count
    uint instanceCount;
    uint firstIndex;       // For indexed: first index; for non-indexed: first vertex
    uint vertexOffset;     // For indexed only: vertex offset
    uint firstInstance;
};

// Visible indices buffer for stream compaction - reset count here
layout(std430, binding = BINDING_TERRAIN_VISIBLE_INDICES) buffer VisibleIndices {
    uint visibleCount;
    // uint indices[]; // Not needed, just reset the count
};

// Push constants for configuration
layout(push_constant) uniform PushConstants {
    uint subdivisionWorkgroupSize;  // Threads per workgroup in subdivision shader
    uint meshletIndexCount;         // Indices per meshlet (0 = no meshlets, just triangles)
};

void main() {
    uint leafCount = cbt_NodeCount();

    // Set up subdivision dispatch (one thread per leaf)
    dispatchX = (leafCount + subdivisionWorkgroupSize - 1u) / subdivisionWorkgroupSize;
    dispatchY = 1u;
    dispatchZ = 1u;

    // Set up draw arguments
    if (meshletIndexCount > 0u) {
        // Instanced indexed meshlet rendering: one instance per leaf
        indexCount = meshletIndexCount;
        instanceCount = leafCount;
        firstIndex = 0u;
        vertexOffset = 0u;
    } else {
        // Direct triangle rendering: 3 vertices per leaf (non-indexed)
        indexCount = leafCount * 3u;  // Actually vertexCount for non-indexed
        instanceCount = 1u;
        firstIndex = 0u;              // Actually firstVertex for non-indexed
        vertexOffset = 0u;            // Unused for non-indexed
    }
    firstInstance = 0u;

    // Reset visible count for next frame's stream compaction
    // This replaces vkCmdFillBuffer on CPU side
    visibleCount = 0u;
}

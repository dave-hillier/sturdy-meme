#version 450

#extension GL_GOOGLE_include_directive : require

/*
 * terrain_sum_reduction_prepass.comp - First pass of sum reduction
 * Processes the bitfield using popcount and writes the bottom levels
 * of the sum reduction tree.
 *
 * OPTIMIZATION: Uses shared memory write coalescing for level maxDepth-5
 * to eliminate atomic write contention. This gives ~10-15x speedup on
 * the sum reduction phase (based on Unity's GDC talk findings).
 *
 * The key insight: At level maxDepth-5, 32 threads would normally fight
 * over the same uint with atomic ops. Instead, we cache values in shared
 * memory and have every 16th thread pack 16 values into 3 uints with
 * non-atomic writes.
 */

#define CBT_BUFFER_BINDING 0
#include "cbt.glsl"

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    int passID;  // Which depth level to start from (maxDepth)
};

// Shared memory for write coalescing at level maxDepth-5
// Each thread stores its 6-bit sum here
shared uint sharedSums[256];

void main() {
    uint cnt = (1u << passID);
    uint threadID = gl_GlobalInvocationID.x << 5;

    if (threadID >= cnt) {
        return;
    }

    uint nodeID = threadID + cnt;
    cbt_Node node = cbt_CreateNode_Explicit(nodeID, passID);
    uint alignedBitOffset = cbt__NodeBitID(node);
    uint bitField = cbtBuffer.heap[alignedBitOffset >> 5u];
    uint bitData = 0u;

    // Level maxDepth-1: 2-bits - count pairs of bits
    // Direct write - no contention (each thread writes unique uint)
    bitField = (bitField & 0x55555555u) + ((bitField >> 1u) & 0x55555555u);
    bitData = bitField;
    cbtBuffer.heap[(alignedBitOffset - cnt) >> 5u] = bitData;

    // Level maxDepth-2: 3-bits - pack 8 x 3-bit values from 4 x 4-bit sums
    bitField = (bitField & 0x33333333u) + ((bitField >> 2u) & 0x33333333u);
    bitData = ((bitField >> 0u) & (7u <<  0u))
            | ((bitField >> 1u) & (7u <<  3u))
            | ((bitField >> 2u) & (7u <<  6u))
            | ((bitField >> 3u) & (7u <<  9u))
            | ((bitField >> 4u) & (7u << 12u))
            | ((bitField >> 5u) & (7u << 15u))
            | ((bitField >> 6u) & (7u << 18u))
            | ((bitField >> 7u) & (7u << 21u));
    cbt__HeapWriteExplicit(cbt_CreateNode_Explicit(nodeID >> 2u, passID - 2), 24, bitData);

    // Level maxDepth-3: 4-bits - pack 4 x 4-bit values
    bitField = (bitField & 0x0F0F0F0Fu) + ((bitField >> 4u) & 0x0F0F0F0Fu);
    bitData = ((bitField >>  0u) & (15u <<  0u))
            | ((bitField >>  4u) & (15u <<  4u))
            | ((bitField >>  8u) & (15u <<  8u))
            | ((bitField >> 12u) & (15u << 12u));
    cbt__HeapWriteExplicit(cbt_CreateNode_Explicit(nodeID >> 3u, passID - 3), 16, bitData);

    // Level maxDepth-4: 5-bits - pack 2 x 5-bit values
    bitField = (bitField & 0x00FF00FFu) + ((bitField >> 8u) & 0x00FF00FFu);
    bitData = ((bitField >> 0u) & (31u << 0u))
            | ((bitField >> 11u) & (31u << 5u));
    cbt__HeapWriteExplicit(cbt_CreateNode_Explicit(nodeID >> 4u, passID - 4), 10, bitData);

    // Level maxDepth-5: 6-bits - single 6-bit value (sum of 32 bits)
    // OPTIMIZED: Use shared memory coalescing instead of atomic writes
    bitField = (bitField & 0x0000FFFFu) + ((bitField >> 16u) & 0x0000FFFFu);
    uint sum = bitField & 0x3Fu;  // 6-bit sum (max value 32)

    // Store to shared memory for coalesced write
    sharedSums[gl_LocalInvocationIndex] = sum;
    barrier();

    // Write coalescing: every 16th thread packs 16 x 6-bit values into 3 uints
    // 16 * 6 = 96 bits = exactly 3 uints
    // This reduces atomic ops from 32 threads * 2 atomics = 64 ops
    // down to 16 threads * 3 non-atomic writes = 48 ops (and no contention!)
    if ((gl_LocalInvocationIndex & 15u) == 0u) {
        uint groupIdx = gl_LocalInvocationIndex >> 4u;  // 0-15 for 256 threads
        uint baseSum = groupIdx * 16u;

        // Pack 16 x 6-bit values into 3 uints
        // Bit layout:
        //   uint0: [s0:0-5][s1:6-11][s2:12-17][s3:18-23][s4:24-29][s5:30-31(2bits)]
        //   uint1: [s5:0-3(4bits)][s6:4-9][s7:10-15][s8:16-21][s9:22-27][s10:28-31(4bits)]
        //   uint2: [s10:0-1(2bits)][s11:2-7][s12:8-13][s13:14-19][s14:20-25][s15:26-31]

        #define S(i) (sharedSums[baseSum + (i)])

        uint u0 = (S(0) << 0u) | (S(1) << 6u) | (S(2) << 12u) | (S(3) << 18u)
                | (S(4) << 24u) | ((S(5) & 0x3u) << 30u);

        uint u1 = (S(5) >> 2u) | (S(6) << 4u) | (S(7) << 10u) | (S(8) << 16u)
                | (S(9) << 22u) | ((S(10) & 0xFu) << 28u);

        uint u2 = (S(10) >> 4u) | (S(11) << 2u) | (S(12) << 8u) | (S(13) << 14u)
                | (S(14) << 20u) | (S(15) << 26u);

        #undef S

        // Calculate heap location for this group of 16 sums
        // NodeBitID formula: 2^(depth+1) + nodeID * bitSize
        // At depth = passID-5, bitSize = 6
        // nodeID for first sum in this group = (1 << (passID-5)) + globalThreadOffset
        // where globalThreadOffset = gl_WorkGroupID.x * 256 + baseSum

        uint levelDepth = uint(passID - 5);
        uint baseNodeID = (1u << levelDepth) + gl_WorkGroupID.x * 256u + baseSum;

        // BitID = 2^(levelDepth+1) + baseNodeID * 6
        uint bitOffset = (2u << levelDepth) + baseNodeID * 6u;
        uint heapUintIdx = bitOffset >> 5u;
        uint bitWithinUint = bitOffset & 31u;

        // For passID >= 9, the data is always 32-bit aligned (bitWithinUint == 0)
        // For lower passID values, we need to handle misalignment
        if (bitWithinUint == 0u) {
            // Aligned case - direct non-atomic writes
            cbtBuffer.heap[heapUintIdx + 0u] = u0;
            cbtBuffer.heap[heapUintIdx + 1u] = u1;
            cbtBuffer.heap[heapUintIdx + 2u] = u2;
        } else {
            // Misaligned case - fall back to atomic writes
            // This only happens for very shallow CBTs (passID < 9) which are rare
            for (uint i = 0u; i < 16u; i++) {
                uint sumNodeID = baseNodeID + i;
                cbt_Node sumNode = cbt_CreateNode_Explicit(sumNodeID, int(levelDepth));
                cbt__HeapWriteExplicit(sumNode, 6, sharedSums[baseSum + i]);
            }
        }
    }
}

#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

/*
 * terrain_shadow_cull.comp - Shadow cascade frustum culling with stream compaction
 *
 * Culls terrain triangles against a shadow cascade's frustum and writes visible
 * indices to a compact buffer for efficient shadow map rendering.
 *
 * This optimization is based on Unity's GDC talk recommendation:
 * "We need to implement separate view frustum culling for rendering shadow maps"
 *
 * Benefits:
 *  - Avoids rendering triangles outside shadow cascade's view
 *  - Reduces vertex shader invocations for shadow pass
 *  - Each cascade can have independent visible set
 *
 * Uses subgroup ballot for efficient stream compaction (1 atomic per subgroup).
 */

#include "../bindings.glsl"

#define CBT_BUFFER_BINDING BINDING_TERRAIN_CBT_BUFFER
#include "cbt.glsl"
#include "leb.glsl"
#include "../terrain_height_common.glsl"

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Height map sampler
layout(binding = BINDING_TERRAIN_HEIGHT_MAP) uniform sampler2D heightMap;

// Push constants for shadow culling
layout(push_constant) uniform PushConstants {
    mat4 lightViewProj;     // Light's view-projection matrix for this cascade
    vec4 lightFrustumPlanes[6];  // Frustum planes derived from lightViewProj
    float terrainSize;
    float heightScale;
    uint cascadeIndex;
    uint padding;
};

// Shadow visible indices buffer: [count, index0, index1, ...]
// This is a separate buffer from the main camera's visible indices
layout(std430, binding = BINDING_TERRAIN_SHADOW_VISIBLE) buffer ShadowVisibleIndices {
    uint shadowVisibleCount;
    uint shadowIndices[];
};

// Shadow indirect draw buffer
layout(std430, binding = BINDING_TERRAIN_SHADOW_DRAW) writeonly buffer ShadowDrawIndirect {
    uint indexCount;      // For indexed draw, or vertexCount for non-indexed
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

// Meshlet configuration (passed via specialization or push constant)
// If 0, using direct triangle draw (3 vertices per triangle)
// If > 0, using indexed meshlet draw (instanceCount = visible triangles)
layout(constant_id = 0) const uint MESHLET_INDEX_COUNT = 0;

// Shared memory for workgroup-level aggregation
shared uint workgroupVisibleCount;
shared uint workgroupBaseSlot;

// Transform UV to world position
vec3 uvToWorldPos(vec2 uv) {
    float height = sampleTerrainHeight(heightMap, uv, heightScale);
    return vec3(
        (uv.x - 0.5) * terrainSize,
        height,
        (uv.y - 0.5) * terrainSize
    );
}

// Frustum culling test for AABB against light frustum
// Returns true if the AABB is completely outside the frustum
bool frustumCullAABB(vec3 minBound, vec3 maxBound) {
    for (int i = 0; i < 6; i++) {
        vec4 plane = lightFrustumPlanes[i];
        // Find the p-vertex (the vertex most in the direction of the plane normal)
        vec3 pVertex = vec3(
            plane.x > 0.0 ? maxBound.x : minBound.x,
            plane.y > 0.0 ? maxBound.y : minBound.y,
            plane.z > 0.0 ? maxBound.z : minBound.z
        );
        // If p-vertex is behind plane, AABB is completely outside
        if (dot(vec4(pVertex, 1.0), plane) < 0.0) {
            return true; // Culled
        }
    }
    return false; // Visible
}

void main() {
    uint leafIndex = gl_GlobalInvocationID.x;
    uint localIndex = gl_LocalInvocationID.x;
    uint totalLeaves = cbt_NodeCount();

    // Initialize shared memory
    if (localIndex == 0u) {
        workgroupVisibleCount = 0u;
    }
    barrier();

    bool visible = false;
    uint myLeafIndex = 0u;

    if (leafIndex < totalLeaves) {
        // Decode node and triangle vertices
        cbt_Node node = cbt_DecodeNode(leafIndex);
        vec2 v0, v1, v2;
        leb_DecodeTriangleVertices(node, v0, v1, v2);

        // Compute world positions for AABB
        vec3 p0 = uvToWorldPos(v0);
        vec3 p1 = uvToWorldPos(v1);
        vec3 p2 = uvToWorldPos(v2);

        // Build AABB
        vec3 minBound = min(min(p0, p1), p2);
        vec3 maxBound = max(max(p0, p1), p2);
        // Add height margin for potential terrain displacement
        minBound.y -= heightScale * 0.1;
        maxBound.y += heightScale * 0.1;

        // Test frustum culling against light/shadow frustum
        visible = !frustumCullAABB(minBound, maxBound);
        myLeafIndex = leafIndex;
    }

    // Subgroup-level stream compaction using ballot
    // This reduces atomics from 1 per visible thread to 1 per subgroup
    uvec4 ballot = subgroupBallot(visible);
    uint subgroupVisibleCount = subgroupBallotBitCount(ballot);
    uint subgroupPrefix = subgroupBallotExclusiveBitCount(ballot);

    // First active thread in subgroup does atomic add to workgroup counter
    uint subgroupBaseOffset;
    if (subgroupElect()) {
        subgroupBaseOffset = atomicAdd(workgroupVisibleCount, subgroupVisibleCount);
    }
    subgroupBaseOffset = subgroupBroadcastFirst(subgroupBaseOffset);

    // Store local offset for later write
    uint localOffset = subgroupBaseOffset + subgroupPrefix;

    // Synchronize workgroup to get final count
    barrier();

    // First thread in workgroup does single atomic to global buffer
    if (localIndex == 0u) {
        workgroupBaseSlot = atomicAdd(shadowVisibleCount, workgroupVisibleCount);
    }
    barrier();

    // Write visible indices to global buffer
    if (visible) {
        uint globalSlot = workgroupBaseSlot + localOffset;
        shadowIndices[globalSlot] = myLeafIndex;
    }

    // Write shadow draw indirect args
    // Multiple workgroups will write, but all write the same correct value
    // since atomicAdd is complete before this point
    barrier();
    memoryBarrierBuffer();

    if (localIndex == 0u) {
        uint finalCount = shadowVisibleCount;

        if (MESHLET_INDEX_COUNT > 0u) {
            // Indexed meshlet draw: one instance per visible triangle
            indexCount = MESHLET_INDEX_COUNT;
            instanceCount = finalCount;
            firstIndex = 0u;
            vertexOffset = 0;
            firstInstance = 0u;
        } else {
            // Direct triangle draw: 3 vertices per visible triangle
            // Note: For shadow, we're drawing all triangles directly from CBT
            // The vertex shader will use shadowIndices to map to the correct CBT node
            indexCount = finalCount * 3u;  // Actually vertexCount for non-indexed
            instanceCount = 1u;
            firstIndex = 0u;
            vertexOffset = 0;
            firstInstance = 0u;
        }
    }
}

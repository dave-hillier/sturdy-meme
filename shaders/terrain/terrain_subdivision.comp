#version 450

#extension GL_GOOGLE_include_directive : require

/*
 * terrain_subdivision.comp - LOD evaluation and adaptive subdivision
 * Each thread processes one leaf triangle and decides whether to split or merge
 * Height convention: see terrain_height_common.glsl
 */

#define CBT_BUFFER_BINDING 0
#include "cbt.glsl"
#include "leb.glsl"
#include "../terrain_height_common.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for update mode
layout(push_constant) uniform PushConstants {
    uint updateMode;  // 0 = split only, 1 = merge only
};

// Height map sampler
layout(binding = 3) uniform sampler2D heightMap;

// Uniform buffer with camera and terrain parameters
layout(std140, binding = 4) uniform TerrainUniforms {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    vec4 frustumPlanes[6];
    vec4 cameraPosition;
    vec4 terrainParams;   // x = size, y = height scale, z = target edge pixels, w = max depth
    vec4 lodParams;       // x = split threshold, y = merge threshold, z = min depth, w = subdivisionPhase (0=split, 1=merge)
    vec2 screenSize;
    float lodFactor;
    float padding;
};

// Subdivision phase: 0 = split only, 1 = merge only
#define SUBDIVISION_PHASE (int(lodParams.w))

// Extract parameters
#define TERRAIN_SIZE (terrainParams.x)
#define HEIGHT_SCALE (terrainParams.y)
#define TARGET_EDGE_PIXELS (terrainParams.z)
#define MAX_DEPTH (int(terrainParams.w))
#define SPLIT_THRESHOLD (lodParams.x)
#define MERGE_THRESHOLD (lodParams.y)
#define MIN_DEPTH (int(lodParams.z))

// Sample terrain height at UV coordinate (uses shared terrain_height_common.glsl)
float sampleHeight(vec2 uv) {
    return sampleTerrainHeight(heightMap, uv, HEIGHT_SCALE);
}

// Compute heightmap gradient (direction of steepest ascent in UV space)
vec2 computeGradient(vec2 uv) {
    vec2 texelSize = 1.0 / vec2(textureSize(heightMap, 0));

    float hL = texture(heightMap, uv + vec2(-texelSize.x, 0.0)).r;
    float hR = texture(heightMap, uv + vec2(texelSize.x, 0.0)).r;
    float hD = texture(heightMap, uv + vec2(0.0, -texelSize.y)).r;
    float hU = texture(heightMap, uv + vec2(0.0, texelSize.y)).r;

    // Gradient in UV space (pointing uphill)
    return vec2(hR - hL, hU - hD) / (2.0 * texelSize);
}

// Compute slope magnitude (0 = flat, 1+ = steep)
float computeSlopeMagnitude(vec2 gradient) {
    // Scale gradient by terrain aspect ratio to get actual slope
    float gradientMag = length(gradient) * HEIGHT_SCALE / TERRAIN_SIZE;
    return gradientMag;
}

// Transform UV to world position
vec3 uvToWorldPos(vec2 uv) {
    float height = sampleHeight(uv);
    return vec3(
        (uv.x - 0.5) * TERRAIN_SIZE,
        height,
        (uv.y - 0.5) * TERRAIN_SIZE
    );
}

// Frustum culling test for AABB with optional margin
// margin > 0 expands the frustum outward (triangle must be further outside to be culled)
bool frustumCullAABB(vec3 minBound, vec3 maxBound, float margin) {
    for (int i = 0; i < 6; i++) {
        vec4 plane = frustumPlanes[i];
        vec3 pVertex = vec3(
            plane.x > 0.0 ? maxBound.x : minBound.x,
            plane.y > 0.0 ? maxBound.y : minBound.y,
            plane.z > 0.0 ? maxBound.z : minBound.z
        );
        // Offset the plane by margin (planes are normalized, so margin is in world units)
        if (dot(vec4(pVertex, 1.0), plane) < -margin) {
            return true; // Culled
        }
    }
    return false; // Visible
}

bool frustumCullAABB(vec3 minBound, vec3 maxBound) {
    return frustumCullAABB(minBound, maxBound, 0.0);
}

// Compute screen-space edge length
float computeScreenSpaceEdgeLength(vec3 p0, vec3 p1) {
    // Project both points to clip space
    vec4 c0 = viewProjMatrix * vec4(p0, 1.0);
    vec4 c1 = viewProjMatrix * vec4(p1, 1.0);

    // Handle behind-camera cases
    if (c0.w <= 0.0 || c1.w <= 0.0) {
        return 1e6; // Force split for edges behind camera
    }

    // Perspective divide to NDC
    vec2 ndc0 = c0.xy / c0.w;
    vec2 ndc1 = c1.xy / c1.w;

    // Convert to pixels
    vec2 s0 = (ndc0 * 0.5 + 0.5) * screenSize;
    vec2 s1 = (ndc1 * 0.5 + 0.5) * screenSize;

    return length(s1 - s0);
}

// Gradient alignment weight - higher values = more subdivision on cliffs
const float GRADIENT_ALIGNMENT_WEIGHT = 2.0;

// Distance-based LOD parameters
// Force high tessellation near the camera for player interaction
const float NEAR_CAMERA_DISTANCE = 50.0;    // Within this distance, strongly boost tessellation
const float NEAR_CAMERA_BOOST = 4.0;        // Multiplier for very close triangles

// Height error tolerance parameters
// Within CLOSE_DISTANCE: use strict world-space error tolerance (for physics/collision)
// Beyond CLOSE_DISTANCE: use screen-space projected error (for visual quality)
const float CLOSE_DISTANCE = 10.0;          // Distance within which world-space accuracy is critical
const float BASE_ERROR_TOLERANCE = 0.1;     // Max allowed height error (in world units) near camera

// Compute LOD for a triangle - returns longest edge length in pixels
// Modified to penalize triangles stretched along the terrain gradient (perpendicular to contours)
// Also includes camera distance priority and height error estimation
float computeTriangleLOD(vec2 v0, vec2 v1, vec2 v2) {
    vec3 p0 = uvToWorldPos(v0);
    vec3 p1 = uvToWorldPos(v1);
    vec3 p2 = uvToWorldPos(v2);

    // Find longest edge (in LEB, the longest edge is always between v1 and v2)
    float e12 = computeScreenSpaceEdgeLength(p1, p2);

    // Compute triangle center
    vec2 centerUV = (v0 + v1 + v2) / 3.0;
    vec3 centerWorld = (p0 + p1 + p2) / 3.0;

    // === Distance-based LOD boost ===
    // Prioritize high tessellation near the camera for player interaction
    float distToCamera = distance(cameraPosition.xyz, centerWorld);
    float distanceFactor = 1.0;
    if (distToCamera < NEAR_CAMERA_DISTANCE) {
        // Smoothly boost tessellation as we get closer
        // At distance 0: boost = NEAR_CAMERA_BOOST
        // At NEAR_CAMERA_DISTANCE: boost = 1.0
        float t = distToCamera / NEAR_CAMERA_DISTANCE;
        distanceFactor = mix(NEAR_CAMERA_BOOST, 1.0, t * t);  // Quadratic falloff
    }
    e12 *= distanceFactor;

    // === Height error estimation ===
    // Check if the triangle's linear interpolation matches the actual heightmap
    // This catches cases where terrain varies significantly within the triangle
    float actualCenterHeight = sampleHeight(centerUV);
    float interpolatedCenterHeight = (p0.y + p1.y + p2.y) / 3.0;
    float heightError = abs(actualCenterHeight - interpolatedCenterHeight);

    // Also sample edge midpoints for better error estimation
    vec2 midUV01 = (v0 + v1) * 0.5;
    vec2 midUV12 = (v1 + v2) * 0.5;
    vec2 midUV20 = (v2 + v0) * 0.5;

    float mid01Height = sampleHeight(midUV01);
    float mid12Height = sampleHeight(midUV12);
    float mid20Height = sampleHeight(midUV20);

    float interp01 = (p0.y + p1.y) * 0.5;
    float interp12 = (p1.y + p2.y) * 0.5;
    float interp20 = (p2.y + p0.y) * 0.5;

    heightError = max(heightError, abs(mid01Height - interp01));
    heightError = max(heightError, abs(mid12Height - interp12));
    heightError = max(heightError, abs(mid20Height - interp20));

    // Height error handling depends on distance:
    // - Near camera: use world-space error tolerance (for player interaction/physics)
    // - Far from camera: use screen-space error (for visual quality)

    if (distToCamera <= CLOSE_DISTANCE) {
        // Near camera: strict world-space error tolerance
        // Player needs accurate collision, so enforce tight error bounds
        if (heightError > BASE_ERROR_TOLERANCE) {
            float errorRatio = heightError / BASE_ERROR_TOLERANCE;
            e12 = max(e12, SPLIT_THRESHOLD * errorRatio);
        }
    } else {
        // Far from camera: screen-space error becomes more important
        // Project height error to approximate screen pixels
        // Height error at distance D subtends angle â‰ˆ error/D radians
        // Multiply by screen height to get pixel equivalent
        float errorAngle = heightError / distToCamera;
        float errorScreenPixels = errorAngle * screenSize.y * 0.5;

        // If the projected error is significant on screen, force subdivision
        // Use half the split threshold as our screen-space error target
        float targetScreenError = SPLIT_THRESHOLD * 0.5;
        if (errorScreenPixels > targetScreenError) {
            e12 = max(e12, errorScreenPixels * 2.0);
        }
    }

    // === Gradient-based refinement ===
    vec2 gradient = computeGradient(centerUV);
    float slopeMag = computeSlopeMagnitude(gradient);

    // Only apply gradient penalty on steep slopes
    if (slopeMag > 0.1) {
        // Edge direction in UV space (longest edge v1->v2)
        vec2 edgeDir = v2 - v1;
        float edgeLen = length(edgeDir);

        if (edgeLen > 0.0001) {
            edgeDir /= edgeLen;

            // How aligned is this edge with the gradient direction?
            // 1.0 = edge runs along gradient (bad - stretched on cliff)
            // 0.0 = edge runs along contour (good - aligned with cliff face)
            vec2 gradientDir = normalize(gradient);
            float gradientAlignment = abs(dot(edgeDir, gradientDir));

            // Penalize edges that run along the gradient direction
            // This encourages subdivision to create edges that run along contours
            float stretchFactor = 1.0 + gradientAlignment * slopeMag * GRADIENT_ALIGNMENT_WEIGHT;
            e12 *= stretchFactor;
        }
    }

    return e12;
}

void main() {
    uint leafIndex = gl_GlobalInvocationID.x;
    uint totalLeaves = cbt_NodeCount();

    if (leafIndex >= totalLeaves) {
        return;
    }

    // Decode leaf index to heap index
    cbt_Node node = cbt_DecodeNode(leafIndex);
    int depth = node.depth;

    // Decode triangle vertices
    vec2 v0, v1, v2;
    leb_DecodeTriangleVertices(node, v0, v1, v2);

    // Get world positions for frustum culling
    vec3 p0 = uvToWorldPos(v0);
    vec3 p1 = uvToWorldPos(v1);
    vec3 p2 = uvToWorldPos(v2);

    // Compute AABB with height margin
    vec3 minBound = min(min(p0, p1), p2);
    vec3 maxBound = max(max(p0, p1), p2);
    // Add height margin for terrain that might be displaced
    minBound.y -= HEIGHT_SCALE * 0.1;
    maxBound.y += HEIGHT_SCALE * 0.1;

    // Compute AABB diagonal for frustum margin calculation
    // This provides hysteresis for culling decisions near frustum boundaries
    vec3 aabbDiag = maxBound - minBound;
    float aabbDiagonal = length(aabbDiag);

    // Frustum culling for split decisions (exact frustum)
    bool culledForSplit = frustumCullAABB(minBound, maxBound);

    // Frustum culling for merge decisions (expanded frustum with margin)
    // Triangle must be at least half its diagonal outside the frustum before merge-culling
    // This prevents flickering when triangles are right at the frustum boundary
    float mergeCullMargin = aabbDiagonal * 0.5;
    bool culledForMerge = frustumCullAABB(minBound, maxBound, mergeCullMargin);

    // Compute screen-space edge length (needed for both modes)
    float edgeLengthPixels = computeTriangleLOD(v0, v1, v2);

    // Ping-pong between split and merge frames to avoid race conditions
    // This ensures that multiple threads don't simultaneously try to split and merge
    // related nodes, which could create inconsistent tree states
    if (updateMode == 0u) {
        // Split-only frame
        if (!culledForSplit && edgeLengthPixels > SPLIT_THRESHOLD && depth < MAX_DEPTH) {
            leb_SplitNode_Square(node);
        }
    } else {
        // Merge-only frame
        // Use culledForMerge (with margin) to prevent flickering at frustum boundaries
        if (culledForMerge) {
            // If well outside frustum and not at minimum depth, merge
            if (depth > MIN_DEPTH) {
                leb_DiamondParent diamond = leb_DecodeDiamondParent_Square(node);
                leb_MergeNode_Square(node, diamond);
            }
        } else if (edgeLengthPixels < MERGE_THRESHOLD && depth > MIN_DEPTH) {
            // Merge: combine with sibling
            leb_DiamondParent diamond = leb_DecodeDiamondParent_Square(node);
            leb_MergeNode_Square(node, diamond);
        }
    }
}

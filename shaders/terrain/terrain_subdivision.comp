#version 450

#extension GL_GOOGLE_include_directive : require

/*
 * terrain_subdivision.comp - LOD evaluation and adaptive subdivision
 * Each thread processes one leaf triangle and decides whether to split or merge
 * Height convention: see terrain_height_common.glsl
 *
 * Optimization: Inline frustum culling eliminates separate cull pass
 */

#include "../bindings.glsl"

#define CBT_BUFFER_BINDING BINDING_TERRAIN_CBT_BUFFER
#include "cbt.glsl"
#include "leb.glsl"
#include "../terrain_height_common.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for update mode and temporal spreading
layout(push_constant) uniform PushConstants {
    uint updateMode;       // 0 = split only, 1 = merge only
    uint frameIndex;       // For temporal spreading
    uint spreadFactor;     // Process 1/N triangles per frame (1 = all)
    uint reserved;         // Padding (was useCompactBuffer, now unused)
};

// Height map sampler (global coarse LOD - fallback for distant terrain)
layout(binding = BINDING_TERRAIN_HEIGHT_MAP) uniform sampler2D heightMap;

// LOD tile array (high-res tiles near camera)
layout(binding = BINDING_TERRAIN_TILE_ARRAY) uniform sampler2DArray heightMapTiles;

// Tile info buffer - world bounds for each active tile
struct TileInfo {
    vec4 worldBounds;    // xy = min corner, zw = max corner
    vec4 uvScaleOffset;  // xy = scale, zw = offset
};
layout(std430, binding = BINDING_TERRAIN_TILE_INFO) readonly buffer TileInfoBuffer {
    uint activeTileCount;
    uint padding1;
    uint padding2;
    uint padding3;
    TileInfo tiles[];
};

// Include tile cache common after defining prerequisites
#include "../tile_cache_common.glsl"

// Uniform buffer with camera and terrain parameters
layout(std140, binding = BINDING_TERRAIN_UBO) uniform TerrainUniforms {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    vec4 frustumPlanes[6];
    vec4 cameraPosition;
    vec4 terrainParams;   // x = size, y = height scale, z = target edge pixels, w = max depth
    vec4 lodParams;       // x = split threshold, y = merge threshold, z = min depth, w = subdivisionPhase (0=split, 1=merge)
    vec2 screenSize;
    float lodFactor;
    float flatnessScale;  // How much flat areas reduce subdivision (0=disabled, 2=3x threshold for flat)
};

// Subdivision phase: 0 = split only, 1 = merge only
#define SUBDIVISION_PHASE (int(lodParams.w))

// Extract parameters
#define TERRAIN_SIZE (terrainParams.x)
#define HEIGHT_SCALE (terrainParams.y)
#define TARGET_EDGE_PIXELS (terrainParams.z)
#define MAX_DEPTH (int(terrainParams.w))
#define SPLIT_THRESHOLD (lodParams.x)
#define MERGE_THRESHOLD (lodParams.y)
#define MIN_DEPTH (int(lodParams.z))

// Sample terrain height at UV coordinate with tile cache support
// Uses high-res tiles near camera, falls back to global heightmap for distant terrain
float sampleHeight(vec2 uv) {
    vec2 worldXZ = (uv - 0.5) * TERRAIN_SIZE;
    return sampleHeightWithTileCache(heightMap, heightMapTiles, uv, worldXZ,
                                     HEIGHT_SCALE, activeTileCount);
}

// Estimate curvature using Laplacian approximation (second derivative)
// Returns normalized curvature in [0, 1] range
float estimateCurvature(vec2 uv, float step) {
    float h00 = sampleHeight(uv);
    float h10 = sampleHeight(uv + vec2(step, 0.0));
    float h01 = sampleHeight(uv + vec2(0.0, step));
    float h11 = sampleHeight(uv + vec2(step, step));

    // Mixed partial derivative approximation
    float curvature = abs(h00 + h11 - h10 - h01);
    return clamp(curvature / HEIGHT_SCALE, 0.0, 1.0);
}

// Compute curvature-adjusted threshold for a triangle
float computeAdjustedThreshold(vec2 v0, vec2 v1, vec2 v2) {
    vec2 triCenter = (v0 + v1 + v2) / 3.0;
    vec2 longestEdge = v2 - v1;  // LEB property: longest edge is v1-v2
    float triangleUVSize = length(longestEdge);

    // Step size: fraction of triangle, but at least one texel
    vec2 texelSize = 1.0 / vec2(textureSize(heightMap, 0));
    float sampleStep = max(triangleUVSize * 0.25, max(texelSize.x, texelSize.y));

    float curvature = estimateCurvature(triCenter, sampleStep);

    // High curvature -> threshold stays near SPLIT_THRESHOLD
    // Low curvature -> threshold increases (less subdivision)
    return SPLIT_THRESHOLD * (1.0 + flatnessScale * (1.0 - curvature));
}

// Transform UV to world position
vec3 uvToWorldPos(vec2 uv) {
    float height = sampleHeight(uv);
    return vec3(
        (uv.x - 0.5) * TERRAIN_SIZE,
        height,
        (uv.y - 0.5) * TERRAIN_SIZE
    );
}

// Frustum culling test for AABB with optional margin
// margin > 0 expands the frustum outward (triangle must be further outside to be culled)
bool frustumCullAABB(vec3 minBound, vec3 maxBound, float margin) {
    for (int i = 0; i < 6; i++) {
        vec4 plane = frustumPlanes[i];
        vec3 pVertex = vec3(
            plane.x > 0.0 ? maxBound.x : minBound.x,
            plane.y > 0.0 ? maxBound.y : minBound.y,
            plane.z > 0.0 ? maxBound.z : minBound.z
        );
        // Offset the plane by margin (planes are normalized, so margin is in world units)
        if (dot(vec4(pVertex, 1.0), plane) < -margin) {
            return true; // Culled
        }
    }
    return false; // Visible
}

bool frustumCullAABB(vec3 minBound, vec3 maxBound) {
    return frustumCullAABB(minBound, maxBound, 0.0);
}

// Compute screen-space edge length
float computeScreenSpaceEdgeLength(vec3 p0, vec3 p1) {
    // Project both points to clip space
    vec4 c0 = viewProjMatrix * vec4(p0, 1.0);
    vec4 c1 = viewProjMatrix * vec4(p1, 1.0);

    // Handle behind-camera cases
    if (c0.w <= 0.0 || c1.w <= 0.0) {
        return 1e6; // Force split for edges behind camera
    }

    // Perspective divide to NDC
    vec2 ndc0 = c0.xy / c0.w;
    vec2 ndc1 = c1.xy / c1.w;

    // Convert to pixels
    vec2 s0 = (ndc0 * 0.5 + 0.5) * screenSize;
    vec2 s1 = (ndc1 * 0.5 + 0.5) * screenSize;

    return length(s1 - s0);
}

// Compute LOD for a triangle - returns longest edge length in pixels
// Takes pre-computed world positions to avoid redundant heightmap samples
float computeTriangleLOD(vec3 p0, vec3 p1, vec3 p2) {
    // In LEB, the longest edge is always between v1 and v2
    return computeScreenSpaceEdgeLength(p1, p2);
}

void main() {
    uint leafIndex = gl_GlobalInvocationID.x;

    // Direct indexing - inline frustum culling eliminates stream compaction
    uint totalLeaves = cbt_NodeCount();
    if (leafIndex >= totalLeaves) {
        return;
    }

    // Phase 1: Decode node (unavoidable - needed for depth check)
    cbt_Node node = cbt_DecodeNode(leafIndex);
    int depth = node.depth;

    // Phase 2: Early-out on depth limits (before any expensive work)
    if (updateMode == 0u) {
        // Split phase: cannot split triangles already at max depth
        if (depth >= MAX_DEPTH) {
            return;  // EARLY-OUT: max depth reached
        }
    } else {
        // Merge phase: cannot merge triangles at min depth
        if (depth <= MIN_DEPTH) {
            return;  // EARLY-OUT: min depth reached
        }
    }

    // Phase 2b: Temporal spreading - process only 1/N triangles per frame
    // Skip deep triangles (far from camera) to spread work over frames
    // Shallow triangles (large, near camera) always update for responsiveness
    if (spreadFactor > 1u && depth > MIN_DEPTH + 4) {
        // For merge phase, use leafIndex/2 to keep diamond sibling pairs synchronized
        uint spreadIndex = (updateMode == 1u) ? leafIndex / 2u : leafIndex;
        if ((spreadIndex + frameIndex) % spreadFactor != 0u) {
            return;  // EARLY-OUT: not our turn this frame
        }
    }

    // Phase 3: Decode triangle vertices
    vec2 v0, v1, v2;
    leb_DecodeTriangleVertices(node, v0, v1, v2);

    // Phase 4: Get world positions and compute AABB
    vec3 p0 = uvToWorldPos(v0);
    vec3 p1 = uvToWorldPos(v1);
    vec3 p2 = uvToWorldPos(v2);

    vec3 minBound = min(min(p0, p1), p2);
    vec3 maxBound = max(max(p0, p1), p2);
    // Add height margin for terrain that might be displaced
    minBound.y -= HEIGHT_SCALE * 0.1;
    maxBound.y += HEIGHT_SCALE * 0.1;

    // Phase 5: Phase-specific logic with optimized ordering
    if (updateMode == 0u) {
        // Split phase: inline frustum culling (eliminates separate cull pass)
        // Early-out if triangle is outside frustum - no need to compute LOD
        if (frustumCullAABB(minBound, maxBound)) {
            return;  // EARLY-OUT: outside frustum, no split needed
        }

        // Visible triangle - compute LOD and split if needed
        float edgeLengthPixels = computeTriangleLOD(p0, p1, p2);
        float adjustedThreshold = computeAdjustedThreshold(v0, v1, v2);
        if (edgeLengthPixels > adjustedThreshold) {
            leb_SplitNode_Square(node);
        }
    } else {
        // Merge phase: need diamond parent for merge operation
        leb_DiamondParent diamond = leb_DecodeDiamondParent_Square(node);

        // Compute AABB diagonal for frustum margin (hysteresis)
        vec3 aabbDiag = maxBound - minBound;
        float aabbDiagonal = length(aabbDiag);
        float mergeCullMargin = aabbDiagonal * 0.5;

        // Use expanded frustum for merge decisions to prevent flickering
        if (frustumCullAABB(minBound, maxBound, mergeCullMargin)) {
            // Well outside frustum - merge without LOD check
            leb_MergeNode_Square(node, diamond);
        } else {
            // Visible: check if parent would have acceptable LOD before merging
            // This prevents oscillation (merge then immediate re-split)
            vec2 pv0, pv1, pv2;
            leb_DecodeTriangleVertices(diamond.base, pv0, pv1, pv2);

            // Compute parent world positions (needed for LOD - can't reuse child positions)
            vec3 pp0 = uvToWorldPos(pv0);
            vec3 pp1 = uvToWorldPos(pv1);
            vec3 pp2 = uvToWorldPos(pv2);
            float parentLOD = computeTriangleLOD(pp0, pp1, pp2);
            float adjustedThreshold = computeAdjustedThreshold(pv0, pv1, pv2);

            if (parentLOD < adjustedThreshold) {
                leb_MergeNode_Square(node, diamond);
            }
        }
    }
}

#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

// Scene Object GPU Culling Compute Shader
// Performs frustum culling + Hi-Z occlusion culling on scene objects
// and generates indirect draw commands via subgroup-batched atomics.

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "hiz_occlusion_common.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Input: Object culling data
struct CullObjectData {
    vec4 boundingSphere;   // xyz = center (world space), w = radius
    vec4 aabbMin;          // xyz = min corner, w = unused
    vec4 aabbMax;          // xyz = max corner, w = unused
    uint objectIndex;      // Index into scene instance buffer
    uint firstIndex;       // First index in index buffer
    uint indexCount;       // Number of indices
    int vertexOffset;      // Vertex offset
};

// Culling uniforms
layout(std140, binding = BINDING_SCENE_CULL_UNIFORMS) uniform CullUniforms {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    vec4 frustumPlanes[6];     // Frustum planes (xyz=normal, w=distance)
    vec4 cameraPosition;       // xyz = camera pos, w = unused
    vec4 screenParams;         // x = width, y = height, z = 1/width, w = 1/height
    vec4 depthParams;          // x = near, y = far, z = numMipLevels, w = unused
    uint objectCount;          // Number of objects to cull
    uint enableHiZ;            // 1 = use Hi-Z occlusion, 0 = frustum only
    uint maxDrawCommands;      // Output buffer capacity
    uint padding;
} cullUniforms;

// Input: Objects to cull
layout(std430, binding = BINDING_SCENE_CULL_OBJECTS) readonly buffer ObjectBuffer {
    CullObjectData objects[];
};

// Output: Indirect draw commands
layout(std430, binding = BINDING_SCENE_CULL_INDIRECT) writeonly buffer IndirectBuffer {
    DrawIndexedIndirectCommand commands[];
};

// Output: Draw count (atomic)
layout(std430, binding = BINDING_SCENE_CULL_COUNT) buffer DrawCountBuffer {
    uint drawCount;
};

// Hi-Z pyramid for occlusion culling
layout(binding = BINDING_SCENE_CULL_HIZ) uniform sampler2D hiZPyramid;

// Frustum test using bounding sphere (fast early rejection)
bool frustumCullSphere(vec3 center, float radius) {
    for (int i = 0; i < 6; ++i) {
        float dist = dot(cullUniforms.frustumPlanes[i].xyz, center) + cullUniforms.frustumPlanes[i].w;
        if (dist < -radius) {
            return true;  // Culled
        }
    }
    return false;  // Visible
}

void main() {
    uint objectIdx = gl_GlobalInvocationID.x;

    if (objectIdx >= cullUniforms.objectCount) {
        return;
    }

    CullObjectData obj = objects[objectIdx];

    // Step 1: Frustum culling — sphere test (fast rejection)
    vec3 sphereCenter = obj.boundingSphere.xyz;
    float sphereRadius = obj.boundingSphere.w;

    if (frustumCullSphere(sphereCenter, sphereRadius)) {
        return;
    }

    // Step 2: Frustum culling — precise AABB test
    vec3 aabbMin = obj.aabbMin.xyz;
    vec3 aabbMax = obj.aabbMax.xyz;

    if (!isAABBInFrustum(cullUniforms.frustumPlanes, aabbMin, aabbMax)) {
        return;
    }

    // Step 3: Hi-Z occlusion culling
    if (cullUniforms.enableHiZ != 0u) {
        float maxMip = cullUniforms.depthParams.z - 1.0;
        if (hizOcclusionTestAABB(aabbMin, aabbMax, hiZPyramid,
                                 cullUniforms.viewProjMatrix,
                                 cullUniforms.screenParams, maxMip)) {
            return;  // Occluded
        }
    }

    // Object is visible — use subgroup operations to batch atomic updates
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    uint baseIdx = 0;
    uint slotsAllocated = 0;
    if (subgroupElect()) {
        uint expected = drawCount;
        while (true) {
            uint available = (expected >= cullUniforms.maxDrawCommands)
                ? 0
                : cullUniforms.maxDrawCommands - expected;
            slotsAllocated = min(activeCount, available);
            if (slotsAllocated == 0) {
                baseIdx = expected;
                break;
            }
            uint desired = expected + slotsAllocated;
            uint actual = atomicCompSwap(drawCount, expected, desired);
            if (actual == expected) {
                baseIdx = expected;
                break;
            }
            expected = actual;
        }
    }
    baseIdx = subgroupBroadcastFirst(baseIdx);
    slotsAllocated = subgroupBroadcastFirst(slotsAllocated);
    uint drawIdx = baseIdx + laneOffset;

    // Only write if we got a valid slot within bounds
    if (laneOffset >= slotsAllocated) {
        return;
    }

    // Write indirect draw command
    commands[drawIdx].indexCount = obj.indexCount;
    commands[drawIdx].instanceCount = 1;
    commands[drawIdx].firstIndex = obj.firstIndex;
    commands[drawIdx].vertexOffset = obj.vertexOffset;
    commands[drawIdx].firstInstance = obj.objectIndex;  // gl_InstanceIndex in vertex shader
}

#version 450

/*
 * gtao_spatial_filter.comp - Bilateral Spatial Filter for GTAO
 *
 * Applies edge-preserving blur to the AO buffer using depth-based
 * bilateral weights. This smooths noise while preserving edges at
 * depth discontinuities.
 */

#extension GL_GOOGLE_include_directive : require

#include "bindings.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input textures
layout(binding = BINDING_GTAO_FILTER_INPUT) uniform sampler2D aoInput;
layout(binding = BINDING_GTAO_FILTER_DEPTH) uniform sampler2D depthTexture;

// Output filtered AO
layout(binding = BINDING_GTAO_FILTER_OUTPUT, r8) uniform writeonly image2D aoOutput;

// Push constants
layout(push_constant) uniform FilterParams {
    vec2 resolution;
    vec2 texelSize;
    float depthThreshold;
    float blurSharpness;
    float padding1;
    float padding2;
};

// Gaussian weights for 3x3 kernel
const float gaussianWeights[9] = float[](
    0.0625, 0.125, 0.0625,
    0.125,  0.25,  0.125,
    0.0625, 0.125, 0.0625
);

// Sample offsets for 3x3 kernel
const ivec2 sampleOffsets[9] = ivec2[](
    ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),
    ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0),
    ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1)
);

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    if (pixelCoord.x >= int(resolution.x) || pixelCoord.y >= int(resolution.y)) {
        return;
    }

    vec2 uv = (vec2(pixelCoord) + 0.5) / resolution;

    // Get center depth and AO
    float centerDepth = texture(depthTexture, uv).r;
    float centerAO = texture(aoInput, uv).r;

    // Skip sky pixels
    if (centerDepth >= 0.9999) {
        imageStore(aoOutput, pixelCoord, vec4(1.0));
        return;
    }

    float totalWeight = 0.0;
    float totalAO = 0.0;

    // 3x3 bilateral filter
    for (int i = 0; i < 9; i++) {
        vec2 sampleUV = uv + vec2(sampleOffsets[i]) * texelSize;

        // Clamp to screen bounds
        sampleUV = clamp(sampleUV, vec2(0.0), vec2(1.0));

        float sampleDepth = texture(depthTexture, sampleUV).r;
        float sampleAO = texture(aoInput, sampleUV).r;

        // Bilateral weight based on depth difference
        float depthDiff = abs(sampleDepth - centerDepth);
        float depthWeight = exp(-depthDiff * blurSharpness / depthThreshold);

        // Combined weight: Gaussian spatial * bilateral depth
        float weight = gaussianWeights[i] * depthWeight;

        totalAO += sampleAO * weight;
        totalWeight += weight;
    }

    // Normalize
    float filteredAO = (totalWeight > 0.001) ? (totalAO / totalWeight) : centerAO;

    imageStore(aoOutput, pixelCoord, vec4(filteredAO));
}

#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"

// Hi-Z Occlusion Culling Compute Shader
// Performs frustum culling followed by hierarchical z-buffer occlusion culling
// Outputs visible objects to an indirect draw buffer

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Object data structure (matches CullObjectData in C++)
struct CullObjectData {
    vec4 boundingSphere;    // xyz = center (world space), w = radius
    vec4 aabbMin;           // xyz = min corner (world space), w = unused
    vec4 aabbMax;           // xyz = max corner (world space), w = unused
    uint meshIndex;         // Index into mesh data for indirect draw
    uint firstIndex;        // First index in index buffer
    uint indexCount;        // Number of indices
    uint vertexOffset;      // Vertex offset
};

// Indirect draw command (matches VkDrawIndexedIndirectCommand)
struct DrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

// Culling uniforms
layout(std140, binding = BINDING_HIZ_CULL_UNIFORMS) uniform HiZCullUniforms {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    vec4 frustumPlanes[6];      // Frustum planes for culling
    vec4 cameraPosition;        // xyz = camera pos, w = unused
    vec4 screenParams;          // x = width, y = height, z = 1/width, w = 1/height
    vec4 depthParams;           // x = near, y = far, z = numMipLevels, w = unused
    uint objectCount;           // Number of objects to cull
    uint enableHiZ;             // 1 = use Hi-Z, 0 = frustum only
    uint padding[2];
} uniforms;

// Input: Object data
layout(std430, binding = BINDING_HIZ_CULL_OBJECTS) readonly buffer ObjectDataBuffer {
    CullObjectData objects[];
};

// Output: Indirect draw commands
layout(std430, binding = BINDING_HIZ_CULL_INDIRECT) writeonly buffer IndirectDrawBuffer {
    DrawIndexedIndirectCommand drawCommands[];
};

// Output: Draw count (atomic counter)
layout(std430, binding = BINDING_HIZ_CULL_COUNT) buffer DrawCountBuffer {
    uint drawCount;
};

// Hi-Z pyramid texture
layout(binding = BINDING_HIZ_CULL_PYRAMID) uniform sampler2D hiZPyramid;

// Check if AABB is completely outside a plane
bool isOutsidePlane(vec4 plane, vec3 aabbMin, vec3 aabbMax) {
    // Find the corner most in the direction of the plane normal
    vec3 pVertex = vec3(
        plane.x > 0.0 ? aabbMax.x : aabbMin.x,
        plane.y > 0.0 ? aabbMax.y : aabbMin.y,
        plane.z > 0.0 ? aabbMax.z : aabbMin.z
    );

    // If the positive vertex is behind the plane, the AABB is completely outside
    return dot(vec4(pVertex, 1.0), plane) < 0.0;
}

// Frustum culling test for AABB
bool frustumCullAABB(vec3 aabbMin, vec3 aabbMax) {
    // Test against all 6 frustum planes
    for (int i = 0; i < 6; i++) {
        if (isOutsidePlane(uniforms.frustumPlanes[i], aabbMin, aabbMax)) {
            return true;  // Culled
        }
    }
    return false;  // Visible
}

// Frustum culling test for bounding sphere (faster but less precise)
bool frustumCullSphere(vec3 center, float radius) {
    for (int i = 0; i < 6; i++) {
        float dist = dot(vec4(center, 1.0), uniforms.frustumPlanes[i]);
        if (dist < -radius) {
            return true;  // Completely outside
        }
    }
    return false;  // At least partially visible
}

// Project AABB to screen space and get bounding rectangle
// Returns: xy = min screen coord, zw = max screen coord (in pixels)
vec4 projectAABBToScreen(vec3 aabbMin, vec3 aabbMax) {
    // Project all 8 corners
    vec3 corners[8];
    corners[0] = vec3(aabbMin.x, aabbMin.y, aabbMin.z);
    corners[1] = vec3(aabbMax.x, aabbMin.y, aabbMin.z);
    corners[2] = vec3(aabbMin.x, aabbMax.y, aabbMin.z);
    corners[3] = vec3(aabbMax.x, aabbMax.y, aabbMin.z);
    corners[4] = vec3(aabbMin.x, aabbMin.y, aabbMax.z);
    corners[5] = vec3(aabbMax.x, aabbMin.y, aabbMax.z);
    corners[6] = vec3(aabbMin.x, aabbMax.y, aabbMax.z);
    corners[7] = vec3(aabbMax.x, aabbMax.y, aabbMax.z);

    vec2 minScreen = vec2(1e10);
    vec2 maxScreen = vec2(-1e10);
    float closestZ = 1.0;  // Closest depth (largest value in reversed-Z)

    for (int i = 0; i < 8; i++) {
        vec4 clipPos = uniforms.viewProjMatrix * vec4(corners[i], 1.0);

        // Handle behind camera
        if (clipPos.w <= 0.0) {
            // Corner is behind camera, expand to full screen
            return vec4(0.0, 0.0, uniforms.screenParams.x, uniforms.screenParams.y);
        }

        // Perspective divide
        vec3 ndc = clipPos.xyz / clipPos.w;

        // Convert to screen coordinates
        vec2 screen = (ndc.xy * 0.5 + 0.5) * uniforms.screenParams.xy;

        minScreen = min(minScreen, screen);
        maxScreen = max(maxScreen, screen);

        // Track closest depth (for reversed-Z, closest = largest value)
        closestZ = max(closestZ, ndc.z);
    }

    // Clamp to screen bounds
    minScreen = max(minScreen, vec2(0.0));
    maxScreen = min(maxScreen, uniforms.screenParams.xy);

    return vec4(minScreen, maxScreen);
}

// Get the closest (maximum in reversed-Z) depth value of the AABB
float getClosestDepth(vec3 aabbMin, vec3 aabbMax) {
    // Project all 8 corners and find closest
    vec3 corners[8];
    corners[0] = vec3(aabbMin.x, aabbMin.y, aabbMin.z);
    corners[1] = vec3(aabbMax.x, aabbMin.y, aabbMin.z);
    corners[2] = vec3(aabbMin.x, aabbMax.y, aabbMin.z);
    corners[3] = vec3(aabbMax.x, aabbMax.y, aabbMin.z);
    corners[4] = vec3(aabbMin.x, aabbMin.y, aabbMax.z);
    corners[5] = vec3(aabbMax.x, aabbMin.y, aabbMax.z);
    corners[6] = vec3(aabbMin.x, aabbMax.y, aabbMax.z);
    corners[7] = vec3(aabbMax.x, aabbMax.y, aabbMax.z);

    float closestZ = 0.0;  // Farthest in reversed-Z

    for (int i = 0; i < 8; i++) {
        vec4 clipPos = uniforms.viewProjMatrix * vec4(corners[i], 1.0);
        if (clipPos.w > 0.0) {
            float ndcZ = clipPos.z / clipPos.w;
            closestZ = max(closestZ, ndcZ);
        }
    }

    return closestZ;
}

// Hi-Z occlusion test
// Returns true if object is occluded (should be culled)
bool hiZOcclusionTest(vec3 aabbMin, vec3 aabbMax) {
    // Project AABB to screen
    vec4 screenRect = projectAABBToScreen(aabbMin, aabbMax);

    // Check if completely off screen
    if (screenRect.x >= screenRect.z || screenRect.y >= screenRect.w) {
        return true;  // Culled (off screen)
    }

    // Calculate the size of the projected rectangle
    vec2 rectSize = screenRect.zw - screenRect.xy;

    // Choose mip level based on rectangle size
    // We want a mip where the rect covers roughly 2x2 texels
    float maxDim = max(rectSize.x, rectSize.y);
    float mipLevel = max(0.0, log2(maxDim) - 1.0);
    mipLevel = min(mipLevel, uniforms.depthParams.z - 1.0);

    // Sample Hi-Z at the center of the rectangle
    vec2 centerUV = (screenRect.xy + screenRect.zw) * 0.5 * uniforms.screenParams.zw;

    // Sample the Hi-Z pyramid
    float hiZDepth = textureLod(hiZPyramid, centerUV, mipLevel).r;

    // Get closest depth of the AABB
    float objectDepth = getClosestDepth(aabbMin, aabbMax);

    // In reversed-Z: larger depth = closer to camera
    // Object is occluded if its closest point is farther than the Hi-Z depth
    // (objectDepth < hiZDepth means object is behind what's in the depth buffer)
    return objectDepth < hiZDepth;
}

void main() {
    uint objectIndex = gl_GlobalInvocationID.x;

    // Early out if beyond object count
    if (objectIndex >= uniforms.objectCount) {
        return;
    }

    // Load object data
    CullObjectData obj = objects[objectIndex];
    vec3 aabbMin = obj.aabbMin.xyz;
    vec3 aabbMax = obj.aabbMax.xyz;

    // Step 1: Frustum culling (fast rejection)
    // Use sphere test first for quick rejection
    vec3 sphereCenter = obj.boundingSphere.xyz;
    float sphereRadius = obj.boundingSphere.w;

    if (frustumCullSphere(sphereCenter, sphereRadius)) {
        return;  // Culled by frustum (sphere)
    }

    // More precise AABB frustum test
    if (frustumCullAABB(aabbMin, aabbMax)) {
        return;  // Culled by frustum (AABB)
    }

    // Step 2: Hi-Z occlusion culling (if enabled)
    if (uniforms.enableHiZ != 0) {
        if (hiZOcclusionTest(aabbMin, aabbMax)) {
            return;  // Occluded
        }
    }

    // Use subgroup operations to batch atomic updates
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    uint baseIdx = 0;
    if (subgroupElect()) {
        baseIdx = atomicAdd(drawCount, activeCount);
    }
    baseIdx = subgroupBroadcastFirst(baseIdx);
    uint drawIndex = baseIdx + laneOffset;

    // Write indirect draw command
    drawCommands[drawIndex].indexCount = obj.indexCount;
    drawCommands[drawIndex].instanceCount = 1;
    drawCommands[drawIndex].firstIndex = obj.firstIndex;
    drawCommands[drawIndex].vertexOffset = int(obj.vertexOffset);
    drawCommands[drawIndex].firstInstance = objectIndex;  // Pass object index for per-instance data
}

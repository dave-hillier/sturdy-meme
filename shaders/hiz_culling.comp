#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "hiz_occlusion_common.glsl"

// Hi-Z Occlusion Culling Compute Shader
// Performs frustum culling followed by hierarchical z-buffer occlusion culling
// Outputs visible objects to an indirect draw buffer
//
// This shader is used by HiZSystem for its own culling pipeline.
// The occlusion test logic is shared with scene_cull.comp via hiz_occlusion_common.glsl.

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Object data structure (matches CullObjectData in C++)
struct CullObjectData {
    vec4 boundingSphere;    // xyz = center (world space), w = radius
    vec4 aabbMin;           // xyz = min corner (world space), w = unused
    vec4 aabbMax;           // xyz = max corner (world space), w = unused
    uint meshIndex;         // Index into mesh data for indirect draw
    uint firstIndex;        // First index in index buffer
    uint indexCount;        // Number of indices
    uint vertexOffset;      // Vertex offset
};

// Note: DrawIndexedIndirectCommand is defined in instancing_common.glsl

// Culling uniforms
layout(std140, binding = BINDING_HIZ_CULL_UNIFORMS) uniform HiZCullUniforms {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    vec4 frustumPlanes[6];      // Frustum planes for culling
    vec4 cameraPosition;        // xyz = camera pos, w = unused
    vec4 screenParams;          // x = width, y = height, z = 1/width, w = 1/height
    vec4 depthParams;           // x = near, y = far, z = numMipLevels, w = unused
    uint objectCount;           // Number of objects to cull
    uint enableHiZ;             // 1 = use Hi-Z, 0 = frustum only
    uint maxDrawCommands;       // Output buffer capacity
    uint padding;
} uniforms;

// Input: Object data
layout(std430, binding = BINDING_HIZ_CULL_OBJECTS) readonly buffer ObjectDataBuffer {
    CullObjectData objects[];
};

// Output: Indirect draw commands
layout(std430, binding = BINDING_HIZ_CULL_INDIRECT) writeonly buffer IndirectDrawBuffer {
    DrawIndexedIndirectCommand drawCommands[];
};

// Output: Draw count (atomic counter)
layout(std430, binding = BINDING_HIZ_CULL_COUNT) buffer DrawCountBuffer {
    uint drawCount;
};

// Hi-Z pyramid texture
layout(binding = BINDING_HIZ_CULL_PYRAMID) uniform sampler2D hiZPyramid;

// Frustum culling test for bounding sphere (faster but less precise)
bool frustumCullSphere(vec3 center, float radius) {
    for (int i = 0; i < 6; i++) {
        float dist = dot(vec4(center, 1.0), uniforms.frustumPlanes[i]);
        if (dist < -radius) {
            return true;  // Completely outside
        }
    }
    return false;  // At least partially visible
}

void main() {
    uint objectIndex = gl_GlobalInvocationID.x;

    // Early out if beyond object count
    if (objectIndex >= uniforms.objectCount) {
        return;
    }

    // Load object data
    CullObjectData obj = objects[objectIndex];
    vec3 aabbMin = obj.aabbMin.xyz;
    vec3 aabbMax = obj.aabbMax.xyz;

    // Step 1: Frustum culling (fast rejection)
    vec3 sphereCenter = obj.boundingSphere.xyz;
    float sphereRadius = obj.boundingSphere.w;

    if (frustumCullSphere(sphereCenter, sphereRadius)) {
        return;
    }

    if (!isAABBInFrustum(uniforms.frustumPlanes, aabbMin, aabbMax)) {
        return;
    }

    // Step 2: Hi-Z occlusion culling (if enabled)
    if (uniforms.enableHiZ != 0) {
        float maxMip = uniforms.depthParams.z - 1.0;
        if (hizOcclusionTestAABB(aabbMin, aabbMax, hiZPyramid,
                                 uniforms.viewProjMatrix,
                                 uniforms.screenParams, maxMip)) {
            return;  // Occluded
        }
    }

    // Use subgroup operations to batch atomic updates
    uvec4 activeMask = subgroupBallot(true);
    uint activeCount = subgroupBallotBitCount(activeMask);
    uint laneOffset = subgroupBallotExclusiveBitCount(activeMask);

    // Use compare-and-swap to only allocate slots within buffer capacity
    uint baseIdx = 0;
    uint slotsAllocated = 0;
    if (subgroupElect()) {
        uint expected = drawCount;
        while (true) {
            uint available = (expected >= uniforms.maxDrawCommands)
                ? 0
                : uniforms.maxDrawCommands - expected;
            slotsAllocated = min(activeCount, available);
            if (slotsAllocated == 0) {
                baseIdx = expected;
                break;
            }
            uint desired = expected + slotsAllocated;
            uint actual = atomicCompSwap(drawCount, expected, desired);
            if (actual == expected) {
                baseIdx = expected;
                break;
            }
            expected = actual;
        }
    }
    baseIdx = subgroupBroadcastFirst(baseIdx);
    slotsAllocated = subgroupBroadcastFirst(slotsAllocated);
    uint drawIndex = baseIdx + laneOffset;

    // Only write if we got a valid slot within bounds
    if (laneOffset >= slotsAllocated) {
        return;
    }

    // Write indirect draw command
    drawCommands[drawIndex].indexCount = obj.indexCount;
    drawCommands[drawIndex].instanceCount = 1;
    drawCommands[drawIndex].firstIndex = obj.firstIndex;
    drawCommands[drawIndex].vertexOffset = int(obj.vertexOffset);
    drawCommands[drawIndex].firstInstance = objectIndex;  // Pass object index for per-instance data
}

#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "bindings.glsl"
#include "instancing_common.glsl"
#include "cull_compute_common.glsl"

layout(local_size_x = 256) in;

// Input: all tree transforms
struct BranchShadowInput {
    vec4 positionAndScale;     // xyz = position, w = scale
    vec4 rotationAndArchetype; // x = rotation (radians), y = meshIndex, z = archetypeIndex, w = boundingRadius (local-space)
};

layout(std430, binding = BINDING_TREE_BRANCH_SHADOW_INPUT) readonly buffer InputBuffer {
    BranchShadowInput trees[];
};

// Output: visible branch instances with pre-computed model matrices
struct BranchShadowInstance {
    mat4 model;
};

layout(std430, binding = BINDING_TREE_BRANCH_SHADOW_OUTPUT) writeonly buffer OutputBuffer {
    BranchShadowInstance instances[];
};

// Indirect draw commands (one per mesh group)
// Uses DrawIndexedIndirectCommand from instancing_common.glsl
layout(std430, binding = BINDING_TREE_BRANCH_SHADOW_INDIRECT) buffer IndirectBuffer {
    DrawIndexedIndirectCommand drawCmds[];
};

// Mesh group metadata
struct MeshGroupData {
    uint meshIndex;
    uint firstTree;
    uint treeCount;
    uint barkTypeIndex;
    uint indexCount;
    uint maxInstances;
    uint outputOffset;
    uint _pad0;
};

layout(std430, binding = BINDING_TREE_BRANCH_SHADOW_GROUPS) readonly buffer GroupBuffer {
    MeshGroupData meshGroups[];
};

layout(binding = BINDING_TREE_BRANCH_SHADOW_UNIFORMS) uniform CullUniforms {
    vec4 cameraPosition;
    vec4 cascadeFrustumPlanes[6];
    float fullDetailDistance;
    float hysteresis;
    uint cascadeIndex;
    uint numTrees;
    uint numMeshGroups;
    uint _pad0;
    uint _pad1;
    uint _pad2;
} uniforms;

// Frustum culling uses isSphereInFrustum from cull_compute_common.glsl

// Maximum mesh groups to prevent GPU hang from garbage uniform data
const uint MAX_MESH_GROUPS = 16u;

void main() {
    uint treeIdx = gl_GlobalInvocationID.x;

    // Clamp to prevent infinite loop if uniform data is garbage
    uint safeNumMeshGroups = min(uniforms.numMeshGroups, MAX_MESH_GROUPS);

    // Initialize indirect commands (first thread in first workgroup)
    if (gl_LocalInvocationID.x == 0 && gl_WorkGroupID.x == 0) {
        for (uint g = 0; g < safeNumMeshGroups; g++) {
            drawCmds[g].indexCount = meshGroups[g].indexCount;
            drawCmds[g].instanceCount = 0;
            drawCmds[g].firstIndex = 0;
            drawCmds[g].vertexOffset = 0;
            drawCmds[g].firstInstance = 0;
        }
    }
    barrier();
    memoryBarrierBuffer();

    // Early exit if no work to do (also prevents buffer access with uninitialized data)
    if (treeIdx >= uniforms.numTrees || safeNumMeshGroups == 0) return;

    BranchShadowInput tree = trees[treeIdx];
    vec3 treePos = tree.positionAndScale.xyz;
    float treeScale = tree.positionAndScale.w;

    // LOD check: only render full geometry for close trees
    float distToCamera = length(treePos - uniforms.cameraPosition.xyz);
    if (distToCamera > uniforms.fullDetailDistance + uniforms.hysteresis) {
        return; // Too far, will be rendered as impostor
    }

    // Get actual mesh bounding radius from CPU-computed AABB half-diagonal
    // This is passed in w component, in local (unscaled) space
    float localBoundingRadius = tree.rotationAndArchetype.w;
    float boundingRadius = localBoundingRadius * treeScale;

    // Center the bounding sphere at estimated tree center
    // For vertical trees, the AABB center height is approximately equal to the radius
    vec3 boundingCenter = treePos + vec3(0.0, boundingRadius, 0.0);

    // Frustum culling against cascade light frustum with margin for shadow projection
    // Shadows can extend beyond the tree depending on light angle
    float shadowMargin = boundingRadius * 0.5;
    if (!isSphereInFrustum(boundingCenter, boundingRadius + shadowMargin, uniforms.cascadeFrustumPlanes)) {
        return;
    }

    // Find mesh group for this tree (use clamped value to prevent GPU hang)
    uint meshIdx = floatBitsToUint(tree.rotationAndArchetype.y);
    uint groupIdx = 0;
    for (uint g = 0; g < safeNumMeshGroups; g++) {
        if (meshGroups[g].meshIndex == meshIdx) {
            groupIdx = g;
            break;
        }
    }

    // Use subgroup operations to batch atomic updates per mesh group
    uint slot = ~0u;
    uint maxInstances = meshGroups[groupIdx].maxInstances;

    for (uint g = 0; g < MAX_MESH_GROUPS; g++) {
        uvec4 groupMask = subgroupBallot(groupIdx == g);
        uint groupCount = subgroupBallotBitCount(groupMask);

        if (groupCount > 0) {
            uint electedLane = subgroupBallotFindLSB(groupMask);
            uint baseSlot = 0;

            if (gl_SubgroupInvocationID == electedLane) {
                baseSlot = atomicAdd(drawCmds[g].instanceCount, groupCount);
            }

            baseSlot = subgroupBroadcast(baseSlot, electedLane);

            if (groupIdx == g) {
                uint laneOffset = subgroupBallotExclusiveBitCount(groupMask);
                slot = baseSlot + laneOffset;
            }
        }
    }

    if (slot >= maxInstances) {
        return;
    }

    // Build model matrix
    float rotation = tree.rotationAndArchetype.x;
    float c = cos(rotation);
    float s = sin(rotation);

    mat4 model = mat4(1.0);
    // Scale
    model[0][0] = c * treeScale;
    model[0][2] = s * treeScale;
    model[1][1] = treeScale;
    model[2][0] = -s * treeScale;
    model[2][2] = c * treeScale;
    // Translation
    model[3] = vec4(treePos, 1.0);

    // Write to output
    uint outputIdx = meshGroups[groupIdx].outputOffset + slot;
    instances[outputIdx].model = model;
}
